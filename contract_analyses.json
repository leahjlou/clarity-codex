[
  {
    "rank": 1,
    "contract": "SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01",
    "calls": 26905,
    "source": "(use-trait ft-trait .trait-sip-010.sip-010-trait)\n(define-constant ERR-NOT-AUTHORIZED (err u1000))\n(define-constant ERR-POOL-ALREADY-EXISTS (err u2000))\n(define-constant ERR-INVALID-POOL (err u2001))\n(define-constant ERR-BLOCKLISTED (err u2002))\n(define-constant ERR-INVALID-LIQUIDITY (err u2003))\n(define-constant ERR-PERCENT-GREATER-THAN-ONE (err u2004))\n(define-constant ERR-EXCEEDS-MAX-SLIPPAGE (err u2005))\n(define-constant ERR-ORACLE-NOT-ENABLED (err u2006))\n(define-constant ERR-ORACLE-AVERAGE-BIGGER-THAN-ONE (err u2007))\n(define-constant ERR-PAUSED (err u2008))\n(define-constant ERR-SWITCH-THRESHOLD-BIGGER-THAN-ONE (err u2009))\n(define-constant ERR-NO-LIQUIDITY (err u2010))\n(define-constant ERR-MAX-IN-RATIO (err u2011))\n(define-constant ERR-MAX-OUT-RATIO (err u2012))\n(define-data-var paused bool true)\n(define-read-only (is-dao-or-extension)\n    (ok (asserts! (or (is-eq tx-sender .executor-dao) (contract-call? .executor-dao is-extension contract-caller)) ERR-NOT-AUTHORIZED)))\n(define-read-only (is-blocklisted-or-default (sender principal))\n\t(contract-call? .amm-registry-v2-01 is-blocklisted-or-default sender))\n(define-read-only (get-switch-threshold)\n    (contract-call? .amm-registry-v2-01 get-switch-threshold))\n(define-read-only (get-pool-details-by-id (pool-id uint))\n    (contract-call? .amm-registry-v2-01 get-pool-details-by-id pool-id))\n(define-read-only (get-pool-details (token-x principal) (token-y principal) (factor uint))\n    (contract-call? .amm-registry-v2-01 get-pool-details token-x token-y factor))\n(define-read-only (get-pool-exists (token-x principal) (token-y principal) (factor uint))\n    (contract-call? .amm-registry-v2-01 get-pool-exists token-x token-y factor))\n(define-read-only (is-paused)\n\t(var-get paused))\n(define-read-only (get-balances (token-x principal) (token-y principal) (factor uint))\n\t(let (\n\t\t\t(pool (try! (get-pool-details token-x token-y factor)))\n\t\t)\n\t\t(ok {balance-x: (get balance-x pool), balance-y: (get balance-y pool)})))\n(define-read-only (get-start-block (token-x principal) (token-y principal) (factor uint))\n\t(ok (get start-block (try! (get-pool-details token-x token-y factor)))))\n(define-read-only (get-end-block (token-x principal) (token-y principal) (factor uint))\n\t(ok (get end-block (try! (get-pool-details token-x token-y factor)))))\n(define-read-only (get-max-in-ratio (token-x principal) (token-y principal) (factor uint))\n\t(ok (get max-in-ratio (try! (get-pool-details token-x token-y factor)))))\n(define-read-only (get-max-out-ratio (token-x principal) (token-y principal) (factor uint))\n\t(ok (get max-out-ratio (try! (get-pool-details token-x token-y factor)))))\n(define-read-only (check-pool-status (token-x principal) (token-y principal) (factor uint))\n\t(let (\n\t\t\t(pool (try! (get-pool-details token-x token-y factor)))\n\t\t)\n\t\t(ok (asserts! (and (>= block-height (get start-block pool)) (<= block-height (get end-block pool))) ERR-NOT-AUTHORIZED))))\n(define-read-only (get-oracle-enabled (token-x principal) (token-y principal) (factor uint))\n\t(ok (get oracle-enabled (try! (get-pool-details token-x token-y factor)))))\n(define-read-only (get-oracle-average (token-x principal) (token-y principal) (factor uint))\n\t(ok (get oracle-average (try! (get-pool-details token-x token-y factor)))))\n(define-read-only (get-oracle-resilient (token-x principal) (token-y principal) (factor uint))\n    (let (\n            (exists (is-some (get-pool-exists token-x token-y factor)))\n            (pool (if exists (try! (get-pool-details token-x token-y factor)) (try! (get-pool-details token-y token-x factor))))\n            (oracle-instant (try! (get-oracle-instant token-x token-y factor))))\n        (asserts! (get oracle-enabled pool) ERR-ORACLE-NOT-ENABLED)\n        (ok (+ (mul-down (- ONE_8 (get oracle-average pool)) oracle-instant) \n            (mul-down (get oracle-average pool) (if (is-eq (get oracle-resilient pool) u0) oracle-instant (get oracle-resilient pool)))))))\n(define-read-only (get-oracle-instant (token-x principal) (token-y principal) (factor uint))\n\t(let (\n\t\t\t(exists (is-some (get-pool-exists token-x token-y factor)))\n\t\t\t(pool (if exists (try! (get-pool-details token-x token-y factor)) (try! (get-pool-details token-y token-x factor))))\n\t\t)\n\t\t(asserts! (get oracle-enabled pool) ERR-ORACLE-NOT-ENABLED)\n\t\t(if exists\n\t\t\t(ok (get-price-internal (get balance-x pool) (get balance-y pool) factor))\n\t\t\t(ok (get-price-internal (get balance-y pool) (get balance-x pool) factor)))))\n(define-read-only (get-price (token-x principal) (token-y principal) (factor uint))\n\t(let (\n\t\t\t(pool (try! (get-pool-details token-x token-y factor)))\n\t\t)\n\t\t(ok (get-price-internal (get balance-x pool) (get balance-y pool) factor))))\n(define-read-only (get-threshold-x (token-x principal) (token-y principal) (factor uint))\n\t(ok (get threshold-x (try! (get-pool-details token-x token-y factor)))))\n(define-read-only (get-threshold-y (token-x principal) (token-y principal) (factor uint))\n\t(ok (get threshold-y (try! (get-pool-details token-x token-y factor)))))\n(define-read-only (get-fee-rebate (token-x principal) (token-y principal) (factor uint))\n\t(ok (get fee-rebate (try! (get-pool-details token-x token-y factor)))))\n(define-read-only (get-fee-rate-x (token-x principal) (token-y principal) (factor uint))\n\t(ok (get fee-rate-x (try! (get-pool-details token-x token-y factor)))))\n(define-read-only (get-fee-rate-y (token-x principal) (token-y principal) (factor uint))\n\t(ok (get fee-rate-y (try! (get-pool-details token-x token-y factor)))))\n(define-read-only (get-pool-owner (token-x principal) (token-y principal) (factor uint))\n\t(ok (get pool-owner (try! (get-pool-details token-x token-y factor)))))\n(define-read-only (get-y-given-x (token-x principal) (token-y principal) (factor uint) (dx uint))\n\t(let (\n\t\t\t(pool (try! (get-pool-details token-x token-y factor)))\n\t\t\t(threshold (get threshold-x pool))\n\t\t\t(dy (if (>= dx threshold)\n\t\t\t\t(get-y-given-x-internal (get balance-x pool) (get balance-y pool) factor dx)\n\t\t\t\t(div-down (mul-down dx (get-y-given-x-internal (get balance-x pool) (get balance-y pool) factor threshold)) threshold)))\n\t\t)\n\t\t(asserts! (< dx (mul-down (get balance-x pool) (get max-in-ratio pool))) ERR-MAX-IN-RATIO)\n\t\t(asserts! (< dy (mul-down (get balance-y pool) (get max-out-ratio pool))) ERR-MAX-OUT-RATIO)\n\t\t(ok dy)))\n(define-read-only (get-x-given-y (token-x principal) (token-y principal) (factor uint) (dy uint))\n\t(let (\n\t\t\t(pool (try! (get-pool-details token-x token-y factor)))\n\t\t\t(threshold (get threshold-y pool))\n\t\t\t(dx (if (>= dy threshold)\n\t\t\t\t\t(get-x-given-y-internal (get balance-x pool) (get balance-y pool) factor dy)\n\t\t\t\t\t(div-down (mul-down dy (get-x-given-y-internal (get balance-x pool) (get balance-y pool) factor threshold)) threshold)))\n\t\t)\n\t\t(asserts! (< dy (mul-down (get balance-y pool) (get max-in-ratio pool))) ERR-MAX-IN-RATIO)\n\t\t(asserts! (< dx (mul-down (get balance-x pool) (get max-out-ratio pool))) ERR-MAX-OUT-RATIO)\n\t\t(ok dx)))\n(define-read-only (get-y-in-given-x-out (token-x principal) (token-y principal) (factor uint) (dx uint))\n\t(let (\n\t\t\t(pool (try! (get-pool-details token-x token-y factor)))\n\t\t\t(threshold (get threshold-x pool))\n\t\t\t(dy (if (>= dx threshold)\n\t\t\t\t\t(get-y-in-given-x-out-internal (get balance-x pool) (get balance-y pool) factor dx)\n\t\t\t\t\t(div-down (mul-down dx (get-y-in-given-x-out-internal (get balance-x pool) (get balance-y pool) factor threshold)) threshold)))\n\t\t)\n\t\t(asserts! (< dy (mul-down (get balance-y pool) (get max-in-ratio pool))) ERR-MAX-IN-RATIO)\n\t\t(asserts! (< dx (mul-down (get balance-x pool) (get max-out-ratio pool))) ERR-MAX-OUT-RATIO)\n\t\t(ok dy)))\n(define-read-only (get-x-in-given-y-out (token-x principal) (token-y principal) (factor uint) (dy uint))\n\t(let (\n\t\t\t(pool (try! (get-pool-details token-x token-y factor)))\n\t\t\t(threshold (get threshold-y pool))\n\t\t\t(dx (if (>= dy threshold)\n\t\t\t\t\t(get-x-in-given-y-out-internal (get balance-x pool) (get balance-y pool) factor dy)\n\t\t\t\t\t(div-down (mul-down dy (get-x-in-given-y-out-internal (get balance-x pool) (get balance-y pool) factor threshold)) threshold)))\n\t\t)\n\t\t(asserts! (< dx (mul-down (get balance-x pool) (get max-in-ratio pool))) ERR-MAX-IN-RATIO)\n\t\t(asserts! (< dy (mul-down (get balance-y pool) (get max-out-ratio pool))) ERR-MAX-OUT-RATIO)\n\t\t(ok dx)))\n(define-read-only (get-x-given-price (token-x principal) (token-y principal) (factor uint) (price uint))\n\t(let (\n\t\t\t(pool (try! (get-pool-details token-x token-y factor)))\n\t\t)\n\t\t(asserts! (< price (get-price-internal (get balance-x pool) (get balance-y pool) factor)) ERR-NO-LIQUIDITY)\n\t\t(ok (get-x-given-price-internal (get balance-x pool) (get balance-y pool) factor price))))\n(define-read-only (get-y-given-price (token-x principal) (token-y principal) (factor uint) (price uint))\n\t(let (\n\t\t\t(pool (try! (get-pool-details token-x token-y factor)))\n\t\t)\n\t\t(asserts! (> price (get-price-internal (get balance-x pool) (get balance-y pool) factor)) ERR-NO-LIQUIDITY)\n\t\t(ok (get-y-given-price-internal (get balance-x pool) (get balance-y pool) factor price))))\n(define-read-only (get-token-given-position (token-x principal) (token-y principal) (factor uint) (dx uint) (max-dy (optional uint)))\n\t(let (\n\t\t\t(pool (try! (get-pool-details token-x token-y factor)))\n\t\t\t(dy (default-to u340282366920938463463374607431768211455 max-dy))\n\t\t)\n\t\t(asserts! (and (> dx u0) (> dy u0))  ERR-NO-LIQUIDITY)\n\t\t(ok (get-token-given-position-internal (get balance-x pool) (get balance-y pool) factor (get total-supply pool) dx dy))))\n(define-read-only (get-position-given-mint (token-x principal) (token-y principal) (factor uint) (token-amount uint))\n\t(let (\n\t\t\t(pool (try! (get-pool-details token-x token-y factor)))\n\t\t)\n\t\t(asserts! (> (get total-supply pool) u0) ERR-NO-LIQUIDITY)\n\t\t(ok (get-position-given-mint-internal (get balance-x pool) (get balance-y pool) factor (get total-supply pool) token-amount))))\n(define-read-only (get-position-given-burn (token-x principal) (token-y principal) (factor uint) (token-amount uint))\n\t(let (\n\t\t\t(pool (try! (get-pool-details token-x token-y factor)))\n\t\t)\n\t\t(asserts! (> (get total-supply pool) u0) ERR-NO-LIQUIDITY)\n\t\t(ok (get-position-given-burn-internal (get balance-x pool) (get balance-y pool) factor (get total-supply pool) token-amount))))\n(define-read-only (get-helper (token-x principal) (token-y principal) (factor uint) (dx uint))\n\t(if (is-some (get-pool-exists token-x token-y factor))\n\t\t(get-y-given-x token-x token-y factor dx)\n\t\t(get-x-given-y token-y token-x factor dx)))\n(define-read-only (get-helper-a (token-x principal) (token-y principal) (token-z principal) (factor-x uint) (factor-y uint) (dx uint))\n\t(get-helper token-y token-z factor-y (try! (get-helper token-x token-y factor-x dx))))\n(define-read-only (get-helper-b\n\t\t(token-x principal) (token-y principal) (token-z principal) (token-w principal)\n\t\t(factor-x uint) (factor-y uint) (factor-z uint)\n\t\t(dx uint))\n\t(get-helper token-z token-w factor-z (try! (get-helper-a token-x token-y token-z factor-x factor-y dx))))\n(define-read-only (get-helper-c\n\t\t(token-x principal) (token-y principal) (token-z principal) (token-w principal) (token-v principal)\n\t\t(factor-x uint) (factor-y uint) (factor-z uint) (factor-w uint)\n\t\t(dx uint))\n\t(get-helper-a token-z token-w token-v factor-z factor-w (try! (get-helper-a token-x token-y token-z factor-x factor-y dx))))\n(define-read-only (fee-helper (token-x principal) (token-y principal) (factor uint))\n\t(if (is-some (get-pool-exists token-x token-y factor))\n\t\t(get-fee-rate-x token-x token-y factor)\n\t\t(get-fee-rate-y token-y token-x factor)))\n(define-read-only (fee-helper-a (token-x principal) (token-y principal) (token-z principal) (factor-x uint) (factor-y uint))\n\t(ok (+ (try! (fee-helper token-x token-y factor-x)) (try! (fee-helper token-y token-z factor-y)))))\n(define-read-only (fee-helper-b\n\t\t(token-x principal) (token-y principal) (token-z principal) (token-w principal)\n\t\t(factor-x uint) (factor-y uint) (factor-z uint))\n\t(ok (+ (try! (fee-helper-a token-x token-y token-z factor-x factor-y)) (try! (fee-helper token-z token-w factor-z)))))\n(define-read-only (fee-helper-c\n\t\t(token-x principal) (token-y principal) (token-z principal) (token-w principal) (token-v principal)\n\t\t(factor-x uint) (factor-y uint) (factor-z uint) (factor-w uint))\n\t(ok (+ (try! (fee-helper-a token-x token-y token-z factor-x factor-y)) (try! (fee-helper-a token-z token-w token-v factor-z factor-w)))))\n(define-read-only (get-invariant (balance-x uint) (balance-y uint) (t uint))\n    (if (>= t (get-switch-threshold))\n        (+ (mul-down (- ONE_8 t) (+ balance-x balance-y)) (mul-down t (mul-down balance-x balance-y)))\n        (+ (pow-down balance-x (- ONE_8 t)) (pow-down balance-y (- ONE_8 t)))))\n(define-read-only (get-max-ratio-limit)\n    (contract-call? .amm-registry-v2-01 get-max-ratio-limit))\n(define-public (pause (new-paused bool))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ok (var-set paused new-paused))))\n(define-public (set-start-block (token-x principal) (token-y principal) (factor uint) (new-start-block uint))\n    (let (\n            (pool (try! (get-pool-details token-x token-y factor))))\n        (asserts! (or (is-eq tx-sender (get pool-owner pool)) (is-ok (is-dao-or-extension))) ERR-NOT-AUTHORIZED)\n        (as-contract (contract-call? .amm-registry-v2-01 set-start-block token-x token-y factor new-start-block))))\n(define-public (set-end-block (token-x principal) (token-y principal) (factor uint) (new-end-block uint))\n    (let (\n            (pool (try! (get-pool-details token-x token-y factor))))\n        (asserts! (or (is-eq tx-sender (get pool-owner pool)) (is-ok (is-dao-or-extension))) ERR-NOT-AUTHORIZED)\n        (as-contract (contract-call? .amm-registry-v2-01 set-end-block token-x token-y factor new-end-block))))\n(define-public (set-max-in-ratio (token-x principal) (token-y principal) (factor uint) (new-max-in-ratio uint))\n    (let (\n            (pool (try! (get-pool-details token-x token-y factor))))\n        (asserts! (or (is-eq tx-sender (get pool-owner pool)) (is-ok (is-dao-or-extension))) ERR-NOT-AUTHORIZED)\n        (as-contract (contract-call? .amm-registry-v2-01 set-max-in-ratio token-x token-y factor new-max-in-ratio))))\n(define-public (set-max-out-ratio (token-x principal) (token-y principal) (factor uint) (new-max-out-ratio uint))\n    (let (\n            (pool (try! (get-pool-details token-x token-y factor))))\n        (asserts! (or (is-eq tx-sender (get pool-owner pool)) (is-ok (is-dao-or-extension))) ERR-NOT-AUTHORIZED)\n        (as-contract (contract-call? .amm-registry-v2-01 set-max-out-ratio token-x token-y factor new-max-out-ratio))))\n(define-public (set-oracle-enabled (token-x principal) (token-y principal) (factor uint) (enabled bool))\n    (let (\n            (pool (try! (get-pool-details token-x token-y factor))))\n        (asserts! (or (is-eq tx-sender (get pool-owner pool)) (is-ok (is-dao-or-extension))) ERR-NOT-AUTHORIZED)\n        (as-contract (contract-call? .amm-registry-v2-01 set-oracle-enabled token-x token-y factor enabled))))\n(define-public (set-oracle-average (token-x principal) (token-y principal) (factor uint) (new-oracle-average uint))\n    (let (\n            (pool (try! (get-pool-details token-x token-y factor))))\n        (asserts! (or (is-eq tx-sender (get pool-owner pool)) (is-ok (is-dao-or-extension))) ERR-NOT-AUTHORIZED)\n        (as-contract (contract-call? .amm-registry-v2-01 set-oracle-average token-x token-y factor new-oracle-average))))\n(define-public (set-threshold-x (token-x principal) (token-y principal) (factor uint) (new-threshold uint))\n    (let (\n            (pool (try! (get-pool-details token-x token-y factor))))\n        (asserts! (or (is-eq tx-sender (get pool-owner pool)) (is-ok (is-dao-or-extension))) ERR-NOT-AUTHORIZED)\n        (as-contract (contract-call? .amm-registry-v2-01 set-threshold-x token-x token-y factor new-threshold))))\n(define-public (set-threshold-y (token-x principal) (token-y principal) (factor uint) (new-threshold uint))\n    (let (\n            (pool (try! (get-pool-details token-x token-y factor))))\n        (asserts! (or (is-eq tx-sender (get pool-owner pool)) (is-ok (is-dao-or-extension))) ERR-NOT-AUTHORIZED)\n        (as-contract (contract-call? .amm-registry-v2-01 set-threshold-y token-x token-y factor new-threshold))))\n(define-public (set-fee-rate-x (token-x principal) (token-y principal) (factor uint) (fee-rate-x uint))\n    (let (        \n            (pool (try! (get-pool-details token-x token-y factor))))\n        (asserts! (or (is-eq tx-sender (get pool-owner pool)) (is-ok (is-dao-or-extension))) ERR-NOT-AUTHORIZED)\n        (as-contract (contract-call? .amm-registry-v2-01 set-fee-rate-x token-x token-y factor fee-rate-x))))\n(define-public (set-fee-rate-y (token-x principal) (token-y principal) (factor uint) (fee-rate-y uint))\n    (let (    \n            (pool (try! (get-pool-details token-x token-y factor))))\n        (asserts! (or (is-eq tx-sender (get pool-owner pool)) (is-ok (is-dao-or-extension))) ERR-NOT-AUTHORIZED)\n        (as-contract (contract-call? .amm-registry-v2-01 set-fee-rate-y token-x token-y factor fee-rate-y))))\n(define-public (create-pool (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (factor uint) (pool-owner principal) (dx uint) (dy uint)) \n    (begin\n\t\t\t\t(asserts! (not (is-blocklisted-or-default tx-sender)) ERR-BLOCKLISTED)\n        (as-contract (try! (contract-call? .amm-registry-v2-01 create-pool token-x-trait token-y-trait factor pool-owner)))\n        (add-to-position token-x-trait token-y-trait factor dx (some dy))))\n(define-public (add-to-position (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (factor uint) (dx uint) (max-dy (optional uint)))\n    (let (\n            (token-x (contract-of token-x-trait))\n            (token-y (contract-of token-y-trait))\n            (pool (try! (get-pool-details token-x token-y factor)))\n            (balance-x (get balance-x pool))\n            (balance-y (get balance-y pool))\n            (total-supply (get total-supply pool))\n            (add-data (try! (get-token-given-position token-x token-y factor dx max-dy)))\n            (new-supply (get token add-data))\n            (dy (get dy add-data))\n            (pool-updated (merge pool { total-supply: (+ new-supply total-supply), balance-x: (+ balance-x dx), balance-y: (+ balance-y dy) }))\n            (sender tx-sender))\n        (asserts! (not (is-paused)) ERR-PAUSED)\n        (asserts! (and (> dx u0) (> dy u0)) ERR-INVALID-LIQUIDITY)\n        (asserts! (>= (default-to u340282366920938463463374607431768211455 max-dy) dy) ERR-EXCEEDS-MAX-SLIPPAGE)\n        (try! (contract-call? token-x-trait transfer-fixed dx sender .amm-vault-v2-01 none))\n        (try! (contract-call? token-y-trait transfer-fixed dy sender .amm-vault-v2-01 none))\n        (as-contract (try! (contract-call? .amm-registry-v2-01 update-pool token-x token-y factor pool-updated)))\n        (as-contract (try! (contract-call? .token-amm-pool-v2-01 mint-fixed (get pool-id pool) new-supply sender)))\n        (print { object: \"pool\", action: \"liquidity-added\", data: pool-updated, dx: dx, dy: dy, token-x: token-x, token-y: token-y, sender: sender })\n        (ok {supply: new-supply, dx: dx, dy: dy})))\n(define-public (reduce-position (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (factor uint) (percent uint))\n    (let (\n            (token-x (contract-of token-x-trait))\n            (token-y (contract-of token-y-trait))\n            (pool (try! (get-pool-details token-x token-y factor)))\n            (balance-x (get balance-x pool))\n            (balance-y (get balance-y pool))\n            (total-shares (unwrap-panic (contract-call? .token-amm-pool-v2-01 get-balance-fixed (get pool-id pool) tx-sender)))\n            (shares (if (is-eq percent ONE_8) total-shares (mul-down total-shares percent)))\n            (total-supply (get total-supply pool))\n            (reduce-data (try! (get-position-given-burn token-x token-y factor shares)))\n            (dx (get dx reduce-data))\n            (dy (get dy reduce-data))\n            (pool-updated (merge pool { total-supply: (if (<= total-supply shares) u0 (- total-supply shares)), balance-x: (if (<= balance-x dx) u0 (- balance-x dx)), balance-y: (if (<= balance-y dy) u0 (- balance-y dy)) }))\n            (sender tx-sender))  \n\t\t\t\t(asserts! (not (is-blocklisted-or-default tx-sender)) ERR-BLOCKLISTED)\t\t\n        (asserts! (not (is-paused)) ERR-PAUSED)       \n        (asserts! (<= percent ONE_8) ERR-PERCENT-GREATER-THAN-ONE)\n        (as-contract (try! (contract-call? .amm-vault-v2-01 transfer-ft-two token-x-trait dx token-y-trait dy sender)))\n        (as-contract (try! (contract-call? .amm-registry-v2-01 update-pool token-x token-y factor pool-updated)))\n        (as-contract (try! (contract-call? .token-amm-pool-v2-01 burn-fixed (get pool-id pool) shares sender)))\n        (print { object: \"pool\", action: \"liquidity-removed\", data: pool-updated, dx: dx, dy: dy, token-x: token-x, token-y: token-y, sender: sender })\n        (ok {dx: dx, dy: dy})))\n(define-public (swap-x-for-y (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (factor uint) (dx uint) (min-dy (optional uint)))\n    (let (\n            (token-x (contract-of token-x-trait))\n            (token-y (contract-of token-y-trait))\n            (pool (try! (get-pool-details token-x token-y factor)))\n            (balance-x (get balance-x pool))\n            (balance-y (get balance-y pool))\n            (fee (mul-up dx (get fee-rate-x pool)))\n            (dx-net-fees (if (<= dx fee) u0 (- dx fee)))\n            (fee-rebate (mul-down fee (get fee-rebate pool)))\n            (dy (try! (get-y-given-x token-x token-y factor dx-net-fees)))                \n            (pool-updated (merge pool {\n                balance-x: (+ balance-x dx-net-fees fee-rebate),\n                balance-y: (if (<= balance-y dy) u0 (- balance-y dy)),\n                oracle-resilient: (if (get oracle-enabled pool) (try! (get-oracle-resilient token-x token-y factor)) u0)\n                }))\n            (sender tx-sender))\n\t\t\t\t(asserts! (not (is-blocklisted-or-default tx-sender)) ERR-BLOCKLISTED)\n        (asserts! (not (is-paused)) ERR-PAUSED)\n        (try! (check-pool-status token-x token-y factor))\n        (asserts! (> dx u0) ERR-INVALID-LIQUIDITY)\n        (asserts! (<= (div-down dy dx-net-fees) (get-price-internal balance-x balance-y factor)) ERR-INVALID-LIQUIDITY)\n        (asserts! (<= (default-to u0 min-dy) dy) ERR-EXCEEDS-MAX-SLIPPAGE)\n        (try! (contract-call? token-x-trait transfer-fixed dx sender .amm-vault-v2-01 none))\n        (and (> dy u0) (as-contract (try! (contract-call? .amm-vault-v2-01 transfer-ft token-y-trait dy sender))))\n        (as-contract (try! (contract-call? .amm-vault-v2-01 add-to-reserve token-x (- fee fee-rebate))))\n        (as-contract (try! (contract-call? .amm-registry-v2-01 update-pool token-x token-y factor pool-updated)))\n        (print { object: \"pool\", action: \"swap-x-for-y\", data: pool-updated, dx: dx, dy: dy, token-x: token-x, token-y: token-y, sender: sender, fee: fee, fee-rebate: fee-rebate })\n        (ok {dx: dx-net-fees, dy: dy})))\n(define-public (swap-y-for-x (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (factor uint) (dy uint) (min-dx (optional uint)))\n    (let (\n            (token-x (contract-of token-x-trait))\n            (token-y (contract-of token-y-trait))\n            (pool (try! (get-pool-details token-x token-y factor)))\n            (balance-x (get balance-x pool))\n            (balance-y (get balance-y pool))\n            (fee (mul-up dy (get fee-rate-y pool)))\n            (dy-net-fees (if (<= dy fee) u0 (- dy fee)))\n            (fee-rebate (mul-down fee (get fee-rebate pool)))\n            (dx (try! (get-x-given-y token-x token-y factor dy-net-fees)))\n            (pool-updated (merge pool {\n                balance-x: (if (<= balance-x dx) u0 (- balance-x dx)),\n                balance-y: (+ balance-y dy-net-fees fee-rebate),\n                oracle-resilient: (if (get oracle-enabled pool) (try! (get-oracle-resilient token-x token-y factor)) u0)\n                }))\n            (sender tx-sender))\n\t\t\t\t(asserts! (not (is-blocklisted-or-default tx-sender)) ERR-BLOCKLISTED)\n        (asserts! (not (is-paused)) ERR-PAUSED)\n        (try! (check-pool-status token-x token-y factor))\n        (asserts! (> dy u0) ERR-INVALID-LIQUIDITY)        \n        (asserts! (>= (div-down dy-net-fees dx) (get-price-internal balance-x balance-y factor)) ERR-INVALID-LIQUIDITY)\n        (asserts! (<= (default-to u0 min-dx) dx) ERR-EXCEEDS-MAX-SLIPPAGE)        \n        (try! (contract-call? token-y-trait transfer-fixed dy sender .amm-vault-v2-01 none))\n        (and (> dx u0) (as-contract (try! (contract-call? .amm-vault-v2-01 transfer-ft token-x-trait dx sender))))            \n        (as-contract (try! (contract-call? .amm-vault-v2-01 add-to-reserve token-y (- fee fee-rebate))))\n        (as-contract (try! (contract-call? .amm-registry-v2-01 update-pool token-x token-y factor pool-updated)))\n        (print { object: \"pool\", action: \"swap-y-for-x\", data: pool-updated, dx: dx, dy: dy, token-x: token-x, token-y: token-y, sender: sender, fee: fee, fee-rebate: fee-rebate })\n        (ok {dx: dx, dy: dy-net-fees})))\n(define-public (swap-helper (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (factor uint) (dx uint) (min-dy (optional uint)))\n\t(if (is-some (get-pool-exists (contract-of token-x-trait) (contract-of token-y-trait) factor))\n\t\t(ok (get dy (try! (swap-x-for-y token-x-trait token-y-trait factor dx min-dy))))\n\t\t(ok (get dx (try! (swap-y-for-x token-y-trait token-x-trait factor dx min-dy))))))\n(define-public (swap-helper-a (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (token-z-trait <ft-trait>) (factor-x uint) (factor-y uint) (dx uint) (min-dz (optional uint)))\n\t(swap-helper token-y-trait token-z-trait factor-y (try! (swap-helper token-x-trait token-y-trait factor-x dx none)) min-dz))\n(define-public (swap-helper-b\n\t\t(token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (token-z-trait <ft-trait>) (token-w-trait <ft-trait>)\n\t\t(factor-x uint) (factor-y uint) (factor-z uint)\n\t\t(dx uint) (min-dw (optional uint)))\n\t(swap-helper token-z-trait token-w-trait factor-z (try! (swap-helper-a token-x-trait token-y-trait token-z-trait factor-x factor-y dx none)) min-dw))\n(define-public (swap-helper-c\n\t\t(token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (token-z-trait <ft-trait>) (token-w-trait <ft-trait>) (token-v-trait <ft-trait>)\n\t\t(factor-x uint) (factor-y uint) (factor-z uint) (factor-w uint)\n\t\t(dx uint) (min-dv (optional uint)))\n\t(swap-helper-a token-z-trait token-w-trait token-v-trait factor-z factor-w (try! (swap-helper-a token-x-trait token-y-trait token-z-trait factor-x factor-y dx none)) min-dv))\n(define-private (get-price-internal (balance-x uint) (balance-y uint) (factor uint))\n    (if (>= factor (get-switch-threshold))\n        (div-down (+ (- ONE_8 factor) (mul-down factor balance-y)) (+ (- ONE_8 factor) (mul-down factor balance-x)))\n        (pow-down (div-down balance-y balance-x) factor)))\n(define-private (get-y-given-x-internal (balance-x uint) (balance-y uint) (t uint) (dx uint))\n    (if (>= t (get-switch-threshold))\n        (let (\n                (t-comp (if (<= ONE_8 t) u0 (- ONE_8 t))))        \n            (div-down (+ (mul-down t-comp dx) (mul-down t (mul-down dx balance-y))) (+ t-comp (mul-down t (+ balance-x dx)))))\n        (let (\n                (t-comp (if (<= ONE_8 t) u0 (- ONE_8 t)))\n                (t-comp-num-uncapped (div-up ONE_8 t-comp))\n                (t-comp-num (if (< t-comp-num-uncapped MILD_EXPONENT_BOUND) t-comp-num-uncapped MILD_EXPONENT_BOUND))            \n                (x-pow (pow-up balance-x t-comp))\n                (y-pow (pow-up balance-y t-comp))\n                (x-dx-pow (pow-down (+ balance-x dx) t-comp))\n                (add-term (+ x-pow y-pow))\n                (term (if (<= add-term x-dx-pow) u0 (- add-term x-dx-pow)))\n                (final-term (pow-up term t-comp-num)))        \n            (if (<= balance-y final-term) u0 (- balance-y final-term)))))\n(define-private (get-x-given-y-internal (balance-x uint) (balance-y uint) (t uint) (dy uint))\n    (if (>= t (get-switch-threshold))\n        (let (\n                (t-comp (if (<= ONE_8 t) u0 (- ONE_8 t))))        \n            (div-down (+ (mul-down t-comp dy) (mul-down t (mul-down dy balance-x))) (+ t-comp (mul-down t (+ balance-y dy)))))  \n        (let (          \n                (t-comp (if (<= ONE_8 t) u0 (- ONE_8 t)))\n                (t-comp-num-uncapped (div-up ONE_8 t-comp))\n                (t-comp-num (if (< t-comp-num-uncapped MILD_EXPONENT_BOUND) t-comp-num-uncapped MILD_EXPONENT_BOUND))            \n                (x-pow (pow-up balance-x t-comp))\n                (y-pow (pow-up balance-y t-comp))\n                (y-dy-pow (pow-down (+ balance-y dy) t-comp))\n                (add-term (+ x-pow y-pow))\n                (term (if (<= add-term y-dy-pow) u0 (- add-term y-dy-pow)))\n                (final-term (pow-up term t-comp-num)))\n            (if (<= balance-x final-term) u0 (- balance-x final-term)))))\n(define-private (get-y-in-given-x-out-internal (balance-x uint) (balance-y uint) (t uint) (dx uint))    \n    (if (>= t (get-switch-threshold))\n        (let (\n                (t-comp (if (<= ONE_8 t) u0 (- ONE_8 t))))\n            (div-down (+ (mul-down t-comp dx) (mul-down t (mul-down dx balance-y))) (+ t-comp (mul-down t (- balance-x dx)))))\n        (let (\n                (t-comp (if (<= ONE_8 t) u0 (- ONE_8 t)))\n                (t-comp-num-uncapped (div-down ONE_8 t-comp))\n                (t-comp-num (if (< t-comp-num-uncapped MILD_EXPONENT_BOUND) t-comp-num-uncapped MILD_EXPONENT_BOUND))            \n                (x-pow (pow-down balance-x t-comp))\n                (y-pow (pow-down balance-y t-comp))\n                (x-dx-pow (pow-up (if (<= balance-x dx) u0 (- balance-x dx)) t-comp))\n                (add-term (+ x-pow y-pow))\n                (term (if (<= add-term x-dx-pow) u0 (- add-term x-dx-pow)))\n                (final-term (pow-down term t-comp-num)))\n            (if (<= final-term balance-y) u0 (- final-term balance-y)))))\n(define-private (get-x-in-given-y-out-internal (balance-x uint) (balance-y uint) (t uint) (dy uint))\n    (if (>= t (get-switch-threshold))\n        (let (          \n                (t-comp (if (<= ONE_8 t) u0 (- ONE_8 t))))\n            (div-down (+ (mul-down t-comp dy) (mul-down t (mul-down dy balance-x))) (+ t-comp (mul-down t (- balance-y dy)))))\n        (let (          \n                (t-comp (if (<= ONE_8 t) u0 (- ONE_8 t)))\n                (t-comp-num-uncapped (div-down ONE_8 t-comp))\n                (t-comp-num (if (< t-comp-num-uncapped MILD_EXPONENT_BOUND) t-comp-num-uncapped MILD_EXPONENT_BOUND))            \n                (x-pow (pow-down balance-x t-comp))\n                (y-pow (pow-down balance-y t-comp))\n                (y-dy-pow (pow-up (if (<= balance-y dy) u0 (- balance-y dy)) t-comp))\n                (add-term (+ x-pow y-pow))\n                (term (if (<= add-term y-dy-pow) u0 (- add-term y-dy-pow)))\n                (final-term (pow-down term t-comp-num)))\n            (if (<= final-term balance-x) u0 (- final-term balance-x)))))\n(define-private (get-x-given-price-internal (balance-x uint) (balance-y uint) (t uint) (price uint))\n    (if (>= t (get-switch-threshold))\n        (let (\n                (power (pow-down (div-down (get-price-internal balance-x balance-y t) price) u50000000)))\n            (mul-down balance-x (if (<= power ONE_8) u0 (- power ONE_8)))) \n        (let (\n                (t-comp (if (<= ONE_8 t) u0 (- ONE_8 t)))\n                (t-comp-num-uncapped (div-down ONE_8 t-comp))\n                (t-comp-num (if (< t-comp-num-uncapped MILD_EXPONENT_BOUND) t-comp-num-uncapped MILD_EXPONENT_BOUND))            \n                (numer (+ ONE_8 (pow-down (get-price-internal balance-x balance-y t) (div-down t-comp t))))\n                (denom (+ ONE_8 (pow-down price (div-down t-comp t))))\n                (lead-term (pow-down (div-down numer denom) t-comp-num)))\n            (if (<= lead-term ONE_8) u0 (mul-up balance-x (- lead-term ONE_8))))))\n(define-private (get-y-given-price-internal (balance-x uint) (balance-y uint) (t uint) (price uint))\n    (if (>= t (get-switch-threshold))\n        (let (            \n                (power (pow-down (div-down price (get-price-internal balance-x balance-y t)) u50000000)))\n            (mul-down balance-y (if (<= power ONE_8) u0 (- power ONE_8))))\n        (let (\n                (t-comp (if (<= ONE_8 t) u0 (- ONE_8 t)))\n                (t-comp-num-uncapped (div-down ONE_8 t-comp))\n                (t-comp-num (if (< t-comp-num-uncapped MILD_EXPONENT_BOUND) t-comp-num-uncapped MILD_EXPONENT_BOUND))            \n                (numer (+ ONE_8 (pow-down (get-price-internal balance-x balance-y t) (div-down t-comp t))))\n                (denom (+ ONE_8 (pow-down price (div-down t-comp t))))\n                (lead-term (pow-down (div-down numer denom) t-comp-num)))\n            (if (<= ONE_8 lead-term) u0 (mul-up balance-y (- ONE_8 lead-term))))))\n(define-private (get-token-given-position-internal (balance-x uint) (balance-y uint) (t uint) (total-supply uint) (dx uint) (dy uint))\n\t(if (is-eq total-supply u0)\n\t\t{token: (get-invariant dx dy t), dy: dy}\n\t\t{token: (div-down (mul-down total-supply dx) balance-x), dy: (div-down (mul-down balance-y dx) balance-x)}))\n(define-private (get-position-given-mint-internal (balance-x uint) (balance-y uint) (t uint) (total-supply uint) (token-amount uint))\n\t(let (\n\t\t\t(token-div-supply (div-down token-amount total-supply))\n\t\t)\n\t\t{dx: (mul-down balance-x token-div-supply), dy: (mul-down balance-y token-div-supply)}))\n(define-private (get-position-given-burn-internal (balance-x uint) (balance-y uint) (t uint) (total-supply uint) (token-amount uint))\n\t(get-position-given-mint-internal balance-x balance-y t total-supply token-amount))\n(define-constant ONE_8 u100000000) ;; 8 decimal places\n(define-constant MAX_POW_RELATIVE_ERROR u4)\n(define-private (mul-down (a uint) (b uint))\n\t(/ (* a b) ONE_8))\n(define-private (mul-up (a uint) (b uint))\n\t(let (\n\t\t\t(product (* a b))\n\t\t)\n\t\t(if (is-eq product u0) u0 (+ u1 (/ (- product u1) ONE_8)))))\n(define-private (div-down (a uint) (b uint))\n\t(if (is-eq a u0) u0 (/ (* a ONE_8) b)))\n(define-private (div-up (a uint) (b uint))\n\t(if (is-eq a u0) u0 (+ u1 (/ (- (* a ONE_8) u1) b))))\n(define-private (pow-down (a uint) (b uint))\n\t(let (\n\t\t\t(raw (unwrap-panic (pow-fixed a b)))\n\t\t\t(max-error (+ u1 (mul-up raw MAX_POW_RELATIVE_ERROR)))\n\t\t)\n\t\t(if (< raw max-error) u0 (- raw max-error))))\n(define-private (pow-up (a uint) (b uint))\n\t(let (\n\t\t\t(raw (unwrap-panic (pow-fixed a b)))\n\t\t\t(max-error (+ u1 (mul-up raw MAX_POW_RELATIVE_ERROR)))\n\t\t)\n\t\t(+ raw max-error)))\n(define-constant UNSIGNED_ONE_8 (pow 10 8))\n(define-constant MAX_NATURAL_EXPONENT (* 69 UNSIGNED_ONE_8))\n(define-constant MIN_NATURAL_EXPONENT (* -18 UNSIGNED_ONE_8))\n(define-constant MILD_EXPONENT_BOUND (/ (pow u2 u126) (to-uint UNSIGNED_ONE_8)))\n(define-constant x_a_list_no_deci (list {x_pre: 6400000000, a_pre: 62351490808116168829, use_deci: false} ))\n(define-constant x_a_list (list\n\t{x_pre: 3200000000, a_pre: 78962960182680695161, use_deci: true} ;; x2 = 2^5, a2 = e^(x2)\n\t{x_pre: 1600000000, a_pre: 888611052050787, use_deci: true} ;; x3 = 2^4, a3 = e^(x3)\n\t{x_pre: 800000000, a_pre: 298095798704, use_deci: true} ;; x4 = 2^3, a4 = e^(x4)\n\t{x_pre: 400000000, a_pre: 5459815003, use_deci: true} ;; x5 = 2^2, a5 = e^(x5)\n\t{x_pre: 200000000, a_pre: 738905610, use_deci: true} ;; x6 = 2^1, a6 = e^(x6)\n\t{x_pre: 100000000, a_pre: 271828183, use_deci: true} ;; x7 = 2^0, a7 = e^(x7)\n\t{x_pre: 50000000, a_pre: 164872127, use_deci: true} ;; x8 = 2^-1, a8 = e^(x8)\n\t{x_pre: 25000000, a_pre: 128402542, use_deci: true} ;; x9 = 2^-2, a9 = e^(x9)\n\t{x_pre: 12500000, a_pre: 113314845, use_deci: true} ;; x10 = 2^-3, a10 = e^(x10)\n\t{x_pre: 6250000, a_pre: 106449446, use_deci: true} ;; x11 = 2^-4, a11 = e^x(11)\n))\n(define-constant ERR-X-OUT-OF-BOUNDS (err u5009))\n(define-constant ERR-Y-OUT-OF-BOUNDS (err u5010))\n(define-constant ERR-PRODUCT-OUT-OF-BOUNDS (err u5011))\n(define-constant ERR-INVALID-EXPONENT (err u5012))\n(define-constant ERR-OUT-OF-BOUNDS (err u5013))\n(define-private (ln-priv (a int))\n\t(let (\n\t\t\t(a_sum_no_deci (fold accumulate_division x_a_list_no_deci {a: a, sum: 0}))\n\t\t\t(a_sum (fold accumulate_division x_a_list {a: (get a a_sum_no_deci), sum: (get sum a_sum_no_deci)}))\n\t\t\t(out_a (get a a_sum))\n\t\t\t(out_sum (get sum a_sum))\n\t\t\t(z (/ (* (- out_a UNSIGNED_ONE_8) UNSIGNED_ONE_8) (+ out_a UNSIGNED_ONE_8)))\n\t\t\t(z_squared (/ (* z z) UNSIGNED_ONE_8))\n\t\t\t(div_list (list 3 5 7 9 11))\n\t\t\t(num_sum_zsq (fold rolling_sum_div div_list {num: z, seriesSum: z, z_squared: z_squared}))\n\t\t\t(seriesSum (get seriesSum num_sum_zsq))\n\t\t)\n\t\t(+ out_sum (* seriesSum 2))))\n(define-private (accumulate_division (x_a_pre (tuple (x_pre int) (a_pre int) (use_deci bool))) (rolling_a_sum (tuple (a int) (sum int))))\n\t(let (\n\t\t\t(a_pre (get a_pre x_a_pre))\n\t\t\t(x_pre (get x_pre x_a_pre))\n\t\t\t(use_deci (get use_deci x_a_pre))\n\t\t\t(rolling_a (get a rolling_a_sum))\n\t\t\t(rolling_sum (get sum rolling_a_sum))\n\t\t)\n\t\t(if (>= rolling_a (if use_deci a_pre (* a_pre UNSIGNED_ONE_8)))\n\t\t\t\t{a: (/ (* rolling_a (if use_deci UNSIGNED_ONE_8 1)) a_pre), sum: (+ rolling_sum x_pre)}\n\t\t\t\t{a: rolling_a, sum: rolling_sum})))\n(define-private (rolling_sum_div (n int) (rolling (tuple (num int) (seriesSum int) (z_squared int))))\n\t(let (\n\t\t\t(rolling_num (get num rolling))\n\t\t\t(rolling_sum (get seriesSum rolling))\n\t\t\t(z_squared (get z_squared rolling))\n\t\t\t(next_num (/ (* rolling_num z_squared) UNSIGNED_ONE_8))\n\t\t\t(next_sum (+ rolling_sum (/ next_num n)))\n\t\t)\n\t\t{num: next_num, seriesSum: next_sum, z_squared: z_squared}))\n(define-private (pow-priv (x uint) (y uint))\n    (let (\n            (x-int (to-int x))\n            (y-int (to-int y))\n            (lnx (ln-priv x-int))\n            (logx-times-y (/ (* lnx y-int) UNSIGNED_ONE_8)))\n        (asserts! (and (<= MIN_NATURAL_EXPONENT logx-times-y) (<= logx-times-y MAX_NATURAL_EXPONENT)) ERR-PRODUCT-OUT-OF-BOUNDS)\n        (ok (to-uint (try! (exp-fixed logx-times-y))))))\n(define-private (exp-pos (x int))\n\t(begin\n\t\t(asserts! (and (<= 0 x) (<= x MAX_NATURAL_EXPONENT)) ERR-INVALID-EXPONENT)\n\t\t(let (\n\t\t\t\t(x_product_no_deci (fold accumulate_product x_a_list_no_deci {x: x, product: 1}))\n\t\t\t\t(x_adj (get x x_product_no_deci))\n\t\t\t\t(firstAN (get product x_product_no_deci))\n\t\t\t\t(x_product (fold accumulate_product x_a_list {x: x_adj, product: UNSIGNED_ONE_8}))\n\t\t\t\t(product_out (get product x_product))\n\t\t\t\t(x_out (get x x_product))\n\t\t\t\t(seriesSum (+ UNSIGNED_ONE_8 x_out))\n\t\t\t\t(div_list (list 2 3 4 5 6 7 8 9 10 11 12))\n\t\t\t\t(term_sum_x (fold rolling_div_sum div_list {term: x_out, seriesSum: seriesSum, x: x_out}))\n\t\t\t\t(sum (get seriesSum term_sum_x)))\n\t\t\t(ok (* (/ (* product_out sum) UNSIGNED_ONE_8) firstAN)))))\n(define-private (accumulate_product (x_a_pre (tuple (x_pre int) (a_pre int) (use_deci bool))) (rolling_x_p (tuple (x int) (product int))))\n\t(let (\n\t\t\t(x_pre (get x_pre x_a_pre))\n\t\t\t(a_pre (get a_pre x_a_pre))\n\t\t\t(use_deci (get use_deci x_a_pre))\n\t\t\t(rolling_x (get x rolling_x_p))\n\t\t\t(rolling_product (get product rolling_x_p)))\n\t\t(if (>= rolling_x x_pre)\n\t\t\t{x: (- rolling_x x_pre), product: (/ (* rolling_product a_pre) (if use_deci UNSIGNED_ONE_8 1))}\n\t\t\t{x: rolling_x, product: rolling_product})))\n(define-private (rolling_div_sum (n int) (rolling (tuple (term int) (seriesSum int) (x int))))\n\t(let (\n\t\t\t(rolling_term (get term rolling))\n\t\t\t(rolling_sum (get seriesSum rolling))\n\t\t\t(x (get x rolling))\n\t\t\t(next_term (/ (/ (* rolling_term x) UNSIGNED_ONE_8) n))\n\t\t\t(next_sum (+ rolling_sum next_term))\n\t\t)\n\t\t{term: next_term, seriesSum: next_sum, x: x}))\n(define-private (pow-fixed (x uint) (y uint))\n\t(begin\n\t\t(asserts! (< x (pow u2 u127)) ERR-X-OUT-OF-BOUNDS)\n\t\t(asserts! (< y MILD_EXPONENT_BOUND) ERR-Y-OUT-OF-BOUNDS)\n\t\t(if (is-eq y u0)\n\t\t\t(ok (to-uint UNSIGNED_ONE_8))\n\t\t\t(if (is-eq x u0) (ok u0) (pow-priv x y)))))\n(define-private (exp-fixed (x int))\n\t(begin\n\t\t(asserts! (and (<= MIN_NATURAL_EXPONENT x) (<= x MAX_NATURAL_EXPONENT)) ERR-INVALID-EXPONENT)\n\t\t(if (< x 0) (ok (/ (* UNSIGNED_ONE_8 UNSIGNED_ONE_8) (try! (exp-pos (* -1 x))))) (exp-pos x))))\n(define-private (log-fixed (arg int) (base int))\n\t(let (\n\t\t\t(logBase (* (ln-priv base) UNSIGNED_ONE_8))\n\t\t\t(logArg (* (ln-priv arg) UNSIGNED_ONE_8)))\n\t\t(ok (/ (* logArg UNSIGNED_ONE_8) logBase))))\n(define-private (ln-fixed (a int))\n\t(begin\n\t\t(asserts! (> a 0) ERR-OUT-OF-BOUNDS)\n\t\t(if (< a UNSIGNED_ONE_8) (ok (- 0 (ln-priv (/ (* UNSIGNED_ONE_8 UNSIGNED_ONE_8) a)))) (ok (ln-priv a)))))",
    "analysis": {
      "summary": "This contract facilitates the creation and interaction with automated market maker (AMM) pools on the Stacks blockchain, allowing for token swaps, liquidity provision, and pool management.",
      "explanation": "The contract is designed to integrate with a decentralized exchange (DEX) ecosystem, providing functionalities such as swapping tokens, adding or removing liquidity, and adjusting pool parameters by authorized users. It interacts with external contracts for token management and pool registry, adhering to the SIP-010 fungible token standard for Stacks tokens.\n\n1. **Constants and Data Variables**:\n- Error codes <L2-27> define various failure states, ensuring that the contract can communicate specific issues to callers.\n- A data variable 'paused' <L16> indicates whether the contract's functions are currently paused, a common feature for emergency stop mechanisms.\n\n2. **Read-Only Functions**:\n- Functions like 'get-pool-details' <L23-26> and 'get-balances' <L31-35> query the state of pools, including balances and configuration, without altering the state.\n- Price calculation and swap estimations <L61-74, L87-130> provide essential data for users to make informed decisions when interacting with pools.\n- Oracle-related functions <L49-60> fetch data about external price feeds, ensuring that the contract can integrate with price oracles for additional security measures in token swapping.\n\n3. **Public Functions**:\n- 'pause' <L198-201>, 'set-start-block' <L202-206>, and similar functions <L207-241> allow authorized users to adjust critical parameters of the pools, ensuring adaptability to changing conditions or to respond to security incidents.\n- 'create-pool' <L252-256> and 'add-to-position' <L257-278> enable liquidity provision, a core feature of AMMs, allowing users to contribute to the liquidity of token pairs and earn fees from trades.\n- Swap functions <L302-359> facilitate the core functionality of exchanging tokens, with safeguards like slippage protection and fee calculation to ensure fair and secure operations.\n\n4. **Private Functions**:\n- Internal logic for price and ratio calculations <L376-443> supports the public API, ensuring that swaps and liquidity adjustments are based on accurate and fair market conditions.\n- Mathematical utilities <L483-622> provide foundational operations like multiplication, division, and exponentiation with fixed-point arithmetic, crucial for financial calculations in a blockchain context.\n\n**Notable Qualities**:\n- The contract's design emphasizes security and flexibility, with extensive error handling and parameter checks.\n- Integration with external oracles and registries suggests a modular architecture, allowing for scalability and interoperability within the Stacks ecosystem.\n- The use of fixed-point arithmetic for financial calculations demonstrates attention to precision and the challenges of blockchain-based finance.",
      "tags": ["DeFi", "DEX", "liquidity", "oracle"]
    }
  },
  {
    "rank": 2,
    "contract": "SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.path-apply_staging",
    "calls": 23235,
    "source": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(use-trait ft-trait 'SP2AKWJYC7BNY18W1XXKPGP0YVEK63QJG4793Z2D4.sip-010-trait-ft-standard.sip-010-trait)\n\n(use-trait share-fee-to-trait 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to-trait.share-fee-to-trait)\n\n(use-trait univ2v2-pool-trait 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-pool-trait_v1_0_0.univ2-pool-trait)\n(use-trait univ2v2-fees-trait 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-fees-trait_v1_0_0.univ2-fees-trait)\n\n(use-trait curve-pool-trait   'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.curve-pool-trait_v1_0_0.curve-pool-trait)\n(use-trait curve-fees-trait   'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.curve-fees-trait_v1_0_0.curve-fees-trait)\n\n(use-trait ststx-pool-trait   'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.curve-pool-trait_ststx.curve-pool-trait)\n(use-trait ststx-proxy-trait  'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.curve-proxy-trait_ststx.curve-proxy-trait)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; max 2047 edge tuples\n(define-constant MAX-EDGES    u500) ;;effectively max nr of pools (stx -> *)\n(define-constant MAX-PATH-LEN u4)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; pool types\n(define-constant UNIV2   \"u\")\n(define-constant UNIV2V2 \"v\")\n(define-constant CURVE   \"c\")\n(define-constant USDH    \"h\")\n(define-constant STSTX   \"s\")\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; edges\n(define-read-only\n  (is-univ2 (edge {a:(string-ascii 1),b:principal,c:uint,d:principal,e:principal,f:bool}))\n  (is-eq (get a edge) UNIV2))\n(define-read-only\n  (is-univ2v2 (edge {a:(string-ascii 1),b:principal,c:uint,d:principal,e:principal,f:bool}))\n  (is-eq (get a edge) UNIV2V2))\n(define-read-only\n  (is-curve (edge {a:(string-ascii 1),b:principal,c:uint,d:principal,e:principal,f:bool}))\n  (is-eq (get a edge) CURVE))\n(define-read-only\n (is-usdh (edge {a:(string-ascii 1),b:principal,c:uint,d:principal,e:principal,f:bool}))\n (is-eq (get a edge) USDH))\n(define-read-only\n  (is-ststx (edge {a:(string-ascii 1),b:principal,c:uint,d:principal,e:principal,f:bool}))\n  (is-eq (get a edge) STSTX))\n\n(define-read-only\n (id (edge {a:(string-ascii 1),b:principal,c:uint,d:principal,e:principal,f:bool}))\n (get c edge))\n(define-read-only\n (from-is-token0 (edge {a:(string-ascii 1),b:principal,c:uint,d:principal,e:principal,f:bool}))\n (get f edge))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(define-public\n  (apply\n   (path   (list 4 {a:(string-ascii 1),b:principal,c:uint,d:principal,e:principal,f:bool}))\n   (amt-in uint)\n\n   ;; ctx\n   (token1         (optional <ft-trait>))\n   (token2         (optional <ft-trait>))\n   (token3         (optional <ft-trait>))\n   (token4         (optional <ft-trait>))\n   (token5         (optional <ft-trait>))\n\n   ;; v1\n   (share-fee-to   (optional <share-fee-to-trait>))\n\n   ;; v2\n   (univ2v2-pool-1 (optional <univ2v2-pool-trait>))\n   (univ2v2-pool-2 (optional <univ2v2-pool-trait>))\n   (univ2v2-pool-3 (optional <univ2v2-pool-trait>))\n   (univ2v2-pool-4 (optional <univ2v2-pool-trait>))\n\n   (univ2v2-fees-1 (optional <univ2v2-fees-trait>))\n   (univ2v2-fees-2 (optional <univ2v2-fees-trait>))\n   (univ2v2-fees-3 (optional <univ2v2-fees-trait>))\n   (univ2v2-fees-4 (optional <univ2v2-fees-trait>))\n\n   (curve-pool-1   (optional <curve-pool-trait>))\n   (curve-pool-2   (optional <curve-pool-trait>))\n   (curve-pool-3   (optional <curve-pool-trait>))\n   (curve-pool-4   (optional <curve-pool-trait>))\n\n   (curve-fees-1   (optional <curve-fees-trait>))\n   (curve-fees-2   (optional <curve-fees-trait>))\n   (curve-fees-3   (optional <curve-fees-trait>))\n   (curve-fees-4   (optional <curve-fees-trait>))\n\n   (ststx-pool-1   (optional <ststx-pool-trait>))\n   (ststx-pool-2   (optional <ststx-pool-trait>))\n   (ststx-pool-3   (optional <ststx-pool-trait>))\n   (ststx-pool-4   (optional <ststx-pool-trait>))\n\n   (ststx-proxy-1   (optional <ststx-proxy-trait>))\n   (ststx-proxy-2   (optional <ststx-proxy-trait>))\n   (ststx-proxy-3   (optional <ststx-proxy-trait>))\n   (ststx-proxy-4   (optional <ststx-proxy-trait>))\n   )\n  (let ((swap1 (try! (swap (element-at? path u0) amt-in\n                           token1 token2\n                           share-fee-to\n                           univ2v2-pool-1 univ2v2-fees-1\n                           curve-pool-1 curve-fees-1\n                           ststx-pool-1 ststx-proxy-1\n                           )))\n        (swap2 (try! (swap (element-at? path u1) (get amt-out swap1)\n                           token2 token3\n                           share-fee-to\n                           univ2v2-pool-2 univ2v2-fees-2\n                           curve-pool-2 curve-fees-2\n                           ststx-pool-2 ststx-proxy-2\n                           )))\n        (swap3 (try! (swap (element-at? path u2) (get amt-out swap2)\n                           token3 token4\n                           share-fee-to\n                           univ2v2-pool-3 univ2v2-fees-3\n                           curve-pool-3 curve-fees-3\n                           ststx-pool-3 ststx-proxy-3\n                           )))\n        (swap4 (try! (swap (element-at? path u3) (get amt-out swap3)\n                           token4 token5\n                           share-fee-to\n                           univ2v2-pool-4 univ2v2-fees-4\n                           curve-pool-4 curve-fees-4\n                           ststx-pool-4 ststx-proxy-4\n                           )))\n        )\n    (ok\n    {swap1: swap1,\n     swap2: swap2,\n     swap3: swap3,\n     swap4: swap4,\n    }) ))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(define-private\n  (swap\n   (edge   (optional {a:(string-ascii 1),b:principal,c:uint,d:principal,e:principal,f:bool}))\n   (amt-in uint)\n\n   (token-in     (optional <ft-trait>))\n   (token-out    (optional <ft-trait>))\n   (share-fee-to (optional <share-fee-to-trait>))\n   (univ2v2-pool (optional <univ2v2-pool-trait>))\n   (univ2v2-fees (optional <univ2v2-fees-trait>))\n   (curve-pool   (optional <curve-pool-trait>))\n   (curve-fees   (optional <curve-fees-trait>))\n   (ststx-pool   (optional <ststx-pool-trait>))\n   (ststx-proxy  (optional <ststx-proxy-trait>))\n\n   )\n  (match\n   edge\n   e\n    (if (is-univ2   e) (swap-univ2   e amt-in\n                                     (unwrap-panic token-in) (unwrap-panic token-out)\n                                     (unwrap-panic share-fee-to))\n    (if (is-univ2v2 e) (swap-univ2v2 e amt-in\n                                     (unwrap-panic token-in) (unwrap-panic token-out)\n                                     (unwrap-panic univ2v2-pool) (unwrap-panic univ2v2-fees))\n    (if (is-curve   e) (swap-curve   e amt-in\n                                     (unwrap-panic token-in) (unwrap-panic token-out)\n                                     (unwrap-panic curve-pool) (unwrap-panic curve-fees))\n    (if (is-usdh    e) (swap-curve   e amt-in\n                                     (unwrap-panic token-in) (unwrap-panic token-out)\n                                     (unwrap-panic curve-pool) (unwrap-panic curve-fees))\n    (if (is-ststx   e) (swap-ststx   e amt-in\n                                     (unwrap-panic token-in) (unwrap-panic token-out)\n                                     (unwrap-panic ststx-pool) (unwrap-panic curve-fees)\n                                     (unwrap-panic ststx-proxy))\n\n    (err u0))))))\n   (ok {amt-in: amt-in, amt-out: amt-in}) ))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(define-public\n  (swap-univ2\n   (edge         {a:(string-ascii 1),b:principal,c:uint,d:principal,e:principal,f:bool})\n   (amt-in       uint)\n   (token-in     <ft-trait>)\n   (token-out    <ft-trait>)\n   (share-fee-to <share-fee-to-trait>) )\n  (let ((res\n         (try!\n          (contract-call?\n           'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router\n           swap-exact-tokens-for-tokens\n           (id edge)\n           (if (from-is-token0 edge) token-in token-out)\n           (if (from-is-token0 edge) token-out token-in)\n           token-in\n           token-out\n           share-fee-to\n           amt-in\n           u1 ;;amt-out-min\n           ))))\n    (ok {amt-in: amt-in, amt-out: (get amt-out res)}) ))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(define-public\n  (swap-univ2v2\n   (edge         {a:(string-ascii 1),b:principal,c:uint,d:principal,e:principal,f:bool})\n   (amt-in       uint)\n   (token-in     <ft-trait>)\n   (token-out    <ft-trait>)\n   (univ2v2-pool <univ2v2-pool-trait>)\n   (univ2v2-fees <univ2v2-fees-trait>)\n   )\n  (let ((res\n         (try!\n          (contract-call?\n           univ2v2-pool\n           swap\n           token-in\n           token-out\n           univ2v2-fees\n           amt-in\n           u1 ;;amt-out-min\n           ))))\n    (ok {amt-in: amt-in, amt-out: (get amt-out res)}) ))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(define-public\n  (swap-curve\n   (edge         {a:(string-ascii 1),b:principal,c:uint,d:principal,e:principal,f:bool})\n   (amt-in       uint)\n   (token-in     <ft-trait>)\n   (token-out    <ft-trait>)\n   (curve-pool   <curve-pool-trait>)\n   (curve-fees   <curve-fees-trait>)\n   )\n  (let ((res (try! (contract-call?\n                      curve-pool\n                      swap\n                      token-in\n                      token-out\n                      curve-fees\n                      amt-in\n                      u1 ;;amt-out-min\n                      ))))\n    (ok {amt-in: amt-in, amt-out: (get amt-out res)}) ))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(define-public\n (swap-ststx\n  (edge         {a:(string-ascii 1),b:principal,c:uint,d:principal,e:principal,f:bool})\n  (amt-in       uint)\n  (token-in     <ft-trait>)\n  (token-out    <ft-trait>)\n  (ststx-pool   <ststx-pool-trait>)\n  (curve-fees   <curve-fees-trait>)\n  (ststx-proxy  <ststx-proxy-trait>)\n  )\n (let ((res (try! (contract-call?\n                   ststx-pool\n                   swap\n                   token-in\n                   token-out\n                   curve-fees\n                   ststx-proxy\n                   amt-in\n                   u1 ;;amt-out-min\n                   ))))\n   (ok {amt-in: amt-in, amt-out: (get amt-out res)}) ))\n\n;;; eof\n",
    "analysis": {
      "summary": "This contract facilitates multi-step token swaps across different liquidity pools on the Stacks blockchain.",
      "explanation": "This contract is designed to interact with various liquidity pool contracts to perform token swaps in a single transaction. It supports different pool types, including Uniswap V2-like pools, Curve-like pools, and a custom STSTX pool. The contract uses traits to ensure that the pools it interacts with adhere to expected interfaces.\n\n1. Constants and data variables:\n- MAX-EDGES <L17> and MAX-PATH-LEN <L18> set limits for the number of pools that can be involved in a swap and the length of the swap path, respectively.\n- Pool type constants <L22-26> are used to identify the type of each pool in the swap path.\n\n2. Functions:\n- The 'apply' function <L54-134> initiates a series of swaps across different pools specified by the path parameter. It takes in a list of edges (each representing a pool and swap details), the amount of input tokens, and optional traits for each pool type involved in the swaps. It sequentially performs swaps by calling the 'swap' function <L137-174> with the appropriate parameters based on the pool type.\n- The 'swap' function <L137-174> determines the type of the current pool in the swap path and calls the corresponding swap function specific to that pool type (e.g., 'swap-univ2', 'swap-univ2v2', 'swap-curve', 'swap-ststx'). It uses pattern matching on the edge parameter to identify the pool type and delegates the swap operation to the appropriate function.\n- Swap functions for each pool type ('swap-univ2' <L177-198>, 'swap-univ2v2' <L201-221>, 'swap-curve' <L224-242>, 'swap-ststx' <L245-265>) execute the actual token swap logic by calling the swap function of the respective liquidity pool contract. These functions handle the specifics of each pool type, such as fee calculation and token routing.\n\nEach swap function checks for the pool type and performs the swap by interacting with the corresponding pool contract, passing along necessary parameters like token addresses and amounts. Error handling is implemented to ensure that swaps only proceed if all parameters are correctly provided and the pool contracts execute swaps successfully.\n\nNotable qualities:\n- Modular design allowing for easy addition of new pool types.\n- Use of traits to ensure compatibility with different liquidity pool contracts.\n- Comprehensive error handling to ensure robustness in swap execution.",
      "tags": ["DeFi", "DEX", "swap", "liquidity-pool"]
    }
  },
  {
    "rank": 3,
    "contract": "SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.wrapper-alex-v-2-1",
    "calls": 20083,
    "source": "\n;; wrapper-alex-v-2-1\n\n(use-trait ft-trait 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.trait-sip-010.sip-010-trait)\n\n(define-public (swap-helper\n    (token-x-trait <ft-trait>) (token-y-trait <ft-trait>)\n    (factor uint)\n    (dx uint) (min-dy (optional uint))\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper\n                  token-x-trait\n                  token-y-trait\n                  factor\n                  dx min-dy)))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-public (swap-helper-a\n    (token-x-trait <ft-trait>) (token-y-trait <ft-trait>)\n    (token-z-trait <ft-trait>)\n    (factor-x uint) (factor-y uint)\n    (dx uint) (min-dz (optional uint))\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper-a\n                  token-x-trait token-y-trait\n                  token-z-trait\n                  factor-x factor-y\n                  dx min-dz)))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-public (swap-helper-b\n    (token-x-trait <ft-trait>) (token-y-trait <ft-trait>)\n    (token-z-trait <ft-trait>) (token-w-trait <ft-trait>)\n    (factor-x uint) (factor-y uint) (factor-z uint)\n    (dx uint) (min-dw (optional uint))\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper-b\n                  token-x-trait token-y-trait\n                  token-z-trait token-w-trait\n                  factor-x factor-y factor-z\n                  dx min-dw)))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-public (swap-helper-c\n    (token-x-trait <ft-trait>) (token-y-trait <ft-trait>)\n    (token-z-trait <ft-trait>) (token-w-trait <ft-trait>)\n    (token-v-trait <ft-trait>)\n    (factor-x uint) (factor-y uint) (factor-z uint) (factor-w uint)\n    (dx uint) (min-dv (optional uint))\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper-c\n                  token-x-trait token-y-trait\n                  token-z-trait token-w-trait\n                  token-v-trait\n                  factor-x factor-y factor-z factor-w\n                  dx min-dv)))\n  )\n    (ok swap-a)\n  )\n)\n",
    "analysis": {
      "summary": "This contract acts as a wrapper for interacting with an AMM pool, facilitating swaps between different sets of tokens.",
      "explanation": "The contract serves as an intermediary layer between users and an Automated Market Maker (AMM) pool, enabling users to swap tokens by calling the corresponding swap-helper functions. Each function is designed to handle a specific swap scenario, ranging from simple two-token swaps to more complex multi-token swaps. The contract uses the SIP-010 trait for fungible tokens to ensure compatibility with the Stacks ecosystem's standard for token contracts. Here's a detailed breakdown of its components and functionalities:\n\n1. The contract imports the SIP-010 fungible token trait from another contract <L4>, ensuring that any token passed to this contract adheres to the standard interface for fungible tokens on Stacks.\n\n2. The 'swap-helper' function <L6-20> is designed for swapping between two tokens. It accepts traits for both tokens involved in the swap, a 'factor' that could influence the swap logic (though its exact use is not specified within this contract), the amount of the first token to swap ('dx'), and a minimum acceptable amount for the second token ('min-dy'). This function calls an external contract's 'swap-helper' method, passing along all provided parameters <L12-17>, and returns the result of that call.\n\n3. The 'swap-helper-a' function <L23-38> extends the swapping functionality to handle a scenario involving three tokens. It introduces an additional token trait parameter and factors for each swap step, allowing for a two-step swap process through an external AMM pool.\n\n4. Similarly, 'swap-helper-b' <L41-56> and 'swap-helper-c' <L59-76> further extend this functionality to four and five tokens, respectively, each adding more token traits and factors to accommodate the complexity of swapping multiple tokens in sequence.\n\nEach function performs a safety check using 'try!' to catch any errors from the external contract calls <L12, L31, L48, L67>. If the external call fails, the whole transaction is aborted, ensuring that users do not lose their tokens due to failed swaps.\n\nNotably, the contract assumes that the external AMM pool it interacts with supports the same 'swap-helper' interfaces for two, three, four, and five-token swaps, which indicates a highly modular and potentially complex underlying AMM logic.",
      "tags": ["utility", "DeFi", "swap", "fungible-token"],
      "notable_qualities": [
        "The contract abstracts complex swap logic into simpler, high-level functions that can be easily called by other contracts or users.",
        "It demonstrates a practical use of the SIP-010 trait for fungible tokens, ensuring compatibility within the Stacks ecosystem.",
        "The use of 'try!' for error handling in external contract calls emphasizes safety and robustness in contract design.",
        "The contract's design allows for scalability, accommodating swaps involving an increasing number of tokens without significantly complicating the interface."
      ]
    }
  },
  {
    "rank": 4,
    "contract": "SP2QEZ06AGJ3RKJPBV14SY1V5BBFNAW33D96YPGZF.BNS-V2",
    "calls": 16340,
    "source": ";; title: BNS-V2\n;; version: V-2\n;; summary: Updated BNS contract, handles the creation of new namespaces and new names on each namespace\n\n;; traits\n;; (new) Import SIP-09 NFT trait \n(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)\n;; (new) Import a custom commission trait for handling commissions for NFT marketplaces functions\n(use-trait commission-trait .commission-trait.commission)\n\n;; token definition\n;; (new) Define the non-fungible token (NFT) called BNS-V2 with unique identifiers as unsigned integers\n(define-non-fungible-token BNS-V2 uint)\n;; Time-to-live (TTL) constants for namespace preorders and name preorders, and the duration for name grace period.\n;; The TTL for namespace and names preorders. (1 day)\n(define-constant PREORDER-CLAIMABILITY-TTL u144) \n;; The duration after revealing a namespace within which it must be launched. (1 year)\n(define-constant NAMESPACE-LAUNCHABILITY-TTL u52595) \n;; The grace period duration for name renewals post-expiration. (34 days)\n(define-constant NAME-GRACE-PERIOD-DURATION u5000) \n;; (new) The length of the hash should match this\n(define-constant HASH160LEN u20)\n;; Defines the price tiers for namespaces based on their lengths.\n(define-constant NAMESPACE-PRICE-TIERS (list\n    u640000000000\n    u64000000000 u64000000000 \n    u6400000000 u6400000000 u6400000000 u6400000000 \n    u640000000 u640000000 u640000000 u640000000 u640000000 u640000000 u640000000 u640000000 u640000000 u640000000 u640000000 u640000000 u640000000)\n)\n\n;; Only authorized caller to flip the switch and update URI\n(define-constant DEPLOYER tx-sender)\n\n;; (new) Var to store the token URI, allowing for metadata association with the NFT\n(define-data-var token-uri (string-ascii 256) \"ipfs://QmUQY1aZ799SPRaNBFqeCvvmZ4fTQfZvWHauRvHAukyQDB\")\n\n(define-public (update-token-uri (new-token-uri (string-ascii 256)))\n    (ok \n        (begin \n            (asserts! (is-eq contract-caller DEPLOYER) ERR-NOT-AUTHORIZED) \n            (var-set token-uri new-token-uri)\n        )\n    )\n)\n\n(define-data-var contract-uri (string-ascii 256) \"ipfs://QmWKTZEMQNWngp23i7bgPzkineYC9LDvcxYkwNyVQVoH8y\")\n\n(define-public (update-contract-uri (new-contract-uri (string-ascii 256)))\n    (ok \n        (begin \n            (asserts! (is-eq contract-caller DEPLOYER) ERR-NOT-AUTHORIZED) \n            (var-set token-uri new-contract-uri)\n        )\n    )\n)\n\n;; errors\n(define-constant ERR-UNWRAP (err u101))\n(define-constant ERR-NOT-AUTHORIZED (err u102))\n(define-constant ERR-NOT-LISTED (err u103))\n(define-constant ERR-WRONG-COMMISSION (err u104))\n(define-constant ERR-LISTED (err u105))\n(define-constant ERR-NO-NAME (err u106))\n(define-constant ERR-HASH-MALFORMED (err u107))\n(define-constant ERR-STX-BURNT-INSUFFICIENT (err u108))\n(define-constant ERR-PREORDER-NOT-FOUND (err u109))\n(define-constant ERR-CHARSET-INVALID (err u110))\n(define-constant ERR-NAMESPACE-ALREADY-EXISTS (err u111))\n(define-constant ERR-PREORDER-CLAIMABILITY-EXPIRED (err u112))\n(define-constant ERR-NAMESPACE-NOT-FOUND (err u113))\n(define-constant ERR-OPERATION-UNAUTHORIZED (err u114))\n(define-constant ERR-NAMESPACE-ALREADY-LAUNCHED (err u115))\n(define-constant ERR-NAMESPACE-PREORDER-LAUNCHABILITY-EXPIRED (err u116))\n(define-constant ERR-NAMESPACE-NOT-LAUNCHED (err u117))\n(define-constant ERR-NAME-NOT-AVAILABLE (err u118))\n(define-constant ERR-NAMESPACE-BLANK (err u119))\n(define-constant ERR-NAME-BLANK (err u120))\n(define-constant ERR-NAME-PREORDERED-BEFORE-NAMESPACE-LAUNCH (err u121))\n(define-constant ERR-NAMESPACE-HAS-MANAGER (err u122))\n(define-constant ERR-OVERFLOW (err u123))\n(define-constant ERR-NO-NAMESPACE-MANAGER (err u124))\n(define-constant ERR-FAST-MINTED-BEFORE (err u125))\n(define-constant ERR-PREORDERED-BEFORE (err u126))\n(define-constant ERR-NAME-NOT-CLAIMABLE-YET (err u127))\n(define-constant ERR-IMPORTED-BEFORE (err u128))\n(define-constant ERR-LIFETIME-EQUAL-0 (err u129))\n(define-constant ERR-MIGRATION-IN-PROGRESS (err u130))\n(define-constant ERR-NO-PRIMARY-NAME (err u131))\n\n;; variables\n;; (new) Variable to see if migration is complete\n(define-data-var migration-complete bool false)\n\n;; (new) Counter to keep track of the last minted NFT ID, ensuring unique identifiers\n(define-data-var bns-index uint u0)\n\n;; maps\n;; (new) Map to track market listings, associating NFT IDs with price and commission details\n(define-map market uint {price: uint, commission: principal})\n\n;; (new) Define a map to link NFT IDs to their respective names and namespaces.\n(define-map index-to-name uint \n    {\n        name: (buff 48), namespace: (buff 20)\n    } \n)\n;; (new) Define a map to link names and namespaces to their respective NFT IDs.\n(define-map name-to-index \n    {\n        name: (buff 48), namespace: (buff 20)\n    } \n    uint\n)\n\n;; (updated) Contains detailed properties of names, including registration and importation times\n(define-map name-properties\n    { name: (buff 48), namespace: (buff 20) }\n    {\n        registered-at: (optional uint),\n        imported-at: (optional uint),\n        ;; The fqn used to make the earliest preorder at any given point\n        hashed-salted-fqn-preorder: (optional (buff 20)),\n        ;; Added this field in name-properties to know exactly who has the earliest preorder at any given point\n        preordered-by: (optional principal),\n        renewal-height: uint,\n        stx-burn: uint,\n        owner: principal,\n    }\n)\n\n;; (update) Stores properties of namespaces, including their import principals, reveal and launch times, and pricing functions.\n(define-map namespaces (buff 20)\n    { \n        namespace-manager: (optional principal),\n        manager-transferable: bool,\n        manager-frozen: bool,\n        namespace-import: principal,\n        revealed-at: uint,\n        launched-at: (optional uint),\n        lifetime: uint,\n        can-update-price-function: bool,\n        price-function: \n            {\n                buckets: (list 16 uint),\n                base: uint, \n                coeff: uint, \n                nonalpha-discount: uint, \n                no-vowel-discount: uint\n            }\n    }\n)\n\n;; Records namespace preorder transactions with their creation times, and STX burned.\n(define-map namespace-preorders\n    { hashed-salted-namespace: (buff 20), buyer: principal }\n    { created-at: uint, stx-burned: uint, claimed: bool}\n)\n\n;; Tracks preorders, to avoid attacks\n(define-map namespace-single-preorder (buff 20) bool)\n\n;; Tracks preorders, to avoid attacks\n(define-map name-single-preorder (buff 20) bool)\n\n;; Tracks preorders for names, including their creation times, and STX burned.\n(define-map name-preorders\n    { hashed-salted-fqn: (buff 20), buyer: principal }\n    { created-at: uint, stx-burned: uint, claimed: bool}\n)\n\n;; It maps a user's principal to the ID of their primary name.\n(define-map primary-name principal uint)\n\n;; read-only\n;; @desc (new) SIP-09 compliant function to get the last minted token's ID\n(define-read-only (get-last-token-id)\n    ;; Returns the current value of bns-index variable, which tracks the last token ID\n    (ok (var-get bns-index))\n)\n\n(define-read-only (get-renewal-height (id uint))\n    (let \n        (\n            (name-namespace (unwrap! (get-bns-from-id id) ERR-NO-NAME))\n            (namespace-props (unwrap! (map-get? namespaces (get namespace name-namespace)) ERR-NAMESPACE-NOT-FOUND))\n            (name-props (unwrap! (map-get? name-properties name-namespace) ERR-NO-NAME))\n            (renewal-height (get renewal-height name-props))\n            (namespace-lifetime (get lifetime namespace-props))\n        )\n        ;; Check if the namespace requires renewals\n        (asserts! (not (is-eq namespace-lifetime u0)) ERR-LIFETIME-EQUAL-0) \n        ;; If the check passes then check the renewal-height of the name\n        (ok \n            (if (is-eq renewal-height u0)\n                ;; If it is true then it means it was imported so return the namespace launch blockheight + lifetime\n                (+ (unwrap! (get launched-at namespace-props) ERR-NAMESPACE-NOT-LAUNCHED) namespace-lifetime) \n                renewal-height\n            )\n        )\n    )\n)\n\n(define-read-only (can-resolve-name (namespace (buff 20)) (name (buff 48)))\n    (let \n        (\n            (name-id (unwrap! (get-id-from-bns name namespace) ERR-NO-NAME))\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n            (name-props (unwrap! (map-get? name-properties {name: name, namespace: namespace}) ERR-NO-NAME))\n            (renewal-height (get renewal-height name-props))\n            (namespace-lifetime (get lifetime namespace-props))\n        )\n        ;; Check if the name can resolve\n        (ok \n            (if (is-eq u0 namespace-lifetime)\n                ;; If true it means that the name is in a managed namespace or the namespace does not require renewals\n                {renewal: u0, owner: (get owner name-props)}\n                ;; If false then calculate renewal-height\n                {renewal: (try! (get-renewal-height name-id)), owner: (get owner name-props)}\n            )\n        )\n    )\n)\n\n;; @desc (new) SIP-09 compliant function to get token URI\n(define-read-only (get-token-uri (id uint))\n    ;; Returns a predefined set URI for the token metadata\n    (ok (some (var-get token-uri)))\n)\n\n(define-read-only (get-contract-uri)\n    ;; Returns a predefined set URI for the contract metadata\n    (ok (some (var-get contract-uri)))\n)\n\n;; @desc (new) SIP-09 compliant function to get the owner of a specific token by its ID\n(define-read-only (get-owner (id uint))\n    ;; Check and return the owner of the specified NFT\n    (ok (nft-get-owner? BNS-V2 id))\n)\n\n;; @desc (new) New get owner function\n(define-read-only (get-owner-name (name (buff 48)) (namespace (buff 20)))\n    ;; Check and return the owner of the specified NFT\n    (ok (nft-get-owner? BNS-V2 (unwrap! (get-id-from-bns name namespace) ERR-NO-NAME)))\n)\n\n;; Read-only function `get-namespace-price` calculates the registration price for a namespace based on its length.\n;; @params:\n    ;; namespace (buff 20): The namespace for which the price is being calculated.\n(define-read-only (get-namespace-price (namespace (buff 20)))\n    (let \n        (\n            ;; Calculate the length of the namespace.\n            (namespace-len (len namespace))\n        )\n        ;; Ensure the namespace is not blank, its length is greater than 0.\n        (asserts! (> namespace-len u0) ERR-NAMESPACE-BLANK)\n        ;; Retrieve the price for the namespace based on its length from the NAMESPACE-PRICE-TIERS list.\n        ;; The price tier is determined by the minimum of 7 or the namespace length minus one.\n        (ok (unwrap! (element-at? NAMESPACE-PRICE-TIERS (min u7 (- namespace-len u1))) ERR-UNWRAP))\n    )\n)\n\n;; Read-only function `get-name-price` calculates the registration price for a name based on the price buckets of the namespace\n;; @params:\n    ;; namespace (buff 20): The namespace for which the price is being calculated.\n    ;; name (buff 48): The name for which the price is being calculated.\n(define-read-only (get-name-price (namespace (buff 20)) (name (buff 48)))\n    (let \n        (\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n        )\n        (ok (compute-name-price name (get price-function namespace-props)))\n    )\n)\n\n;; Read-only function `can-namespace-be-registered` checks if a namespace is available for registration.\n;; @params:\n    ;; namespace (buff 20): The namespace being checked for availability.\n(define-read-only (can-namespace-be-registered (namespace (buff 20)))\n    ;; Returns the result of `is-namespace-available` directly, indicating if the namespace can be registered.\n    (ok (is-namespace-available namespace))\n)\n\n;; Read-only function `get-namespace-properties` for retrieving properties of a specific namespace.\n;; @params:\n    ;; namespace (buff 20): The namespace whose properties are being queried.\n(define-read-only (get-namespace-properties (namespace (buff 20)))\n    (let \n        (\n            ;; Fetch the properties of the specified namespace from the `namespaces` map.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n        )\n        ;; Returns the namespace along with its associated properties.\n        (ok { namespace: namespace, properties: namespace-props })\n    )\n)\n\n;; Read only function to get name properties\n(define-read-only (get-bns-info (name (buff 48)) (namespace (buff 20)))\n    (map-get? name-properties {name: name, namespace: namespace})\n)\n\n;; (new) Defines a read-only function to fetch the unique ID of a BNS name given its name and the namespace it belongs to.\n(define-read-only (get-id-from-bns (name (buff 48)) (namespace (buff 20))) \n    ;; Attempts to retrieve the ID from the 'name-to-index' map using the provided name and namespace as the key.\n    (map-get? name-to-index {name: name, namespace: namespace})\n)\n\n;; (new) Defines a read-only function to fetch the BNS name and the namespace given a unique ID.\n(define-read-only (get-bns-from-id (id uint)) \n    ;; Attempts to retrieve the name and namespace from the 'index-to-name' map using the provided id as the key.\n    (map-get? index-to-name id)\n)\n\n;; (new) Fetcher for primary name\n(define-read-only (get-primary-name (owner principal))\n    (map-get? primary-name owner)\n)\n\n;; (new) Fetcher for primary name returns name and namespace\n(define-read-only (get-primary (owner principal))\n    (ok (get-bns-from-id (unwrap! (map-get? primary-name owner) ERR-NO-PRIMARY-NAME)))\n)\n\n;; public functions\n;; @desc (new) SIP-09 compliant function to transfer a token from one owner to another.\n;; @param id: ID of the NFT being transferred.\n;; @param owner: Principal of the current owner of the NFT.\n;; @param recipient: Principal of the recipient of the NFT.\n(define-public (transfer (id uint) (owner principal) (recipient principal))\n    (let \n        (\n            ;; Get the name and namespace of the NFT.\n            (name-and-namespace (unwrap! (get-bns-from-id id) ERR-NO-NAME))\n            (namespace (get namespace name-and-namespace))\n            (name (get name name-and-namespace))\n            ;; Get namespace properties and manager.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n            (manager-transfers (get manager-transferable namespace-props))\n            ;; Get name properties and owner.\n            (name-props (unwrap! (map-get? name-properties name-and-namespace) ERR-NO-NAME))\n            (registered-at-value (get registered-at name-props))\n            (nft-current-owner (unwrap! (nft-get-owner? BNS-V2 id) ERR-NO-NAME))\n        )\n        ;; First check if the name was registered\n        (match registered-at-value\n            is-registered\n            ;; If it was registered, check if registered-at is lower than current blockheight\n            ;; This check works to make sure that if a name is fast-claimed they have to wait 1 block to transfer it\n            (asserts! (< is-registered burn-block-height) ERR-OPERATION-UNAUTHORIZED)\n            ;; If it is not registered then continue\n            true \n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Check that the namespace is launched\n        (asserts! (is-some (get launched-at namespace-props)) ERR-NAMESPACE-NOT-LAUNCHED)\n        ;; Check owner and recipient is not the same\n        (asserts! (not (is-eq nft-current-owner recipient)) ERR-OPERATION-UNAUTHORIZED)\n        ;; We only need to check if manager transfers are true or false, if true then they have to do transfers through the manager contract that calls into mng-transfer, if false then they can call into this function\n        (asserts! (not manager-transfers) ERR-NOT-AUTHORIZED)\n        ;; Check contract-caller\n        (asserts! (is-eq contract-caller nft-current-owner) ERR-NOT-AUTHORIZED)\n        ;; Check if in fact the owner is-eq to nft-current-owner\n        (asserts! (is-eq owner nft-current-owner) ERR-NOT-AUTHORIZED)\n        ;; Ensures the NFT is not currently listed in the market.\n        (asserts! (is-none (map-get? market id)) ERR-LISTED)\n        ;; Update the name properties with the new owner\n        (map-set name-properties name-and-namespace (merge name-props {owner: recipient}))\n        ;; Update primary name if needed for owner\n        (update-primary-name-owner id owner)\n        ;; Update primary name if needed for recipient\n        (update-primary-name-recipient id recipient)\n        ;; Execute the NFT transfer.\n        (try! (nft-transfer? BNS-V2 id nft-current-owner recipient))\n        (print \n            {\n                topic: \"transfer-name\", \n                owner: recipient, \n                name: {name: name, namespace: namespace}, \n                id: id,\n                properties: (map-get? name-properties {name: name, namespace: namespace})\n            }\n        )\n        (ok true)\n    )\n)\n\n;; @desc (new) manager function to be called by managed namespaces that allows manager transfers.\n;; @param id: ID of the NFT being transferred.\n;; @param owner: Principal of the current owner of the NFT.\n;; @param recipient: Principal of the recipient of the NFT.\n(define-public (mng-transfer (id uint) (owner principal) (recipient principal))\n    (let \n        (\n            ;; Get the name and namespace of the NFT.\n            (name-and-namespace (unwrap! (get-bns-from-id id) ERR-NO-NAME))\n            (namespace (get namespace name-and-namespace))\n            (name (get name name-and-namespace))\n            ;; Get namespace properties and manager.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n            (manager-transfers (get manager-transferable namespace-props))\n            (manager (get namespace-manager namespace-props))\n            ;; Get name properties and owner.\n            (name-props (unwrap! (map-get? name-properties name-and-namespace) ERR-NO-NAME))\n            (registered-at-value (get registered-at name-props))\n            (nft-current-owner (unwrap! (nft-get-owner? BNS-V2 id) ERR-NO-NAME))\n        )\n        ;; First check if the name was registered\n        (match registered-at-value\n            is-registered\n            ;; If it was registered, check if registered-at is lower than current blockheight\n            ;; This check works to make sure that if a name is fast-claimed they have to wait 1 block to transfer it\n            (asserts! (< is-registered burn-block-height) ERR-OPERATION-UNAUTHORIZED)\n            ;; If it is not registered then continue\n            true \n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Check that the namespace is launched\n        (asserts! (is-some (get launched-at namespace-props)) ERR-NAMESPACE-NOT-LAUNCHED)\n        ;; Check owner and recipient is not the same\n        (asserts! (not (is-eq nft-current-owner recipient)) ERR-OPERATION-UNAUTHORIZED)\n        ;; We only need to check if manager transfers are true or false, if true then continue, if false then they can call into `transfer` function\n        (asserts! manager-transfers ERR-NOT-AUTHORIZED)\n        ;; Check contract-caller, we unwrap-panic because if manager-transfers is true then there has to be a manager\n        (asserts! (is-eq contract-caller (unwrap-panic manager)) ERR-NOT-AUTHORIZED)\n        ;; Check if in fact the owner is-eq to nft-current-owner\n        (asserts! (is-eq owner nft-current-owner) ERR-NOT-AUTHORIZED)\n        ;; Ensures the NFT is not currently listed in the market.\n        (asserts! (is-none (map-get? market id)) ERR-LISTED)\n        ;; Update primary name if needed for owner\n        (update-primary-name-owner id owner)\n        ;; Update primary name if needed for recipient\n        (update-primary-name-recipient id recipient)\n        ;; Update the name properties with the new owner\n        (map-set name-properties name-and-namespace (merge name-props {owner: recipient}))\n        ;; Execute the NFT transfer.\n        (try! (nft-transfer? BNS-V2 id nft-current-owner recipient))\n        (print \n            {\n                topic: \"transfer-name\", \n                owner: recipient, \n                name: {name: name, namespace: namespace}, \n                id: id,\n                properties: (map-get? name-properties {name: name, namespace: namespace})\n            }\n        )\n        (ok true)\n    )\n)\n\n;; @desc (new) Function to list an NFT for sale.\n;; @param id: ID of the NFT being listed.\n;; @param price: Listing price.\n;; @param comm-trait: Address of the commission-trait.\n(define-public (list-in-ustx (id uint) (price uint) (comm-trait <commission-trait>))\n    (let\n        (\n            ;; Get the name and namespace of the NFT.\n            (name-and-namespace (unwrap! (map-get? index-to-name id) ERR-NO-NAME))\n            (namespace (get namespace name-and-namespace))\n            ;; Get namespace properties and manager.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n            (namespace-manager (get namespace-manager namespace-props))\n            ;; Get name properties and registered-at value.\n            (name-props (unwrap! (map-get? name-properties name-and-namespace) ERR-NO-NAME))\n            (registered-at-value (get registered-at name-props))\n            ;; Creates a listing record with price and commission details\n            (listing {price: price, commission: (contract-of comm-trait)})\n        )\n        ;; Checks if the name was registered\n        (match registered-at-value\n            is-registered\n            ;; If it was registered, check if registered-at is lower than current blockheight\n            ;; Same as transfers, this check works to make sure that if a name is fast-claimed they have to wait 1 block to list it\n            (asserts! (< is-registered burn-block-height) ERR-OPERATION-UNAUTHORIZED)\n            ;; If it is not registered then continue\n            true \n        )\n        ;; Check if there is a namespace manager\n        (match namespace-manager \n            manager \n            ;; If there is then check that the contract-caller is the manager\n            (asserts! (is-eq manager contract-caller) ERR-NOT-AUTHORIZED)\n            ;; If there isn't assert that the owner is the contract-caller\n            (asserts! (is-eq (some contract-caller) (nft-get-owner? BNS-V2 id)) ERR-NOT-AUTHORIZED)\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Updates the market map with the new listing details\n        (map-set market id listing)\n        ;; Prints listing details\n        (ok (print (merge listing {a: \"list-in-ustx\", id: id})))\n    )\n)\n\n;; @desc (new) Function to remove an NFT listing from the market.\n;; @param id: ID of the NFT being unlisted.\n(define-public (unlist-in-ustx (id uint))\n    (let\n        (\n            ;; Get the name and namespace of the NFT.\n            (name-and-namespace (unwrap! (map-get? index-to-name id) ERR-NO-NAME))\n            (namespace (get namespace name-and-namespace))\n            ;; Verify if the NFT is listed in the market.\n            (market-map (unwrap! (map-get? market id) ERR-NOT-LISTED))\n            ;; Get namespace properties and manager.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n            (namespace-manager (get namespace-manager namespace-props))\n        )\n        ;; Check if there is a namespace manager\n        (match namespace-manager \n            manager \n            ;; If there is then check that the contract-caller is the manager\n            (asserts! (is-eq manager contract-caller) ERR-NOT-AUTHORIZED)\n            ;; If there isn't assert that the owner is the contract-caller\n            (asserts! (is-eq (some contract-caller) (nft-get-owner? BNS-V2 id)) ERR-NOT-AUTHORIZED)\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Deletes the listing from the market map\n        (map-delete market id)\n        ;; Prints unlisting details\n        (ok (print {a: \"unlist-in-ustx\", id: id}))\n    )\n)   \n\n;; @desc (new) Function to buy an NFT listed for sale, transferring ownership and handling commission.\n;; @param id: ID of the NFT being purchased.\n;; @param comm-trait: Address of the commission-trait.\n(define-public (buy-in-ustx (id uint) (comm-trait <commission-trait>))\n    (let\n        (\n            ;; Retrieves current owner and listing details\n            (owner (unwrap! (nft-get-owner? BNS-V2 id) ERR-NO-NAME))\n            (listing (unwrap! (map-get? market id) ERR-NOT-LISTED))\n            (price (get price listing))\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Verifies the commission details match the listing\n        (asserts! (is-eq (contract-of comm-trait) (get commission listing)) ERR-WRONG-COMMISSION)\n        ;; Transfers STX from buyer to seller\n        (try! (stx-transfer? price contract-caller owner))\n        ;; Handle commission payment\n        (try! (contract-call? comm-trait pay id price))\n        ;; Transfers the NFT to the buyer\n        ;; This function differs from the `transfer` method by not checking who the contract-caller is, otherwise trasnfers would never be executed\n        (try! (purchase-transfer id owner contract-caller))\n        ;; Removes the listing from the market map\n        (map-delete market id)\n        ;; Prints purchase details\n        (ok (print {a: \"buy-in-ustx\", id: id}))\n    )\n)\n\n;; @desc (new) Sets the primary name for the caller to a specific BNS name they own.\n;; @param primary-name-id: ID of the name to be set as primary.\n(define-public (set-primary-name (primary-name-id uint))\n    (begin \n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Verify the contract-caller is the owner of the name.\n        (asserts! (is-eq (unwrap! (nft-get-owner? BNS-V2 primary-name-id) ERR-NO-NAME) contract-caller) ERR-NOT-AUTHORIZED)\n        ;; Update the contract-caller's primary name.\n        (map-set primary-name contract-caller primary-name-id)\n        ;; Return true upon successful execution.\n        (ok true)\n    )\n)\n\n;; @desc (new) Defines a public function to burn an NFT, under managed namespaces.\n;; @param id: ID of the NFT to be burned.\n(define-public (mng-burn (id uint)) \n    (let \n        (\n            ;; Get the name details associated with the given ID.\n            (name-and-namespace (unwrap! (get-bns-from-id id) ERR-NO-NAME))\n            ;; Get the owner of the name.\n            (owner (unwrap! (nft-get-owner? BNS-V2 id) ERR-UNWRAP)) \n        ) \n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Ensure the caller is the current namespace manager.\n        (asserts! (is-eq contract-caller (unwrap! (get namespace-manager (unwrap! (map-get? namespaces (get namespace name-and-namespace)) ERR-NAMESPACE-NOT-FOUND)) ERR-NO-NAMESPACE-MANAGER)) ERR-NOT-AUTHORIZED)\n        ;; Unlist the NFT if it is listed.\n        (match (map-get? market id)\n            listed-name \n            (map-delete market id) \n            true\n        )\n        ;; Update primary name if needed for the owner of the name\n        (update-primary-name-owner id owner)\n        ;; Delete the name from all maps:\n        ;; Remove the name-to-index.\n        (map-delete name-to-index name-and-namespace)\n        ;; Remove the index-to-name.\n        (map-delete index-to-name id)\n        ;; Remove the name-properties.\n        (map-delete name-properties name-and-namespace)\n        ;; Executes the burn operation for the specified NFT.\n        (try! (nft-burn? BNS-V2 id (unwrap! (nft-get-owner? BNS-V2 id) ERR-UNWRAP)))\n        (print \n            {\n                topic: \"burn-name\", \n                owner: \"\", \n                name: {name: (get name name-and-namespace), namespace: (get namespace name-and-namespace)}, \n                id: id\n            }\n        )\n        (ok true)\n    )\n)\n\n;; @desc (new) Transfers the management role of a specific namespace to a new principal.\n;; @param new-manager: Principal of the new manager.\n;; @param namespace: Buffer of the namespace.\n(define-public (mng-manager-transfer (new-manager (optional principal)) (namespace (buff 20)))\n    (let \n        (\n            ;; Retrieve namespace properties and current manager.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS) \n        ;; Ensure the caller is the current namespace manager.\n        (asserts! (is-eq contract-caller (unwrap! (get namespace-manager namespace-props) ERR-NO-NAMESPACE-MANAGER)) ERR-NOT-AUTHORIZED)\n        ;; Ensure manager can be changed\n        (asserts! (not (get manager-frozen namespace-props)) ERR-NOT-AUTHORIZED)\n        ;; Update the namespace manager to the new manager.\n        (map-set namespaces namespace \n            (merge \n                namespace-props \n                {namespace-manager: new-manager}\n            )\n        )\n        (print { namespace: namespace, status: \"transfer-manager\", properties: (map-get? namespaces namespace) })\n        (ok true)\n    )\n)\n\n;; @desc (new) freezes the ability to make manager transfers\n;; @param namespace: Buffer of the namespace.\n(define-public (freeze-manager (namespace (buff 20)))\n    (let \n        (\n            ;; Retrieve namespace properties and current manager.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Ensure the caller is the current namespace manager.\n        (asserts! (is-eq contract-caller (unwrap! (get namespace-manager namespace-props) ERR-NO-NAMESPACE-MANAGER)) ERR-NOT-AUTHORIZED)\n        ;; Update the namespace manager to the new manager.\n        (map-set namespaces namespace \n                (merge \n                    namespace-props \n                    {manager-frozen: true}\n                )\n            )\n        (print { namespace: namespace, status: \"freeze-manager\", properties: (map-get? namespaces namespace) })\n        (ok true)\n    )\n)\n\n;;;; NAMESPACES\n;; @desc Public function `namespace-preorder` initiates the registration process for a namespace by sending a transaction with a salted hash of the namespace.\n;; This transaction burns the registration fee as a commitment.\n;; @params: hashed-salted-namespace (buff 20): The hashed and salted namespace being preordered.\n;; @params: stx-to-burn (uint): The amount of STX tokens to be burned as part of the preorder process.\n(define-public (namespace-preorder (hashed-salted-namespace (buff 20)) (stx-to-burn uint))\n    (begin\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS) \n        ;; Validate that the hashed-salted-namespace is exactly 20 bytes long.\n        (asserts! (is-eq (len hashed-salted-namespace) HASH160LEN) ERR-HASH-MALFORMED)\n        ;; Check if the same hashed-salted-fqn has been used before\n        (asserts! (is-none (map-get? namespace-single-preorder hashed-salted-namespace)) ERR-PREORDERED-BEFORE)\n        ;; Confirm that the STX amount to be burned is positive\n        (asserts! (> stx-to-burn u0) ERR-STX-BURNT-INSUFFICIENT)\n        ;; Execute the token burn operation.\n        (try! (stx-burn? stx-to-burn contract-caller))\n        ;; Record the preorder details in the `namespace-preorders` map\n        (map-set namespace-preorders\n            { hashed-salted-namespace: hashed-salted-namespace, buyer: contract-caller }\n            { created-at: burn-block-height, stx-burned: stx-to-burn, claimed: false }\n        )\n        ;; Sets the map with just the hashed-salted-namespace as the key\n        (map-set namespace-single-preorder hashed-salted-namespace true)\n        ;; Return the block height at which the preorder claimability expires.\n        (ok (+ burn-block-height PREORDER-CLAIMABILITY-TTL))\n    )\n)\n\n;; @desc Public function `namespace-reveal` completes the second step in the namespace registration process.\n;; It associates the revealed namespace with its corresponding preorder, establishes the namespace's pricing function, and sets its lifetime and ownership details.\n;; @param: namespace (buff 20): The namespace being revealed.\n;; @param: namespace-salt (buff 20): The salt used during the preorder to generate a unique hash.\n;; @param: p-func-base, p-func-coeff, p-func-b1 to p-func-b16: Parameters defining the price function for registering names within this namespace.\n;; @param: p-func-non-alpha-discount (uint): Discount applied to names with non-alphabetic characters.\n;; @param: p-func-no-vowel-discount (uint): Discount applied to names without vowels.\n;; @param: lifetime (uint): Duration that names within this namespace are valid before needing renewal.\n;; @param: namespace-import (principal): The principal authorized to import names into this namespace.\n;; @param: namespace-manager (optional principal): The principal authorized to manage the namespace.\n(define-public (namespace-reveal \n    (namespace (buff 20)) \n    (namespace-salt (buff 20)) \n    (p-func-base uint) \n    (p-func-coeff uint) \n    (p-func-b1 uint) \n    (p-func-b2 uint) \n    (p-func-b3 uint) \n    (p-func-b4 uint) \n    (p-func-b5 uint) \n    (p-func-b6 uint) \n    (p-func-b7 uint) \n    (p-func-b8 uint) \n    (p-func-b9 uint) \n    (p-func-b10 uint) \n    (p-func-b11 uint) \n    (p-func-b12 uint) \n    (p-func-b13 uint) \n    (p-func-b14 uint) \n    (p-func-b15 uint) \n    (p-func-b16 uint) \n    (p-func-non-alpha-discount uint) \n    (p-func-no-vowel-discount uint) \n    (lifetime uint) \n    (namespace-import principal) \n    (namespace-manager (optional principal)) \n    (can-update-price bool) \n    (manager-transfers bool) \n    (manager-frozen bool)\n)\n    (let \n        (\n            ;; Generate the hashed, salted namespace identifier to match with its preorder.\n            (hashed-salted-namespace (hash160 (concat (concat namespace 0x2e) namespace-salt)))\n            ;; Define the price function based on the provided parameters.\n            (price-function  \n                {\n                    buckets: (list p-func-b1 p-func-b2 p-func-b3 p-func-b4 p-func-b5 p-func-b6 p-func-b7 p-func-b8 p-func-b9 p-func-b10 p-func-b11 p-func-b12 p-func-b13 p-func-b14 p-func-b15 p-func-b16),\n                    base: p-func-base,\n                    coeff: p-func-coeff,\n                    nonalpha-discount: p-func-non-alpha-discount,\n                    no-vowel-discount: p-func-no-vowel-discount\n                }\n            )\n            ;; Retrieve the preorder record to ensure it exists and is valid for the revealing namespace\n            (preorder (unwrap! (map-get? namespace-preorders { hashed-salted-namespace: hashed-salted-namespace, buyer: contract-caller}) ERR-PREORDER-NOT-FOUND))\n            ;; Calculate the namespace's registration price for validation.\n            (namespace-price (try! (get-namespace-price namespace)))\n        )\n        ;; Ensure the preorder has not been claimed before\n        (asserts! (not (get claimed preorder)) ERR-NAMESPACE-ALREADY-EXISTS)\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Ensure the namespace consists of valid characters only.\n        (asserts! (not (has-invalid-chars namespace)) ERR-CHARSET-INVALID)\n        ;; Check that the namespace is available for reveal.\n        (asserts! (unwrap! (can-namespace-be-registered namespace) ERR-NAMESPACE-ALREADY-EXISTS) ERR-NAMESPACE-ALREADY-EXISTS)\n        ;; Verify the burned amount during preorder meets or exceeds the namespace's registration price.\n        (asserts! (>= (get stx-burned preorder) namespace-price) ERR-STX-BURNT-INSUFFICIENT)\n        ;; Confirm the reveal action is performed within the allowed timeframe from the preorder.\n        (asserts! (< burn-block-height (+ (get created-at preorder) PREORDER-CLAIMABILITY-TTL)) ERR-PREORDER-CLAIMABILITY-EXPIRED)\n        ;; Ensure at least 1 block has passed after the preorder to avoid namespace sniping.\n        (asserts! (>= burn-block-height (+ (get created-at preorder) u1)) ERR-OPERATION-UNAUTHORIZED)\n        ;; Check if the namespace manager is assigned\n        (match namespace-manager \n            namespace-m\n            ;; If namespace-manager is assigned, then assign everything except the lifetime, that is set to u0 sinces renewals will be made in the namespace manager contract and set the can update price function to false, since no changes will ever need to be made there.\n            (map-set namespaces namespace\n                {\n                    namespace-manager: namespace-manager,\n                    manager-transferable: manager-transfers,\n                    manager-frozen: manager-frozen,\n                    namespace-import: namespace-import,\n                    revealed-at: burn-block-height,\n                    launched-at: none,\n                    lifetime: u0,\n                    can-update-price-function: can-update-price,\n                    price-function: price-function \n                }\n            )\n            ;; If no manager is assigned\n            (map-set namespaces namespace\n                {\n                    namespace-manager: none,\n                    manager-transferable: manager-transfers,\n                    manager-frozen: manager-frozen,\n                    namespace-import: namespace-import,\n                    revealed-at: burn-block-height,\n                    launched-at: none,\n                    lifetime: lifetime,\n                    can-update-price-function: can-update-price,\n                    price-function: price-function \n                }\n            )\n        )\n        ;; Update the claimed value for the preorder\n        (map-set namespace-preorders { hashed-salted-namespace: hashed-salted-namespace, buyer: contract-caller } \n            (merge preorder \n                {\n                    claimed: true\n                }\n            )\n        )   \n        ;; Confirm successful reveal of the namespace\n        (ok true)\n    )\n)\n\n;; @desc Public function `namespace-launch` marks a namespace as launched and available for public name registrations.\n;; @param: namespace (buff 20): The namespace to be launched and made available for public registrations.\n(define-public (namespace-launch (namespace (buff 20)))\n    (let \n        (\n            ;; Retrieve the properties of the namespace to ensure it exists and to check its current state.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Ensure the transaction sender is the namespace's designated import principal.\n        (asserts! (is-eq (get namespace-import namespace-props) contract-caller) ERR-OPERATION-UNAUTHORIZED)\n        ;; Verify the namespace has not already been launched.\n        (asserts! (is-none (get launched-at namespace-props)) ERR-NAMESPACE-ALREADY-LAUNCHED)\n        ;; Confirm that the action is taken within the permissible time frame since the namespace was revealed.\n        (asserts! (< burn-block-height (+ (get revealed-at namespace-props) NAMESPACE-LAUNCHABILITY-TTL)) ERR-NAMESPACE-PREORDER-LAUNCHABILITY-EXPIRED)\n        ;; Update the `namespaces` map with the newly launched status.\n        (map-set namespaces namespace (merge namespace-props { launched-at: (some burn-block-height) }))      \n        ;; Emit an event to indicate the namespace is now ready and launched.\n        (print { namespace: namespace, status: \"launch\", properties: (map-get? namespaces namespace) })\n        ;; Confirm the successful launch of the namespace.\n        (ok true)\n    )\n)\n\n;; @desc (new) Public function `turn-off-manager-transfers` disables manager transfers for a namespace (callable only once).\n;; @param: namespace (buff 20): The namespace for which manager transfers will be disabled.\n(define-public (turn-off-manager-transfers (namespace (buff 20)))\n    (let \n        (\n            ;; Retrieve the properties of the namespace and manager.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n            (namespace-manager (unwrap! (get namespace-manager namespace-props) ERR-NO-NAMESPACE-MANAGER))\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Ensure the function caller is the namespace manager.\n        (asserts! (is-eq contract-caller namespace-manager) ERR-NOT-AUTHORIZED)\n        ;; Disable manager transfers.\n        (map-set namespaces namespace (merge namespace-props {manager-transferable: false}))\n        (print { namespace: namespace, status: \"turn-off-manager-transfers\", properties: (map-get? namespaces namespace) })\n        ;; Confirm successful execution.\n        (ok true)\n    )\n)\n\n;; @desc Public function `name-import` allows the insertion of names into a namespace that has been revealed but not yet launched.\n;; This facilitates pre-populating the namespace with specific names, assigning owners.\n;; @param: namespace (buff 20): The namespace into which the name is being imported.\n;; @param: name (buff 48): The name being imported into the namespace.\n;; @param: beneficiary (principal): The principal who will own the imported name.\n;; @param: stx-burn (uint): The amount of STX tokens to be burned as part of the import process.\n(define-public (name-import (namespace (buff 20)) (name (buff 48)) (beneficiary principal))\n    (let \n        (\n            ;; Fetch properties of the specified namespace.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n            ;; Fetch the latest index to mint\n            (current-mint (+ (var-get bns-index) u1))\n            (price (if (is-none (get namespace-manager namespace-props))\n                        (try! (compute-name-price name (get price-function namespace-props)))\n                        u0\n                    )\n            )\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Ensure the name is not already registered.\n        (asserts! (is-none (map-get? name-properties {name: name, namespace: namespace})) ERR-NAME-NOT-AVAILABLE)\n        ;; Verify that the name contains only valid characters.\n        (asserts! (not (has-invalid-chars name)) ERR-CHARSET-INVALID)\n        ;; Ensure the contract-caller is the namespace's designated import principal or the namespace manager\n        (asserts! (or (is-eq (get namespace-import namespace-props) contract-caller) (is-eq (get namespace-manager namespace-props) (some contract-caller))) ERR-OPERATION-UNAUTHORIZED)\n        ;; Check that the namespace has not been launched yet, as names can only be imported to namespaces that are revealed but not launched.\n        (asserts! (is-none (get launched-at namespace-props)) ERR-NAMESPACE-ALREADY-LAUNCHED)\n        ;; Confirm that the import is occurring within the allowed timeframe since the namespace was revealed.\n        (asserts! (< burn-block-height (+ (get revealed-at namespace-props) NAMESPACE-LAUNCHABILITY-TTL)) ERR-NAMESPACE-PREORDER-LAUNCHABILITY-EXPIRED)\n        ;; Set the name properties\n        (map-set name-properties {name: name, namespace: namespace}\n            {\n                registered-at: none,\n                imported-at: (some burn-block-height),\n                hashed-salted-fqn-preorder: none,\n                preordered-by: none,\n                renewal-height: u0,\n                stx-burn: price,\n                owner: beneficiary,\n            }\n        )\n        (map-set name-to-index {name: name, namespace: namespace} current-mint)\n        (map-set index-to-name current-mint {name: name, namespace: namespace})\n        ;; Update primary name if needed for send-to\n        (update-primary-name-recipient current-mint beneficiary)\n        ;; Update the index of the minting\n        (var-set bns-index current-mint)\n        ;; Mint the name to the beneficiary\n        (try! (nft-mint? BNS-V2 current-mint beneficiary))\n        ;; Log the new name registration\n        (print \n            {\n                topic: \"new-name\",\n                owner: beneficiary,\n                name: {name: name, namespace: namespace},\n                id: current-mint,\n                properties: (map-get? name-properties {name: name, namespace: namespace})\n            }\n        )\n        ;; Confirm successful import of the name.\n        (ok true)\n    )\n)\n\n;; @desc Public function `namespace-update-price` updates the pricing function for a specific namespace.\n;; @param: namespace (buff 20): The namespace for which the price function is being updated.\n;; @param: p-func-base (uint): The base price used in the pricing function.\n;; @param: p-func-coeff (uint): The coefficient used in the pricing function.\n;; @param: p-func-b1 to p-func-b16 (uint): The bucket-specific multipliers for the pricing function.\n;; @param: p-func-non-alpha-discount (uint): The discount applied for non-alphabetic characters.\n;; @param: p-func-no-vowel-discount (uint): The discount applied when no vowels are present.\n(define-public (namespace-update-price \n    (namespace (buff 20)) \n    (p-func-base uint) \n    (p-func-coeff uint) \n    (p-func-b1 uint) \n    (p-func-b2 uint) \n    (p-func-b3 uint) \n    (p-func-b4 uint) \n    (p-func-b5 uint) \n    (p-func-b6 uint) \n    (p-func-b7 uint) \n    (p-func-b8 uint) \n    (p-func-b9 uint) \n    (p-func-b10 uint) \n    (p-func-b11 uint) \n    (p-func-b12 uint) \n    (p-func-b13 uint) \n    (p-func-b14 uint) \n    (p-func-b15 uint) \n    (p-func-b16 uint) \n    (p-func-non-alpha-discount uint) \n    (p-func-no-vowel-discount uint)\n)\n    (let \n        (\n            ;; Retrieve the current properties of the namespace.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n            ;; Construct the new price function.\n            (price-function \n                {\n                    buckets: (list p-func-b1 p-func-b2 p-func-b3 p-func-b4 p-func-b5 p-func-b6 p-func-b7 p-func-b8 p-func-b9 p-func-b10 p-func-b11 p-func-b12 p-func-b13 p-func-b14 p-func-b15 p-func-b16),\n                    base: p-func-base,\n                    coeff: p-func-coeff,\n                    nonalpha-discount: p-func-non-alpha-discount,\n                    no-vowel-discount: p-func-no-vowel-discount\n                }\n            )\n        )\n        (match (get namespace-manager namespace-props) \n            manager\n            ;; Ensure that the transaction sender is the namespace's designated import principal.\n            (asserts! (is-eq manager contract-caller) ERR-OPERATION-UNAUTHORIZED)\n            ;; Ensure that the contract-caller is the namespace's designated import principal.\n            (asserts! (is-eq (get namespace-import namespace-props) contract-caller) ERR-OPERATION-UNAUTHORIZED)\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Verify the namespace's price function can still be updated.\n        (asserts! (get can-update-price-function namespace-props) ERR-OPERATION-UNAUTHORIZED)\n        ;; Update the namespace's record in the `namespaces` map with the new price function.\n        (map-set namespaces namespace (merge namespace-props { price-function: price-function }))\n        (print { namespace: namespace, status: \"update-price-manager\", properties: (map-get? namespaces namespace) })\n        ;; Confirm the successful update of the price function.\n        (ok true)\n    )\n)\n\n;; @desc Public function `namespace-freeze-price` disables the ability to update the price function for a given namespace.\n;; @param: namespace (buff 20): The target namespace for which the price function update capability is being revoked.\n(define-public (namespace-freeze-price (namespace (buff 20)))\n    (let \n        (\n            ;; Retrieve the properties of the specified namespace to verify its existence and fetch its current settings.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n        )\n        (match (get namespace-manager namespace-props) \n            manager \n            ;; Ensure that the transaction sender is the same as the namespace's designated import principal.\n            (asserts! (is-eq manager contract-caller) ERR-OPERATION-UNAUTHORIZED)\n            ;; Ensure that the contract-caller is the same as the namespace's designated import principal.\n            (asserts! (is-eq (get namespace-import namespace-props) contract-caller) ERR-OPERATION-UNAUTHORIZED)\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Update the namespace properties in the `namespaces` map, setting `can-update-price-function` to false.\n        (map-set namespaces namespace \n            (merge namespace-props { can-update-price-function: false })\n        )\n        (print { namespace: namespace, status: \"freeze-price-manager\", properties: (map-get? namespaces namespace) })\n        ;; Return a success confirmation.\n        (ok true)\n    )\n)\n\n;; @desc (new) A 'fast' one-block registration function: (name-claim-fast)\n;; Warning: this *is* snipeable, for a slower but un-snipeable claim, use the pre-order & register functions\n;; @param: name (buff 48): The name being claimed.\n;; @param: namespace (buff 20): The namespace under which the name is being claimed.\n;; @param: stx-burn (uint): The amount of STX to burn for the claim.\n;; @param: send-to (principal): The principal to whom the name will be sent.\n(define-public (name-claim-fast (name (buff 48)) (namespace (buff 20)) (send-to principal)) \n    (let \n        (\n            ;; Retrieve namespace properties.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n            (current-namespace-manager (get namespace-manager namespace-props))\n            ;; Calculates the ID for the new name to be minted.\n            (id-to-be-minted (+ (var-get bns-index) u1))\n            ;; Check if the name already exists.\n            (name-props (map-get? name-properties {name: name, namespace: namespace}))\n            ;; new to get the price of the name\n            (name-price (if (is-none current-namespace-manager)\n                            (try! (compute-name-price name (get price-function namespace-props)))\n                            u0\n                        )\n            )\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Ensure the name is not already registered.\n        (asserts! (is-none name-props) ERR-NAME-NOT-AVAILABLE)\n        ;; Verify that the name contains only valid characters.\n        (asserts! (not (has-invalid-chars name)) ERR-CHARSET-INVALID)\n        ;; Ensure that the namespace is launched\n        (asserts! (is-some (get launched-at namespace-props)) ERR-NAMESPACE-NOT-LAUNCHED)\n        ;; Check namespace manager\n        (match current-namespace-manager \n            manager \n            ;; If manager, check contract-caller is manager\n            (asserts! (is-eq contract-caller manager) ERR-NOT-AUTHORIZED)\n            ;; If no manager\n            (begin \n                ;; Asserts contract-caller is the send-to if not a managed namespace\n                (asserts! (is-eq contract-caller send-to) ERR-NOT-AUTHORIZED)\n                ;; Updated this to burn the actual ammount of the name-price\n                (try! (stx-burn? name-price send-to))\n            )\n        )\n        ;; Update the index\n        (var-set bns-index id-to-be-minted)\n        ;; Sets properties for the newly registered name.\n        (map-set name-properties\n            {\n                name: name, namespace: namespace\n            } \n            {\n                registered-at: (some (+ burn-block-height u1)),\n                imported-at: none,\n                hashed-salted-fqn-preorder: none,\n                preordered-by: none,\n                ;; Updated this to actually start with the registered-at date/block, and also to be u0 if it is a managed namespace\n                renewal-height: (if (is-eq (get lifetime namespace-props) u0)\n                                    u0\n                                    (+ (get lifetime namespace-props) burn-block-height u1)\n                                ),\n                stx-burn: name-price,\n                owner: send-to,\n            }\n        )\n        (map-set name-to-index {name: name, namespace: namespace} id-to-be-minted) \n        (map-set index-to-name id-to-be-minted {name: name, namespace: namespace}) \n        ;; Update primary name if needed for send-to\n        (update-primary-name-recipient id-to-be-minted send-to)\n        ;; Mints the new BNS name.\n        (try! (nft-mint? BNS-V2 id-to-be-minted send-to))\n        ;; Log the new name registration\n        (print \n            {\n                topic: \"new-name\",\n                owner: send-to,\n                name: {name: name, namespace: namespace},\n                id: id-to-be-minted,\n                properties: (map-get? name-properties {name: name, namespace: namespace})\n            }\n        )\n        ;; Signals successful completion.\n        (ok id-to-be-minted)\n    )\n)\n\n;; @desc Defines a public function `name-preorder` for preordering BNS names by burning the registration fee and submitting the salted hash.\n;; Callable by anyone; the actual check for authorization happens in the `name-register` function.\n;; @param: hashed-salted-fqn (buff 20): The hashed and salted fully qualified name.\n;; @param: stx-to-burn (uint): The amount of STX to burn for the preorder.\n(define-public (name-preorder (hashed-salted-fqn (buff 20)) (stx-to-burn uint))\n    (begin\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS) \n        ;; Validate the length of the hashed-salted FQN.\n        (asserts! (is-eq (len hashed-salted-fqn) HASH160LEN) ERR-HASH-MALFORMED)\n        ;; Ensures that the amount of STX specified to burn is greater than zero.\n        (asserts! (> stx-to-burn u0) ERR-STX-BURNT-INSUFFICIENT)\n        ;; Check if the same hashed-salted-fqn has been used before\n        (asserts! (is-none (map-get? name-single-preorder hashed-salted-fqn)) ERR-PREORDERED-BEFORE)\n        ;; Transfers the specified amount of stx to the BNS contract to burn on register\n        (try! (stx-transfer? stx-to-burn contract-caller .BNS-V2))\n        ;; Records the preorder in the 'name-preorders' map.\n        (map-set name-preorders\n            { hashed-salted-fqn: hashed-salted-fqn, buyer: contract-caller }\n            { created-at: burn-block-height, stx-burned: stx-to-burn, claimed: false}\n        )\n        ;; Sets the map with just the hashed-salted-fqn as the key\n        (map-set name-single-preorder hashed-salted-fqn true)\n        ;; Returns the block height at which the preorder's claimability period will expire.\n        (ok (+ burn-block-height PREORDER-CLAIMABILITY-TTL))\n    )\n)\n\n;; @desc Public function `name-register` finalizes the registration of a BNS name for users from unmanaged namespaces.\n;; @param: namespace (buff 20): The namespace to which the name belongs.\n;; @param: name (buff 48): The name to be registered.\n;; @param: salt (buff 20): The salt used during the preorder.\n(define-public (name-register (namespace (buff 20)) (name (buff 48)) (salt (buff 20)))\n    (let \n        (\n            ;; Generate a unique identifier for the name by hashing the fully-qualified name with salt\n            (hashed-salted-fqn (hash160 (concat (concat (concat name 0x2e) namespace) salt)))\n            ;; Retrieve the preorder details for this name\n            (preorder (unwrap! (map-get? name-preorders { hashed-salted-fqn: hashed-salted-fqn, buyer: contract-caller }) ERR-PREORDER-NOT-FOUND))\n            ;; Fetch the properties of the namespace\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n            ;; Get the amount of burned STX\n            (stx-burned (get stx-burned preorder))\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Ensure that the namespace is launched\n        (asserts! (is-some (get launched-at namespace-props)) ERR-NAMESPACE-NOT-LAUNCHED)\n        ;; Ensure the preorder hasn't been claimed before\n        (asserts! (not (get claimed preorder)) ERR-OPERATION-UNAUTHORIZED)\n        ;; Check that the namespace doesn't have a manager (implying it's open for registration)\n        (asserts! (is-none (get namespace-manager namespace-props)) ERR-NOT-AUTHORIZED)\n        ;; Verify that the preorder was made after the namespace was launched\n        (asserts! (> (get created-at preorder) (unwrap! (get launched-at namespace-props) ERR-UNWRAP)) ERR-NAME-PREORDERED-BEFORE-NAMESPACE-LAUNCH)\n        ;; Ensure the registration is happening within the allowed time window after preorder\n        (asserts! (< burn-block-height (+ (get created-at preorder) PREORDER-CLAIMABILITY-TTL)) ERR-PREORDER-CLAIMABILITY-EXPIRED)\n        ;; Make sure at least one block has passed since the preorder (prevents front-running)\n        (asserts! (> burn-block-height (+ (get created-at preorder) u1)) ERR-NAME-NOT-CLAIMABLE-YET)\n        ;; Verify that enough STX was burned during preorder to cover the name price\n        (asserts! (is-eq stx-burned (try! (compute-name-price name (get price-function namespace-props)))) ERR-STX-BURNT-INSUFFICIENT)\n        ;; Verify that the name contains only valid characters.\n        (asserts! (not (has-invalid-chars name)) ERR-CHARSET-INVALID)\n        ;; Mark the preorder as claimed to prevent double-spending\n        (map-set name-preorders { hashed-salted-fqn: hashed-salted-fqn, buyer: contract-caller } (merge preorder {claimed: true}))\n        ;; Check if the name already exists\n        (match (map-get? name-properties {name: name, namespace: namespace})\n            name-props-exist\n            ;; If the name exists \n            (handle-existing-name name-props-exist hashed-salted-fqn (get created-at preorder) stx-burned name namespace (get lifetime namespace-props))\n            ;; If the name does not exist\n            (register-new-name (+ (var-get bns-index) u1) hashed-salted-fqn stx-burned name namespace (get lifetime namespace-props))    \n        )\n    )\n)\n\n;; @desc (new) Defines a public function `claim-preorder` for claiming back the STX commited to be burnt on registration.\n;; This should only be allowed to go through if preorder-claimability-ttl has passed\n;; @param: hashed-salted-fqn (buff 20): The hashed and salted fully qualified name.\n(define-public (claim-preorder (hashed-salted-fqn (buff 20)))\n    (let\n        (\n            ;; Retrieves the preorder details.\n            (preorder (unwrap! (map-get? name-preorders { hashed-salted-fqn: hashed-salted-fqn, buyer: contract-caller }) ERR-PREORDER-NOT-FOUND))\n            (claimer contract-caller)\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS) \n        ;; Check if the preorder-claimability-ttl has passed\n        (asserts! (> burn-block-height (+ (get created-at preorder) PREORDER-CLAIMABILITY-TTL)) ERR-OPERATION-UNAUTHORIZED)\n        ;; Asserts that the preorder has not been claimed\n        (asserts! (not (get claimed preorder)) ERR-OPERATION-UNAUTHORIZED)\n        ;; Transfers back the specified amount of stx from the BNS contract to the contract-caller\n        (try! (as-contract (stx-transfer? (get stx-burned preorder) .BNS-V2 claimer)))\n        ;; Deletes the preorder in the 'name-preorders' map.\n        (map-delete name-preorders { hashed-salted-fqn: hashed-salted-fqn, buyer: contract-caller })\n        ;; Remove the entry from the name-single-preorder map\n        (map-delete name-single-preorder hashed-salted-fqn)\n        ;; Returns ok true\n        (ok true)\n    )\n)\n\n;; @desc (new) This function is similar to `name-preorder` but only for namespace managers, without the burning of STX tokens.\n;; Intended only for managers as mng-name-register & name-register will validate.\n;; @param: hashed-salted-fqn (buff 20): The hashed and salted fully-qualified name (FQN) being preordered.\n(define-public (mng-name-preorder (hashed-salted-fqn (buff 20)))\n    (begin\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Validates that the length of the hashed and salted FQN is exactly 20 bytes.\n        (asserts! (is-eq (len hashed-salted-fqn) HASH160LEN) ERR-HASH-MALFORMED)\n        ;; Check if the same hashed-salted-fqn has been used before\n        (asserts! (is-none (map-get? name-single-preorder hashed-salted-fqn)) ERR-PREORDERED-BEFORE)\n        ;; Records the preorder in the 'name-preorders' map. Buyer set to contract-caller\n        (map-set name-preorders\n            { hashed-salted-fqn: hashed-salted-fqn, buyer: contract-caller }\n            { created-at: burn-block-height, stx-burned: u0, claimed: false }\n        )\n        ;; Sets the map with just the hashed-salted-fqn as the key\n        (map-set name-single-preorder hashed-salted-fqn true)\n        ;; Returns the block height at which the preorder's claimability period will expire.\n        (ok (+ burn-block-height PREORDER-CLAIMABILITY-TTL))\n    )\n)\n\n;; @desc (new) This function uses provided details to verify the preorder, register the name, and assign it initial properties.\n;; This should only allow Managers from MANAGED namespaces to register names.\n;; @param: namespace (buff 20): The namespace for the name.\n;; @param: name (buff 48): The name being registered.\n;; @param: salt (buff 20): The salt used in hashing.\n;; @param: send-to (principal): The principal to whom the name will be registered.\n(define-public (mng-name-register (namespace (buff 20)) (name (buff 48)) (salt (buff 20)) (send-to principal))\n    (let \n        (\n            ;; Generates the hashed, salted fully-qualified name.\n            (hashed-salted-fqn (hash160 (concat (concat (concat name 0x2e) namespace) salt)))\n            ;; Retrieves the existing properties of the namespace to confirm its existence and management details.\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n            (current-namespace-manager (unwrap! (get namespace-manager namespace-props) ERR-NO-NAMESPACE-MANAGER))\n            ;; Retrieves the preorder information using the hashed-salted FQN to verify the preorder exists\n            (preorder (unwrap! (map-get? name-preorders { hashed-salted-fqn: hashed-salted-fqn, buyer: current-namespace-manager }) ERR-PREORDER-NOT-FOUND))\n            ;; Calculates the ID for the new name to be minted.\n            (id-to-be-minted (+ (var-get bns-index) u1))\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Ensure the preorder has not been claimed before\n        (asserts! (not (get claimed preorder)) ERR-OPERATION-UNAUTHORIZED)\n        ;; Ensure the name is not already registered\n        (asserts! (is-none (map-get? name-properties {name: name, namespace: namespace})) ERR-NAME-NOT-AVAILABLE)\n        ;; Verify that the name contains only valid characters.\n        (asserts! (not (has-invalid-chars name)) ERR-CHARSET-INVALID)\n        ;; Verifies that the caller is the namespace manager.\n        (asserts! (is-eq contract-caller current-namespace-manager) ERR-NOT-AUTHORIZED)\n        ;; Validates that the preorder was made after the namespace was officially launched.\n        (asserts! (> (get created-at preorder) (unwrap! (get launched-at namespace-props) ERR-UNWRAP)) ERR-NAME-PREORDERED-BEFORE-NAMESPACE-LAUNCH)\n        ;; Verifies the registration is completed within the claimability period.\n        (asserts! (< burn-block-height (+ (get created-at preorder) PREORDER-CLAIMABILITY-TTL)) ERR-PREORDER-CLAIMABILITY-EXPIRED)\n        ;; Sets properties for the newly registered name.\n        (map-set name-properties\n            {\n                name: name, namespace: namespace\n            } \n            {\n                registered-at: (some burn-block-height),\n                imported-at: none,\n                hashed-salted-fqn-preorder: (some hashed-salted-fqn),\n                preordered-by: (some send-to),\n                ;; Updated this to be u0, so that renewals are handled through the namespace manager \n                renewal-height: u0,\n                stx-burn: u0,\n                owner: send-to,\n            }\n        )\n        (map-set name-to-index {name: name, namespace: namespace} id-to-be-minted)\n        (map-set index-to-name id-to-be-minted {name: name, namespace: namespace})\n        ;; Update primary name if needed for send-to\n        (update-primary-name-recipient id-to-be-minted send-to)\n        ;; Updates BNS-index variable to the newly minted ID.\n        (var-set bns-index id-to-be-minted)\n        ;; Update map to claimed for preorder, to avoid people reclaiming stx from an already registered name\n        (map-set name-preorders { hashed-salted-fqn: hashed-salted-fqn, buyer: current-namespace-manager } (merge preorder {claimed: true}))\n        ;; Mints the BNS name as an NFT to the send-to address, finalizing the registration.\n        (try! (nft-mint? BNS-V2 id-to-be-minted send-to))\n        ;; Log the new name registration\n        (print \n            {\n                topic: \"new-name\",\n                owner: send-to,\n                name: {name: name, namespace: namespace},\n                id: id-to-be-minted,\n                properties: (map-get? name-properties {name: name, namespace: namespace})\n            }\n        )\n        ;; Confirms successful registration of the name.\n        (ok id-to-be-minted)\n    )\n)\n\n;; Public function `name-renewal` for renewing ownership of a name.\n;; @param: namespace (buff 20): The namespace of the name to be renewed.\n;; @param: name (buff 48): The actual name to be renewed.\n;; @param: stx-to-burn (uint): The amount of STX tokens to be burned for renewal.\n(define-public (name-renewal (namespace (buff 20)) (name (buff 48)))\n    (let \n        (\n            ;; Get the unique identifier for this name\n            (name-index (unwrap! (get-id-from-bns name namespace) ERR-NO-NAME))\n            ;; Retrieve the properties of the namespace\n            (namespace-props (unwrap! (map-get? namespaces namespace) ERR-NAMESPACE-NOT-FOUND))\n            ;; Get the manager of the namespace, if any\n            (namespace-manager (get namespace-manager namespace-props))\n            ;; Get the current owner of the name\n            (owner (unwrap! (nft-get-owner? BNS-V2 name-index) ERR-NO-NAME))\n            ;; Retrieve the properties of the name\n            (name-props (unwrap! (map-get? name-properties { name: name, namespace: namespace }) ERR-NO-NAME))\n            ;; Get the lifetime of names in this namespace\n            (lifetime (get lifetime namespace-props))\n            ;; Get the current renewal height of the name\n            (renewal-height (try! (get-renewal-height name-index)))\n            ;; Calculate the new renewal height based on current block height\n            (new-renewal-height (+ burn-block-height lifetime))\n        )\n        ;; Check if migration is complete\n        (asserts! (var-get migration-complete) ERR-MIGRATION-IN-PROGRESS)\n        ;; Verify that the namespace has been launched\n        (asserts! (is-some (get launched-at namespace-props)) ERR-NAMESPACE-NOT-LAUNCHED)\n        ;; Ensure the namespace doesn't have a manager\n        (asserts! (is-none namespace-manager) ERR-NAMESPACE-HAS-MANAGER)\n        ;; Check if renewals are required for this namespace\n        (asserts! (> lifetime u0) ERR-LIFETIME-EQUAL-0)\n        ;; Handle renewal based on whether it's within the grace period or not\n        (if (< burn-block-height (+ renewal-height NAME-GRACE-PERIOD-DURATION))   \n            (try! (handle-renewal-in-grace-period name namespace name-props owner lifetime new-renewal-height))\n            (try! (handle-renewal-after-grace-period name namespace name-props owner name-index new-renewal-height))\n        )\n        ;; Burn the specified amount of STX\n        (try! (stx-burn? (try! (compute-name-price name (get price-function namespace-props))) contract-caller))\n        ;; update the new stx-burn to the one paid in renewal\n        (map-set name-properties { name: name, namespace: namespace } (merge (unwrap-panic (map-get? name-properties { name: name, namespace: namespace })) {stx-burn: (try! (compute-name-price name (get price-function namespace-props)))}))\n        ;; Return success\n        (ok true)\n    )\n)\n\n;; Private function to handle renewals within the grace period\n(define-private (handle-renewal-in-grace-period \n    (name (buff 48)) \n    (namespace (buff 20)) \n    (name-props \n        {\n            registered-at: (optional uint), \n            imported-at: (optional uint), \n            hashed-salted-fqn-preorder: (optional (buff 20)), \n            preordered-by: (optional principal), \n            renewal-height: uint, \n            stx-burn: uint, \n            owner: principal\n        }\n    ) \n    (owner principal) \n    (lifetime uint) \n    (new-renewal-height uint)\n)\n    (begin\n        ;; Ensure only the owner can renew within the grace period\n        (asserts! (is-eq contract-caller owner) ERR-NOT-AUTHORIZED)\n        ;; Update the name properties with the new renewal height\n        (map-set name-properties {name: name, namespace: namespace} \n            (merge name-props \n                {\n                    renewal-height: \n                        ;; If still within lifetime, extend from current renewal height; otherwise, use new renewal height\n                        (if (< burn-block-height (unwrap-panic (get-renewal-height (unwrap-panic (get-id-from-bns name namespace)))))\n                            (+ (unwrap-panic (get-renewal-height (unwrap-panic (get-id-from-bns name namespace)))) lifetime)\n                            new-renewal-height\n                        )\n                }\n            )\n        )\n        (print \n            {\n                topic: \"renew-name\", \n                owner: owner, \n                name: {name: name, namespace: namespace}, \n                id: (get-id-from-bns name namespace),\n                properties: (map-get? name-properties {name: name, namespace: namespace})\n            }\n        )\n        (ok true)\n    )\n)\n\n;; Private function to handle renewals after the grace period\n(define-private (handle-renewal-after-grace-period \n    (name (buff 48)) \n    (namespace (buff 20)) \n    (name-props \n        {\n            registered-at: (optional uint), \n            imported-at: (optional uint), \n            hashed-salted-fqn-preorder: (optional (buff 20)), \n            preordered-by: (optional principal), \n            renewal-height: uint, \n            stx-burn: uint, \n            owner: principal\n        }\n    ) \n    (owner principal) \n    (name-index uint) \n    (new-renewal-height uint)\n)\n    (if (is-eq contract-caller owner)\n        ;; If the owner is renewing, simply update the renewal height\n        (ok \n            (map-set name-properties {name: name, namespace: namespace}\n                (merge name-props {renewal-height: new-renewal-height})\n            )\n        )\n        ;; If someone else is renewing (taking over the name)\n        (begin \n            ;; Check if the name is listed on the market and remove the listing if it is\n            (match (map-get? market name-index)\n                listed-name \n                (map-delete market name-index) \n                true\n            )\n            (map-set name-properties {name: name, namespace: namespace}\n                    (merge name-props {renewal-height: new-renewal-height})\n            )\n            ;; Update the name properties with the new renewal height and owner\n            (ok (try! (purchase-transfer name-index owner contract-caller)))\n        )\n    )  \n)\n\n;; Returns the minimum of two uint values.\n(define-private (min (a uint) (b uint))\n    ;; If 'a' is less than or equal to 'b', return 'a', else return 'b'.\n    (if (<= a b) a b)  \n)\n\n;; Returns the maximum of two uint values.\n(define-private (max (a uint) (b uint))\n    ;; If 'a' is greater than 'b', return 'a', else return 'b'.\n    (if (> a b) a b)  \n)\n\n;; Retrieves an exponent value from a list of buckets based on the provided index.\n(define-private (get-exp-at-index (buckets (list 16 uint)) (index uint))\n    ;; Retrieves the element at the specified index.\n    (unwrap-panic (element-at? buckets index))  \n)\n\n;; Determines if a character is a digit (0-9).\n(define-private (is-digit (char (buff 1)))\n    (or \n        ;; Checks if the character is between '0' and '9' using hex values.\n        (is-eq char 0x30) ;; 0\n        (is-eq char 0x31) ;; 1\n        (is-eq char 0x32) ;; 2\n        (is-eq char 0x33) ;; 3\n        (is-eq char 0x34) ;; 4\n        (is-eq char 0x35) ;; 5\n        (is-eq char 0x36) ;; 6\n        (is-eq char 0x37) ;; 7\n        (is-eq char 0x38) ;; 8\n        (is-eq char 0x39) ;; 9\n    )\n) \n\n;; Checks if a character is a lowercase alphabetic character (a-z).\n(define-private (is-lowercase-alpha (char (buff 1)))\n    (or \n        ;; Checks for each lowercase letter using hex values.\n        (is-eq char 0x61) ;; a\n        (is-eq char 0x62) ;; b\n        (is-eq char 0x63) ;; c\n        (is-eq char 0x64) ;; d\n        (is-eq char 0x65) ;; e\n        (is-eq char 0x66) ;; f\n        (is-eq char 0x67) ;; g\n        (is-eq char 0x68) ;; h\n        (is-eq char 0x69) ;; i\n        (is-eq char 0x6a) ;; j\n        (is-eq char 0x6b) ;; k\n        (is-eq char 0x6c) ;; l\n        (is-eq char 0x6d) ;; m\n        (is-eq char 0x6e) ;; n\n        (is-eq char 0x6f) ;; o\n        (is-eq char 0x70) ;; p\n        (is-eq char 0x71) ;; q\n        (is-eq char 0x72) ;; r\n        (is-eq char 0x73) ;; s\n        (is-eq char 0x74) ;; t\n        (is-eq char 0x75) ;; u\n        (is-eq char 0x76) ;; v\n        (is-eq char 0x77) ;; w\n        (is-eq char 0x78) ;; x\n        (is-eq char 0x79) ;; y\n        (is-eq char 0x7a) ;; z\n    )\n) \n\n;; Determines if a character is a vowel (a, e, i, o, u, and y).\n(define-private (is-vowel (char (buff 1)))\n    (or \n        (is-eq char 0x61) ;; a\n        (is-eq char 0x65) ;; e\n        (is-eq char 0x69) ;; i\n        (is-eq char 0x6f) ;; o\n        (is-eq char 0x75) ;; u\n        (is-eq char 0x79) ;; y\n    )\n)\n\n;; Identifies if a character is a special character, specifically '-' or '_'.\n(define-private (is-special-char (char (buff 1)))\n    (or \n        (is-eq char 0x2d) ;; -\n        (is-eq char 0x5f)) ;; _\n) \n\n;; Determines if a character is valid within a name, based on allowed character sets.\n(define-private (is-char-valid (char (buff 1)))\n    (or (is-lowercase-alpha char) (is-digit char) (is-special-char char))\n)\n\n;; Checks if a character is non-alphabetic, either a digit or a special character.\n(define-private (is-nonalpha (char (buff 1)))\n    (or (is-digit char) (is-special-char char))\n)\n\n;; Evaluates if a name contains any vowel characters.\n(define-private (has-vowels-chars (name (buff 48)))\n    (> (len (filter is-vowel name)) u0)\n)\n\n;; Determines if a name contains non-alphabetic characters.\n(define-private (has-nonalpha-chars (name (buff 48)))\n    (> (len (filter is-nonalpha name)) u0)\n)\n\n;; Identifies if a name contains any characters that are not considered valid.\n(define-private (has-invalid-chars (name (buff 48)))\n    (< (len (filter is-char-valid name)) (len name))\n)\n\n;; Private helper function `is-namespace-available` checks if a namespace is available for registration or other operations.\n;; It considers if the namespace has been launched and whether it has expired.\n;; @params:\n    ;; namespace (buff 20): The namespace to check for availability.\n(define-private (is-namespace-available (namespace (buff 20)))\n    ;; Check if the namespace exists\n    (match (map-get? namespaces namespace) \n        namespace-props\n        ;; If it exists\n        ;; Check if the namespace has been launched.\n        (match (get launched-at namespace-props) \n            launched\n            ;; If the namespace is launched, it's considered unavailable if it hasn't expired.\n            false\n            ;; Check if the namespace is expired by comparing the current block height to the reveal time plus the launchability TTL.\n            (> burn-block-height (+ (get revealed-at namespace-props) NAMESPACE-LAUNCHABILITY-TTL))\n        )\n        ;; If the namespace doesn't exist in the map, it's considered available.\n        true\n    )\n)\n\n;; Private helper function `compute-name-price` calculates the registration price for a name based on its length and character composition.\n;; It utilizes a configurable pricing function that can adjust prices based on the name's characteristics.\n;; @params:\n;;     name (buff 48): The name for which the price is being calculated.\n;;     price-function (tuple): A tuple containing the parameters of the pricing function, including:\n;;         buckets (list 16 uint): A list defining price multipliers for different name lengths.\n;;         base (uint): The base price multiplier.\n;;         coeff (uint): A coefficient that adjusts the base price.\n;;         nonalpha-discount (uint): A discount applied to names containing non-alphabetic characters.\n;;         no-vowel-discount (uint): A discount applied to names lacking vowel characters.\n(define-private (compute-name-price (name (buff 48)) (price-function {buckets: (list 16 uint), base: uint, coeff: uint, nonalpha-discount: uint, no-vowel-discount: uint}))\n    (let \n        (\n            ;; Determine the appropriate exponent based on the name's length.\n            ;; This corresponds to a specific bucket in the pricing function.\n            ;; The length of the name is used to index into the buckets list, with a maximum index of 15.\n            (exponent (get-exp-at-index (get buckets price-function) (min u15 (- (len name) u1)))) \n            ;; Calculate the no-vowel discount.\n            ;; If the name has no vowels, apply the no-vowel discount from the price function.\n            ;; Otherwise, use 1 indicating no discount.\n            (no-vowel-discount (if (not (has-vowels-chars name)) (get no-vowel-discount price-function) u1))\n            ;; Calculate the non-alphabetic character discount.\n            ;; If the name contains non-alphabetic characters, apply the non-alpha discount from the price function.\n            ;; Otherwise, use 1 indicating no discount.\n            (nonalpha-discount (if (has-nonalpha-chars name) (get nonalpha-discount price-function) u1))\n            (len-name (len name))\n        )\n        (asserts! (> len-name u0) ERR-NAME-BLANK)\n        ;; Compute the final price.\n        ;; The base price, adjusted by the coefficient and exponent, is divided by the greater of the two discounts (non-alpha or no-vowel).\n        ;; The result is then multiplied by 10 to adjust for unit precision.\n        (ok (* (/ (* (get coeff price-function) (pow (get base price-function) exponent)) (max nonalpha-discount no-vowel-discount)) u10))\n    )\n)\n\n;; This function is similar to the 'transfer' function but does not check that the owner is the contract-caller.\n;; @param id: the id of the nft being transferred.\n;; @param owner: the principal of the current owner of the nft being transferred.\n;; @param recipient: the principal of the recipient to whom the nft is being transferred.\n(define-private (purchase-transfer (id uint) (owner principal) (recipient principal))\n    (let \n        (\n            ;; Attempts to retrieve the name and namespace associated with the given NFT ID.\n            (name-and-namespace (unwrap! (map-get? index-to-name id) ERR-NO-NAME))\n            ;; Retrieves the properties of the name within the namespace.\n            (name-props (unwrap! (map-get? name-properties name-and-namespace) ERR-NO-NAME))\n        )\n        ;; Check owner and recipient is not the same\n        (asserts! (not (is-eq owner recipient)) ERR-OPERATION-UNAUTHORIZED)\n        (asserts! (is-eq owner (get owner name-props)) ERR-NOT-AUTHORIZED)\n        ;; Update primary name if needed for owner\n        (update-primary-name-owner id owner)\n        ;; Update primary name if needed for recipient\n        (update-primary-name-recipient id recipient)\n        ;; Updates the owner to the recipient.\n        (map-set name-properties name-and-namespace (merge name-props {owner: recipient}))\n        ;; Executes the NFT transfer from the current owner to the recipient.\n        (try! (nft-transfer? BNS-V2 id owner recipient))\n        (print \n            {\n                topic: \"transfer-name\", \n                owner: recipient, \n                name: {name: (get name name-and-namespace), namespace: (get namespace name-and-namespace)}, \n                id: id,\n                properties: (map-get? name-properties {name: (get name name-and-namespace), namespace: (get namespace name-and-namespace)})\n            }\n        )\n        (ok true)\n    )\n)\n\n;; Private function to update the primary name of an address when transfering a name\n;; If the id is = to the primary name then it means that a transfer is happening and we should delete it\n(define-private (update-primary-name-owner (id uint) (owner principal)) \n    ;; Check if the owner is transferring the primary name\n    (if (is-eq (map-get? primary-name owner) (some id)) \n        ;; If it is, then delete the primary name map\n        (map-delete primary-name owner)\n        ;; If it is not, do nothing, keep the current primary name\n        false\n    )\n)\n\n;; Private function to update the primary name of an address when recieving\n(define-private (update-primary-name-recipient (id uint) (recipient principal)) \n    ;; Check if recipient has a primary name\n    (match (map-get? primary-name recipient)\n        recipient-primary-name\n        ;; If recipient has a primary name do nothing\n        true\n        ;; If recipient doesn't have a primary name\n        (map-set primary-name recipient id)\n    )\n)\n\n(define-private (handle-existing-name \n    (name-props \n        {\n            registered-at: (optional uint), \n            imported-at: (optional uint), \n            hashed-salted-fqn-preorder: (optional (buff 20)), \n            preordered-by: (optional principal), \n            renewal-height: uint, \n            stx-burn: uint, \n            owner: principal\n        }\n    ) \n    (hashed-salted-fqn (buff 20)) \n    (contract-caller-preorder-height uint) \n    (stx-burned uint) (name (buff 48)) \n    (namespace (buff 20)) \n    (renewal uint)\n)\n    (let \n        (\n            ;; Retrieve the index of the existing name\n            (name-index (unwrap-panic (map-get? name-to-index {name: name, namespace: namespace})))\n        )\n        ;; Straight up check if the name was imported\n        (asserts! (is-none (get imported-at name-props)) ERR-IMPORTED-BEFORE)\n        ;; If the check passes then it is registered, we can straight up check the hashed-salted-fqn-preorder\n        (match (get hashed-salted-fqn-preorder name-props)\n            fqn \n            ;; Compare both preorder's height\n            (asserts! (> (unwrap-panic (get created-at (map-get? name-preorders {hashed-salted-fqn: fqn, buyer: (unwrap-panic (get preordered-by name-props))}))) contract-caller-preorder-height) ERR-PREORDERED-BEFORE)\n            ;; Compare registered with preorder height\n            (asserts! (> (unwrap-panic (get registered-at name-props)) contract-caller-preorder-height) ERR-FAST-MINTED-BEFORE)\n        )\n        ;; Update the name properties with the new preorder information since it is the best preorder\n        (map-set name-properties {name: name, namespace: namespace} \n            (merge name-props \n                {\n                    hashed-salted-fqn-preorder: (some hashed-salted-fqn), \n                    preordered-by: (some contract-caller), \n                    registered-at: (some burn-block-height), \n                    renewal-height: (if (is-eq renewal u0)\n                                        u0\n                                        (+ burn-block-height renewal)\n                                    ), \n                    stx-burn: stx-burned\n                }\n            )\n        )\n        (try! (as-contract (stx-transfer? stx-burned .BNS-V2 (get owner name-props))))\n        ;; Transfer ownership of the name to the new owner\n        (try! (purchase-transfer name-index (get owner name-props) contract-caller))\n        ;; Log the name transfer event\n        (print \n            {\n                topic: \"transfer-name\", \n                owner: contract-caller, \n                name: {name: name, namespace: namespace}, \n                id: name-index,\n                properties: (map-get? name-properties {name: name, namespace: namespace})\n            }\n        )\n        ;; Return the name index\n        (ok name-index)\n    )\n)\n\n(define-private (register-new-name (id-to-be-minted uint) (hashed-salted-fqn (buff 20)) (stx-burned uint) (name (buff 48)) (namespace (buff 20)) (lifetime uint))\n    (begin\n        ;; Set the properties for the newly registered name\n        (map-set name-properties\n            {name: name, namespace: namespace} \n            {\n                registered-at: (some burn-block-height),\n                imported-at: none,\n                hashed-salted-fqn-preorder: (some hashed-salted-fqn),\n                preordered-by: (some contract-caller),\n                renewal-height: (if (is-eq lifetime u0)\n                                    u0\n                                    (+ burn-block-height lifetime)\n                                ),\n                stx-burn: stx-burned,\n                owner: contract-caller,\n            }\n        )\n        ;; Update the index-to-name and name-to-index mappings\n        (map-set index-to-name id-to-be-minted {name: name, namespace: namespace})\n        (map-set name-to-index {name: name, namespace: namespace} id-to-be-minted)\n        ;; Increment the BNS index\n        (var-set bns-index id-to-be-minted)\n        ;; Update the primary name for the new owner if necessary\n        (update-primary-name-recipient id-to-be-minted contract-caller)\n        ;; Mint a new NFT for the BNS name\n        (try! (nft-mint? BNS-V2 id-to-be-minted contract-caller))\n        ;; Burn the STX paid for the name registration\n        (try! (as-contract (stx-burn? stx-burned .BNS-V2)))\n        ;; Log the new name registration event\n        (print \n            {\n                topic: \"new-name\", \n                owner: contract-caller, \n                name: {name: name, namespace: namespace}, \n                id: id-to-be-minted,\n                properties: (map-get? name-properties {name: name, namespace: namespace})\n            }\n        )\n        ;; Return the ID of the newly minted name\n        (ok id-to-be-minted)\n    )\n)\n\n;; Migration Functions\n(define-public (namespace-airdrop \n    (namespace (buff 20))\n    (pricing {base: uint, buckets: (list 16 uint), coeff: uint, no-vowel-discount: uint, nonalpha-discount: uint}) \n    (lifetime uint) \n    (namespace-import principal) \n    (namespace-manager (optional principal)) \n    (can-update-price bool) \n    (manager-transfers bool) \n    (manager-frozen bool)\n    (revealed-at uint)\n    (launched-at uint)\n)\n    (begin\n        ;; Check if migration is complete\n        (asserts! (not (var-get migration-complete)) ERR-MIGRATION-IN-PROGRESS)\n        ;; Ensure the contract-caller is the airdrop contract.\n        (asserts! (is-eq DEPLOYER tx-sender) ERR-OPERATION-UNAUTHORIZED)\n        ;; Ensure the namespace consists of valid characters only.\n        (asserts! (not (has-invalid-chars namespace)) ERR-CHARSET-INVALID)\n        ;; Check that the namespace is available for reveal.\n        (asserts! (unwrap! (can-namespace-be-registered namespace) ERR-NAMESPACE-ALREADY-EXISTS) ERR-NAMESPACE-ALREADY-EXISTS)\n        ;; Set all properties\n        (map-set namespaces namespace\n            {\n                namespace-manager: namespace-manager,\n                manager-transferable: manager-transfers,\n                manager-frozen: manager-frozen,\n                namespace-import: namespace-import,\n                revealed-at: revealed-at,\n                launched-at: (some launched-at),\n                lifetime: lifetime,\n                can-update-price-function: can-update-price,\n                price-function: pricing \n            }\n        )\n        ;; Emit an event to indicate the namespace is now ready and launched.\n        (print { namespace: namespace, status: \"launch\", properties: (map-get? namespaces namespace)})\n        ;; Confirm successful airdrop of the namespace\n        (ok namespace)\n    )\n)\n\n(define-public (name-airdrop\n    (name (buff 48))\n    (namespace (buff 20))\n    (registered-at uint)\n    (lifetime uint) \n    (owner principal)\n)\n    (let\n        (\n            (mint-index (+ u1 (var-get bns-index)))\n        )\n        ;; Check if migration is complete\n        (asserts! (not (var-get migration-complete)) ERR-MIGRATION-IN-PROGRESS)\n        ;; Ensure the contract-caller is the airdrop contract.\n        (asserts! (is-eq DEPLOYER tx-sender) ERR-OPERATION-UNAUTHORIZED)\n        ;; Set all properties\n        (map-set name-to-index {name: name, namespace: namespace} mint-index)\n        (map-set index-to-name mint-index {name: name, namespace: namespace})\n        (map-set name-properties {name: name, namespace: namespace}\n            {\n                registered-at: (some registered-at),\n                imported-at: none,\n                hashed-salted-fqn-preorder: none,\n                preordered-by: none,\n                renewal-height: (if (is-eq lifetime u0) u0 (+ burn-block-height lifetime)),\n                stx-burn: u0,\n                owner: owner,\n            }\n        )\n        ;; Update the index \n        (var-set bns-index mint-index)\n        ;; Update the primary name of the recipient\n        (map-set primary-name owner mint-index)\n        ;; Mint the Name to the owner\n        (try! (nft-mint? BNS-V2 mint-index owner))\n        (print \n            {\n                topic: \"new-airdrop\", \n                owner: owner, \n                name: {name: name, namespace: namespace}, \n                id: mint-index,\n                registered-at: registered-at, \n            }\n        )\n        ;; Confirm successful airdrop of the namespace\n        (ok mint-index)\n    )\n)\n\n(define-public (flip-migration-complete)\n    (ok \n        (begin \n            (asserts! (is-eq contract-caller DEPLOYER) ERR-NOT-AUTHORIZED) \n            (var-set migration-complete true)\n        )\n    )\n)\n\n",
    "analysis": {
      "summary": "This contract facilitates the creation and management of namespaces and names within those namespaces, including features like NFT minting, renewals, and transfers.",
      "explanation": "The contract provides a comprehensive system for managing namespaces and names, including their creation, renewal, and transfer. It integrates NFT functionalities, allowing names to be minted as NFTs, and includes mechanisms for namespace and name pricing, renewals, and ownership transfers. Key components include namespace and name registration, renewal processes, and the ability to update metadata URIs for tokens and the contract itself. It also supports a migration system for transitioning from an older version, with functions dedicated to airdropping namespaces and names to existing owners and a switch to finalize the migration process.",
      "tags": ["NFT", "protocol", "utility"]
    }
  },
  {
    "rank": 5,
    "contract": "SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex",
    "calls": 12242,
    "source": "(impl-trait .trait-sip-010.sip-010-trait)\n(impl-trait .extension-trait.extension-trait)\n(define-constant err-unauthorised (err u3000))\n(define-constant err-not-token-owner (err u4))\n(define-fungible-token alex)\n(define-fungible-token alex-locked)\n(define-data-var token-name (string-ascii 32) \"ALEX Token\")\n(define-data-var token-symbol (string-ascii 10) \"ALEX\")\n(define-data-var token-decimals uint u8)\n(define-data-var token-uri (optional (string-utf8 256)) (some u\"https://cdn.alexlab.co/metadata/token-alex.json\"))\n(define-map approved-contracts principal bool)\n(define-public (is-dao-or-extension)\n\t(ok (asserts! (or (is-eq tx-sender .executor-dao) (contract-call? .executor-dao is-extension contract-caller)) err-unauthorised))\n)\n(define-private (check-is-approved)\n  (ok (asserts! (default-to false (map-get? approved-contracts tx-sender)) err-unauthorised))\n)\n(define-public (edg-transfer (amount uint) (sender principal) (recipient principal))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ft-transfer? alex amount sender recipient)\n\t)\n)\n(define-public (edg-lock (amount uint) (owner principal))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(try! (ft-burn? alex amount owner))\n\t\t(ft-mint? alex-locked amount owner)\n\t)\n)\n(define-public (edg-unlock (amount uint) (owner principal))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(try! (ft-burn? alex-locked amount owner))\n\t\t(ft-mint? alex amount owner)\n\t)\n)\n(define-public (edg-mint (amount uint) (recipient principal))\n\t(begin\t\t\n\t\t(asserts! (or (is-ok (is-dao-or-extension)) (is-ok (check-is-approved))) err-unauthorised)\n\t\t(ft-mint? alex amount recipient)\n\t)\n)\n(define-public (edg-burn (amount uint) (owner principal))\n\t(begin\n\t\t(asserts! (or (is-ok (is-dao-or-extension)) (is-ok (check-is-approved))) err-unauthorised)\n\t\t(ft-burn? alex amount owner)\n\t)\n)\n(define-public (set-name (new-name (string-ascii 32)))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ok (var-set token-name new-name))\n\t)\n)\n(define-public (set-symbol (new-symbol (string-ascii 10)))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ok (var-set token-symbol new-symbol))\n\t)\n)\n(define-public (set-decimals (new-decimals uint))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ok (var-set token-decimals new-decimals))\n\t)\n)\n(define-public (set-token-uri (new-uri (optional (string-utf8 256))))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ok (var-set token-uri new-uri))\n\t)\n)\n(define-private (edg-mint-many-iter (item {amount: uint, recipient: principal}))\n\t(ft-mint? alex (get amount item) (get recipient item))\n)\n(define-public (edg-mint-many (recipients (list 200 {amount: uint, recipient: principal})))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ok (map edg-mint-many-iter recipients))\n\t)\n)\n(define-public (edg-set-approved-contract (new-approved-contract principal) (approved bool))\n  (begin\n    (try! (is-dao-or-extension))\n    (ok (map-set approved-contracts new-approved-contract approved))\n  )\n)\n(define-public (transfer (amount uint) (sender principal) (recipient principal) (memo (optional (buff 34))))\n\t(begin\n\t\t(asserts! (or (is-eq tx-sender sender) (is-eq contract-caller sender)) err-not-token-owner)\n\t\t(ft-transfer? alex amount sender recipient)\n\t)\n)\n(define-read-only (get-name)\n\t(ok (var-get token-name))\n)\n(define-read-only (get-symbol)\n\t(ok (var-get token-symbol))\n)\n(define-read-only (get-decimals)\n\t(ok (var-get token-decimals))\n)\n(define-read-only (get-balance (who principal))\n\t(ok (+ (ft-get-balance alex who) (ft-get-balance alex-locked who)))\n)\n(define-read-only (get-total-supply)\n\t(ok (+ (ft-get-supply alex) (ft-get-supply alex-locked)))\n)\n(define-read-only (get-token-uri)\n\t(ok (var-get token-uri))\n)\n(define-read-only (edg-get-balance (who principal))\n\t(get-balance who)\n)\n(define-read-only (edg-has-percentage-balance (who principal) (factor uint))\n\t(ok (>= (* (unwrap-panic (get-balance who)) factor) (* (unwrap-panic (get-total-supply)) u1000)))\n)\n(define-read-only (edg-get-locked (owner principal))\n\t(ok (ft-get-balance alex-locked owner))\n)\n(define-public (callback (sender principal) (payload (buff 2048)))\n\t(ok true)\n)\n(define-constant ONE_8 (pow u10 u8))\n(define-public (mint (amount uint) (recipient principal))\n  (edg-mint amount recipient)\n)\n(define-public (burn (amount uint) (sender principal))\n  (edg-burn amount sender)\n)\n(define-private (pow-decimals)\n  (pow u10 (unwrap-panic (get-decimals)))\n)\n(define-read-only (fixed-to-decimals (amount uint))\n  (/ (* amount (pow-decimals)) ONE_8)\n)\n(define-private (decimals-to-fixed (amount uint))\n  (/ (* amount ONE_8) (pow-decimals))\n)\n(define-read-only (get-total-supply-fixed)\n  (ok (decimals-to-fixed (unwrap-panic (get-total-supply))))\n)\n(define-read-only (get-balance-fixed (account principal))\n  (ok (decimals-to-fixed (unwrap-panic (get-balance account))))\n)\n(define-public (transfer-fixed (amount uint) (sender principal) (recipient principal) (memo (optional (buff 34))))\n  (transfer (fixed-to-decimals amount) sender recipient memo)\n)\n(define-public (mint-fixed (amount uint) (recipient principal))\n  (mint (fixed-to-decimals amount) recipient)\n)\n(define-public (burn-fixed (amount uint) (sender principal))\n  (burn (fixed-to-decimals amount) sender)\n)",
    "analysis": {
      "summary": "This contract manages the lifecycle of ALEX tokens, including minting, burning, transferring, and locking/unlocking tokens, with additional administrative functions.",
      "explanation": "The contract starts by implementing two traits for standard token operations and extensions <L1-2>. It defines constants for error codes <L3-4>, two fungible tokens (ALEX and ALEX-locked) <L5-6>, and data variables for token metadata <L7-10>. A map to track approved contracts is also declared <L11>. The contract includes functions for DAO or extension validation, token operations (transfer, lock/unlock, mint, burn), metadata management, and utility functions for balance and supply calculations with fixed-point arithmetic support. Notably, it employs a security model that restricts sensitive operations to the DAO or approved extensions, ensuring a controlled token lifecycle management. The contract's architecture is modular, focusing on clear separation of concerns between token management and administrative functionalities. It uses Clarity's capabilities for error handling, data management, and inter-contract communication effectively, showcasing a comprehensive approach to token lifecycle management on the Stacks blockchain.",
      "tags": ["fungible-token", "utility", "governance", "protocol"]
    }
  },
  {
    "rank": 6,
    "contract": "SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.router-velar-alex-v-1-2",
    "calls": 9214,
    "source": ";; router-velar-alex-v-1-2\n\n(use-trait v-ft-trait 'SP2AKWJYC7BNY18W1XXKPGP0YVEK63QJG4793Z2D4.sip-010-trait-ft-standard.sip-010-trait)\n(use-trait v-share-fee-to-trait 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to-trait.share-fee-to-trait)\n(use-trait a-ft-trait 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.trait-sip-010.sip-010-trait)\n\n(define-constant ERR_NOT_AUTHORIZED (err u1001))\n(define-constant ERR_INVALID_AMOUNT (err u1002))\n(define-constant ERR_INVALID_PRINCIPAL (err u1003))\n(define-constant ERR_ALREADY_ADMIN (err u2001))\n(define-constant ERR_ADMIN_LIMIT_REACHED (err u2002))\n(define-constant ERR_ADMIN_NOT_IN_LIST (err u2003))\n(define-constant ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER (err u2004))\n(define-constant ERR_SWAP_STATUS (err u4001))\n(define-constant ERR_MINIMUM_RECEIVED (err u4002))\n(define-constant ERR_SWAP_A (err u5001))\n(define-constant ERR_SWAP_B (err u5002))\n(define-constant ERR_SCALED_AMOUNT_A (err u6001))\n(define-constant ERR_QUOTE_A (err u7001))\n(define-constant ERR_QUOTE_B (err u7002))\n\n(define-constant CONTRACT_DEPLOYER tx-sender)\n\n(define-data-var admins (list 5 principal) (list tx-sender))\n(define-data-var admin-helper principal tx-sender)\n\n(define-data-var swap-status bool true)\n\n(define-read-only (get-admins)\n  (ok (var-get admins))\n)\n\n(define-read-only (get-admin-helper)\n  (ok (var-get admin-helper))\n)\n\n(define-read-only (get-swap-status)\n  (ok (var-get swap-status))\n)\n\n(define-public (set-swap-status (status bool))\n  (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n      (var-set swap-status status)\n      (print {action: \"set-swap-status\", caller: caller, data: {status: status}})\n      (ok true)\n    )\n  )\n)\n\n(define-public (add-admin (admin principal))\n  (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n  )\n    (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n    (asserts! (is-none (index-of admins-list admin)) ERR_ALREADY_ADMIN)\n    (asserts! (is-standard admin) ERR_INVALID_PRINCIPAL)\n    (var-set admins (unwrap! (as-max-len? (append admins-list admin) u5) ERR_ADMIN_LIMIT_REACHED))\n    (print {action: \"add-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n  )\n)\n\n(define-public (remove-admin (admin principal))\n  (let (\n    (admins-list (var-get admins))\n    (caller-in-list (index-of admins-list tx-sender))\n    (admin-to-remove-in-list (index-of admins-list admin))\n    (caller tx-sender)\n  )\n    (asserts! (is-some caller-in-list) ERR_NOT_AUTHORIZED)\n    (asserts! (is-some admin-to-remove-in-list) ERR_ADMIN_NOT_IN_LIST)\n    (asserts! (not (is-eq admin CONTRACT_DEPLOYER)) ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER)\n    (asserts! (is-standard admin) ERR_INVALID_PRINCIPAL)\n    (var-set admin-helper admin)\n    (var-set admins (filter admin-not-removeable admins-list))\n    (print {action: \"remove-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n  )\n)\n\n(define-public (get-quote-a\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>)))\n    (a-factors (tuple (a uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qa amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qa amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get b v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get b a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qa scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qa scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-b\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qa amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qb amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get b v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get c a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qb scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qa scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-c\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qa amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qc amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get b v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get d a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qc scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qa scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-d\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>) (e <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qa amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qd amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get b v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get e a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qd scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qa scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-e\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>)))\n    (a-factors (tuple (a uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qb amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qa amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get c v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get b a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qa scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qb scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-f\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qb amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qb amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get c v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get c a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qb scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qb scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-g\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qb amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qc amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get c v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get d a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qc scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qb scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-h\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>) (e <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qb amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qd amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get c v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get e a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qd scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qb scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-i\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>)))\n    (a-factors (tuple (a uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qc amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qa amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get d v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get b a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qa scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qc scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-j\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qc amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qb amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get d v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get c a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qb scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qc scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-k\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qc amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qc amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get d v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get d a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qc scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qc scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-l\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>) (e <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qc amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qd amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get d v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get e a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qd scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qc scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-m\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>) (e <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>)))\n    (a-factors (tuple (a uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qd amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qa amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get e v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get b a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qa scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qd scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-n\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>) (e <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qd amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qb amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get e v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get c a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qb scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qd scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-o\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>) (e <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qd amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qc amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get e v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get d a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qc scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qd scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-p\n    (amount uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>) (e <v-ft-trait>)))\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>) (e <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (velar-qd amount v-tokens) ERR_QUOTE_A)\n                 (unwrap! (alex-qd amount a-tokens a-factors) ERR_QUOTE_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount quote-a (get e v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount quote-a (get e a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qd scaled-amount a-tokens a-factors) ERR_QUOTE_B)\n                 (unwrap! (velar-qd scaled-amount v-tokens) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (swap-helper-a\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>)))\n    (a-factors (tuple (a uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sa amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sa amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get b v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get b a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sa scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sa scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-a\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-b\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sa amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sb amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get b v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get c a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sb scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sa scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-b\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-c\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sa amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sc amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get b v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get d a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sc scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sa scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-c\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-d\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>) (e <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sa amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sd amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get b v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get e a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sd scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sa scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-d\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-e\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>)))\n    (a-factors (tuple (a uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sb amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sa amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get c v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get b a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sa scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sb scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-e\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-f\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sb amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sb amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get c v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get c a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sb scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sb scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-f\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-g\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sb amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sc amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get c v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get d a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sc scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sb scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-g\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-h\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>) (e <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sb amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sd amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get c v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get e a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sd scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sb scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-h\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-i\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>)))\n    (a-factors (tuple (a uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sc amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sa amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get d v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get b a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sa scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sc scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-i\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-j\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sc amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sb amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get d v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get c a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sb scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sc scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-j\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-k\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sc amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sc amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get d v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get d a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sc scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sc scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-k\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-l\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>) (e <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sc amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sd amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get d v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get e a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sd scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sc scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-l\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-m\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>) (e <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>)))\n    (a-factors (tuple (a uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sd amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sa amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get e v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get b a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sa scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sd scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-m\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-n\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>) (e <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sd amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sb amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get e v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get c a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sb scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sd scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-n\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-o\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>) (e <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sd amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sc amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get e v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get d a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sc scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sd scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-o\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-p\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (v-tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>) (e <v-ft-trait>)))\n    (v-share-fee-to <v-share-fee-to-trait>)\n    (a-tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>) (e <a-ft-trait>)))\n    (a-factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (velar-sd amount v-tokens v-share-fee-to) ERR_SWAP_A)\n                (unwrap! (alex-sd amount a-tokens a-factors) ERR_SWAP_A)))\n    (scaled-amount (if (is-eq swaps-reversed false)\n                       (unwrap! (scale-velar-amount swap-a (get e v-tokens) (get a a-tokens)) ERR_SCALED_AMOUNT_A)\n                       (unwrap! (scale-alex-amount swap-a (get e a-tokens) (get a v-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sd scaled-amount a-tokens a-factors) ERR_SWAP_B)\n                (unwrap! (velar-sd scaled-amount v-tokens v-share-fee-to) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-p\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          velar-data: {\n            v-tokens: v-tokens,\n            v-share-fee-to: v-share-fee-to,\n            v-swap: (if (is-eq swaps-reversed false) swap-a swap-b)\n          },\n          alex-data: {\n            a-tokens: a-tokens,\n            a-factors: a-factors,\n            a-swap: (if (is-eq swaps-reversed false) swap-b swap-a)\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-private (velar-qa\n    (amount uint)\n    (tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>)))\n  )\n  (let (\n    (quote-a (contract-call?\n             'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-path2 amount-out\n             amount\n             (get a tokens) (get b tokens)))\n  )\n    (ok quote-a)\n  )\n)\n\n(define-private (velar-qb\n    (amount uint)\n    (tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>)))\n  )\n  (let (\n    (quote-a (contract-call?\n             'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-path2 get-amount-out-3\n             amount\n             (get a tokens) (get b tokens) (get c tokens)))\n  )\n    (ok (get c quote-a))\n  )\n)\n\n(define-private (velar-qc\n    (amount uint)\n    (tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>)))\n  )\n  (let (\n    (quote-a (contract-call?\n             'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-path2 get-amount-out-4\n             amount\n             (get a tokens) (get b tokens) (get c tokens) (get d tokens)\n             (list u1 u2 u3 u4)))\n  )\n    (ok (get d quote-a))\n  )\n)\n\n(define-private (velar-qd\n    (amount uint)\n    (tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>) (e <v-ft-trait>)))\n  )\n  (let (\n    (quote-a (contract-call?\n             'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-path2 get-amount-out-5\n             amount\n             (get a tokens) (get b tokens) (get c tokens) (get d tokens) (get e tokens)))\n  )\n    (ok (get e quote-a))\n  )\n)\n\n(define-private (alex-qa\n    (amount uint)\n    (tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>)))\n    (factors (tuple (a uint)))\n  )\n  (let (\n    (a-token (get a tokens))\n    (b-token (get b tokens))\n    (quote-a (unwrap-panic (contract-call?\n                           'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-helper\n                           (contract-of a-token) (contract-of b-token)\n                           (get a factors)\n                           amount)))\n  )\n    (ok quote-a)\n  )\n)\n\n(define-private (alex-qb\n    (amount uint)\n    (tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>)))\n    (factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (a-token (get a tokens))\n    (b-token (get b tokens))\n    (c-token (get c tokens))\n    (quote-a (unwrap-panic (contract-call?\n                           'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-helper-a\n                           (contract-of a-token) (contract-of b-token) (contract-of c-token)\n                           (get a factors) (get b factors)\n                           amount)))\n  )\n    (ok quote-a)\n  )\n)\n\n(define-private (alex-qc\n    (amount uint)\n    (tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>)))\n    (factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (a-token (get a tokens))\n    (b-token (get b tokens))\n    (c-token (get c tokens))\n    (d-token (get d tokens))\n    (quote-a (unwrap-panic (contract-call?\n                           'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-helper-b\n                           (contract-of a-token) (contract-of b-token) (contract-of c-token)\n                           (contract-of d-token)\n                           (get a factors) (get b factors) (get c factors)\n                           amount)))\n  )\n    (ok quote-a)\n  )\n)\n\n(define-private (alex-qd\n    (amount uint)\n    (tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>) (e <a-ft-trait>)))\n    (factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (a-token (get a tokens))\n    (b-token (get b tokens))\n    (c-token (get c tokens))\n    (d-token (get d tokens))\n    (e-token (get e tokens))\n    (quote-a (unwrap-panic (contract-call?\n                           'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-helper-c\n                           (contract-of a-token) (contract-of b-token) (contract-of c-token)\n                           (contract-of d-token) (contract-of e-token)\n                           (get a factors) (get b factors) (get c factors) (get d factors)\n                           amount)))\n  )\n    (ok quote-a)\n  )\n)\n\n(define-private (velar-sa\n    (amount uint)\n    (tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>)))\n    (share-fee-to <v-share-fee-to-trait>)\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-path2 do-swap\n                  amount\n                  (get a tokens) (get b tokens)\n                  share-fee-to)))\n  )\n    (ok (get amt-out swap-a))\n  )\n)\n\n(define-private (velar-sb\n    (amount uint)\n    (tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>)))\n    (share-fee-to <v-share-fee-to-trait>)\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-path2 swap-3\n                  amount u1\n                  (get a tokens) (get b tokens) (get c tokens)\n                  share-fee-to)))\n  )\n    (ok (get amt-out (get c swap-a)))\n  )\n)\n\n(define-private (velar-sc\n    (amount uint)\n    (tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>)))\n    (share-fee-to <v-share-fee-to-trait>)\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-path2 swap-4\n                  amount u1\n                  (get a tokens) (get b tokens) (get c tokens) (get d tokens)\n                  share-fee-to)))\n  )\n    (ok (get amt-out (get d swap-a)))\n  )\n)\n\n(define-private (velar-sd\n    (amount uint)\n    (tokens (tuple (a <v-ft-trait>) (b <v-ft-trait>) (c <v-ft-trait>) (d <v-ft-trait>) (e <v-ft-trait>)))\n    (share-fee-to <v-share-fee-to-trait>)\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-path2 swap-5\n                  amount u1\n                  (get a tokens) (get b tokens) (get c tokens) (get d tokens) (get e tokens)\n                  share-fee-to)))\n  )\n    (ok (get amt-out (get e swap-a)))\n  )\n)\n\n(define-private (alex-sa\n    (amount uint)\n    (tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>)))\n    (factors (tuple (a uint)))\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper\n                  (get a tokens) (get b tokens)\n                  (get a factors)\n                  amount (some u1))))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-private (alex-sb\n    (amount uint)\n    (tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>)))\n    (factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper-a\n                  (get a tokens) (get b tokens) (get c tokens)\n                  (get a factors) (get b factors)\n                  amount (some u1))))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-private (alex-sc\n    (amount uint)\n    (tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>)))\n    (factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper-b\n                  (get a tokens) (get b tokens) (get c tokens) (get d tokens)\n                  (get a factors) (get b factors) (get c factors)\n                  amount (some u1))))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-private (alex-sd\n    (amount uint)\n    (tokens (tuple (a <a-ft-trait>) (b <a-ft-trait>) (c <a-ft-trait>) (d <a-ft-trait>) (e <a-ft-trait>)))\n    (factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper-c\n                  (get a tokens) (get b tokens) (get c tokens) (get d tokens) (get e tokens)\n                  (get a factors) (get b factors) (get c factors) (get d factors)\n                  amount (some u1))))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-private (scale-velar-amount (amount uint) (v-token <v-ft-trait>) (a-token <a-ft-trait>))\n  (let (\n    (v-decimals (unwrap-panic (contract-call? v-token get-decimals)))\n    (a-decimals (unwrap-panic (contract-call? a-token get-decimals)))\n    (scaled-amount\n      (if (is-eq v-decimals a-decimals)\n        amount\n        (if (> v-decimals a-decimals)\n          (/ amount (pow u10 (- v-decimals a-decimals)))\n          (* amount (pow u10 (- a-decimals v-decimals)))\n        )\n      )\n    )\n  )\n    (ok scaled-amount)\n  )\n)\n\n(define-private (scale-alex-amount (amount uint) (a-token <a-ft-trait>) (v-token <v-ft-trait>))\n  (let (\n    (a-decimals (unwrap-panic (contract-call? a-token get-decimals)))\n    (v-decimals (unwrap-panic (contract-call? v-token get-decimals)))\n    (scaled-amount\n      (if (is-eq a-decimals v-decimals)\n        amount\n        (if (> a-decimals v-decimals)\n          (/ amount (pow u10 (- a-decimals v-decimals)))\n          (* amount (pow u10 (- v-decimals a-decimals)))\n        )\n      )\n    )\n  )\n    (ok scaled-amount)\n  )\n)\n\n(define-private (admin-not-removeable (admin principal))\n  (not (is-eq admin (var-get admin-helper)))\n)",
    "analysis": {
      "summary": "This contract facilitates token swaps with dynamic routing and admin management.",
      "explanation": "This contract is designed to manage token swaps across different liquidity pools on the Stacks blockchain, utilizing a dynamic routing system to optimize swap outcomes. It also includes administrative functions to manage operational parameters and permissions.\n\n1. Constants and Error Codes <L7-20>: Defines error codes for various failure states such as unauthorized access, invalid amounts, or swap operation errors.\n\n2. Data Variables <L22-27>: Includes the contract deployer, a list of admin principals, an admin helper for removal operations, and a boolean to toggle swap functionality.\n\n3. Read-Only Functions <L29-39>: Provide access to the contract's current admin list, admin helper, and swap status.\n\n4. Administrative Functions <L41-85>: Allow authorized admins to toggle swap functionality, add or remove admins, with checks for authorization and list constraints.\n\n5. Swap Quote Functions <L87-1205>: A series of functions to get swap quotes across various token pairs and configurations, handling both direct and reverse swaps, and scaling amounts based on token decimals.\n\n6. Swap Helper Functions <L439-1205>: Perform the actual swaps, with pre-checks for swap status, minimum received amounts, and printing swap details. These functions call external contracts for swap execution and handle both 'velar' and 'alex' token types with scaling for token decimals.\n\nEach swap function variant (e.g., swap-helper-a, swap-helper-b) is tailored to handle different token configurations and swap paths, demonstrating the contract's flexibility in routing swaps across multiple liquidity pools.\n\nNotable qualities include:\n- Dynamic swap routing based on token pairs and swap directions.\n- Admin management for operational control.\n- Detailed error handling and logging of swap actions.\n- Compatibility with multiple token standards through trait usage.",
      "tags": ["DeFi", "DEX", "swap", "utility"]
    }
  },
  {
    "rank": 7,
    "contract": "SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-stx-ststx-v-1-2",
    "calls": 6992,
    "source": ";; Bitflow Stableswap Core Contract - v1.2\n;; This contract handles the core logic of the Stableswap protocol.\n;; The trading pair is stSTX/STX, where stSTX is the staked STX token.\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;; Cons, Vars, & Maps ;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(use-trait sip-010-trait .sip-010-trait-ft-standard.sip-010-trait)\n(use-trait lp-trait .lp-trait.lp-trait)\n\n;;;;;;;;;;;;;;;\n;; Constants ;;\n;;;;;;;;;;;;;;;\n\n;; This contract address\n(define-constant this-contract (as-contract tx-sender))\n\n;; Deployment height\n(define-constant deployment-height burn-block-height)\n\n;; Cycle length in blocks (1 day = 144 blocks)\n(define-constant cycle-length u144)\n\n;; Index loop for using Newton-Raphson method to converge square root that goes up to u384\n(define-constant index-list (list u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13 u14 u15 u16 u17 u18 u19 u20 u21 u22 u23 u24 u25 u26 u27 u28 u29 u30 u31 u32 u33 u34 u35 u36 u37 u38 u39 u40 u41 u42 u43 u44 u45 u46 u47 u48 u49 u50 u51 u52 u53 u54 u55 u56 u57 u58 u59 u60 u61 u62 u63 u64 u65 u66 u67 u68 u69 u70 u71 u72 u73 u74 u75 u76 u77 u78 u79 u80 u81 u82 u83 u84 u85 u86 u87 u88 u89 u90 u91 u92 u93 u94 u95 u96 u97 u98 u99 u100 u101 u102 u103 u104 u105 u106 u107 u108 u109 u110 u111 u112 u113 u114 u115 u116 u117 u118 u119 u120 u121 u122 u123 u124 u125 u126 u127 u128 u129 u130 u131 u132 u133 u134 u135 u136 u137 u138 u139 u140 u141 u142 u143 u144 u145 u146 u147 u148 u149 u150 u151 u152 u153 u154 u155 u156 u157 u158 u159 u160 u161 u162 u163 u164 u165 u166 u167 u168 u169 u170 u171 u172 u173 u174 u175 u176 u177 u178 u179 u180 u181 u182 u183 u184 u185 u186 u187 u188 u189 u190 u191 u192 u193 u194 u195 u196 u197 u198 u199 u200 u201 u202 u203 u204 u205 u206 u207 u208 u209 u210 u211 u212 u213 u214 u215 u216 u217 u218 u219 u220 u221 u222 u223 u224 u225 u226 u227 u228 u229 u230 u231 u232 u233 u234 u235 u236 u237 u238 u239 u240 u241 u242 u243 u244 u245 u246 u247 u248 u249 u250 u251 u252 u253 u254 u255 u256 u257 u258 u259 u260 u261 u262 u263 u264 u265 u266 u267 u268 u269 u270 u271 u272 u273 u274 u275 u276 u277 u278 u279 u280 u281 u282 u283 u284 u285 u286 u287 u288 u289 u290 u291 u292 u293 u294 u295 u296 u297 u298 u299 u300 u301 u302 u303 u304 u305 u306 u307 u308 u309 u310 u311 u312 u313 u314 u315 u316 u317 u318 u319 u320 u321 u322 u323 u324 u325 u326 u327 u328 u329 u330 u331 u332 u333 u334 u335 u336 u337 u338 u339 u340 u341 u342 u343 u344 u345 u346 u347 u348 u349 u350 u351 u352 u353 u354 u355 u356 u357 u358 u359 u360 u361 u362 u363 u364 u365 u366 u367 u368 u369 u370 u371 u372 u373 u374 u375 u376 u377 u378 u379 u380 u381 u382 u383 u384))\n\n;; Number of tokens per pair\n(define-constant number-of-tokens u2)\n\n;; Contract deployer\n(define-constant contract-deployer tx-sender)\n\n;;;;;;;;;;;;\n;; Errors ;;\n;;;;;;;;;;;;\n\n\n;;;;;;;;;;;;;;;\n;; Variables ;;\n;;;;;;;;;;;;;;;\n\n;; Contract for Stableswap Staking and Rewards\n(define-data-var staking-and-rewards-contract principal tx-sender)\n\n;; Define a variable to track whether the staking-and-rewards contract has been set\n(define-data-var staking-and-rewards-contract-is-set bool false)\n\n;; Contract for the Stacking DAO to receive fees\n(define-data-var stacking-dao-contract principal 'SP4SZE494VC2YC5JYG7AYFQ44F5Q4PYV7DVMDPBG)\n\n;; Contract for the Bitflow protocol to receive fees\n(define-data-var bitflow-contract principal 'SP1G6QWV6X9EVXH7QMMFVHNC3VHWJC28MHR6P8TX2)\n\n;; Admin Governance List\n(define-data-var admins (list 5 principal) (list tx-sender))\n\n;; Swap Fees (5 total bps initialized, 3 bps to LPs, 0 bps to Stacking DAO protocol, 2bps to Bitflow protocol)\n(define-data-var buy-fees {lps: uint, stacking-dao: uint, bitflow: uint} {lps: u3, stacking-dao: u0, bitflow: u2})\n\n;; Swap Fees (200 total bps initialized, 3 bps to LPs, 195 bps to Stacking DAO protocol, 2bps to Bitflow protocol)\n(define-data-var sell-fees {lps: uint, stacking-dao: uint, bitflow: uint} {lps: u3, stacking-dao: u195, bitflow: u2})\n\n;; Admin Swap Fees - Set to Zero\n(define-data-var admin-swap-fees {lps: uint, stacking-dao: uint, bitflow: uint} {lps: u0, stacking-dao: u0, bitflow: u0})\n\n;; Liquidity Fees (3 bps initialized, all to protocol)\n(define-data-var liquidity-fees uint u3)\n\n;; Helper var to remove admin\n(define-data-var helper-principal principal tx-sender)\n\n;; Convergence Threshold\n(define-data-var convergence-threshold uint u2)\n\n\n;;;;;;;;;;\n;; Maps ;;\n;;;;;;;;;;\n\n(define-map PairsDataMap {y-token: principal, lp-token: principal} {\n    approval: bool,\n    total-shares: uint,\n    x-decimals: uint,\n    y-decimals: uint,\n    balance-x: uint,\n    balance-y: uint,\n    d: uint,\n    amplification-coefficient: uint,\n})\n\n(define-map CycleDataMap {y-token: principal, lp-token: principal, cycle-num: uint} {\n    cycle-fee-balance-x: uint\n})\n\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Read-Only Functions ;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Get pair data\n(define-read-only (get-pair-data (y-token <sip-010-trait>) (lp-token <sip-010-trait>)) \n    (map-get? PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)})\n)\n\n;; Get cycle data\n(define-read-only (get-cycle-data (y-token principal) (lp-token principal) (cycle-num uint)) \n    (map-get? CycleDataMap {y-token: y-token, lp-token: lp-token, cycle-num: cycle-num})\n)\n\n;; Get current cycle\n(define-read-only (get-current-cycle) \n    (/ (- burn-block-height deployment-height) cycle-length)\n)\n\n;; Get cycle from height\n(define-read-only (get-cycle-from-height (height uint)) \n    (/ (- height deployment-height) cycle-length)\n)\n\n;; Get starting height from cycle\n(define-read-only (get-starting-height-from-cycle (cycle uint)) \n    (+ deployment-height (* cycle cycle-length))\n)\n\n;; Get deployment height\n(define-read-only (get-deployment-height) \n    deployment-height\n)\n\n;; Get up to last 120 cycle rewards -> nice to have\n;; (define-read-only (get-cycle-rewards) body)\n\n;; Get DX\n(define-read-only (get-dx (y-token <sip-010-trait>) (lp-token <lp-trait>) (y-amount uint))\n    (let \n        (\n            (pair-data (unwrap! (map-get? PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-balance-x (get balance-x pair-data))\n            (current-balance-y (get balance-y pair-data))\n            (x-decimals (get x-decimals pair-data))\n            (y-decimals (get y-decimals pair-data))\n            (swap-fee-lps (get lps (var-get sell-fees)))\n            (swap-fee-stacking-dao (get stacking-dao (var-get sell-fees)))\n            (swap-fee-bitflow (get bitflow (var-get sell-fees)))\n            (total-swap-fee (+ swap-fee-lps swap-fee-stacking-dao swap-fee-bitflow))\n\n            ;; Scale up balances to perform AMM calculations with get-x\n            (scaled-up-balances (get-scaled-up-token-amounts current-balance-x current-balance-y x-decimals y-decimals))\n            (current-balance-x-scaled (get scaled-x scaled-up-balances))\n            (current-balance-y-scaled (get scaled-y scaled-up-balances))\n            (scaled-up-swap-amount (get-scaled-up-token-amounts u0 y-amount x-decimals y-decimals))\n            (y-amount-scaled (get scaled-y scaled-up-swap-amount))\n            (updated-y-balance-scaled (+ current-balance-y-scaled y-amount-scaled))\n            (new-x-scaled (get-x updated-y-balance-scaled current-balance-x-scaled y-amount-scaled (* (get amplification-coefficient pair-data) number-of-tokens)))\n            (new-x (get scaled-x (get-scaled-down-token-amounts new-x-scaled u0 x-decimals y-decimals)))\n            (new-y (+ current-balance-y y-amount))\n\n            ;; Apply fees on the delta in x\n            (dx-without-fees (- current-balance-x new-x)) \n            (x-amount-fee-lps (/ (* dx-without-fees swap-fee-lps) u10000))\n            (x-amount-fee-stacking-dao (/ (* dx-without-fees swap-fee-stacking-dao) u10000))\n            (x-amount-fee-bitflow (/ (* dx-without-fees swap-fee-bitflow) u10000))\n            (dx (- dx-without-fees (+ x-amount-fee-lps x-amount-fee-stacking-dao x-amount-fee-bitflow)))\n        )\n        (ok dx)\n    )\n)\n\n;; Get X\n(define-read-only (get-x (y-bal uint) (x-bal uint) (y-amount uint) (ann uint))\n    (let \n        (\n            (y-bal-new (+ y-bal y-amount))\n            (current-D (get-D x-bal y-bal ann))\n            (c0 current-D)\n            (c1 (/ (* c0 current-D) (* number-of-tokens y-bal-new)))\n            (c2 (/ (* c1 current-D) (* ann number-of-tokens)))\n            (b (+ y-bal-new (/ current-D ann)))\n        )\n        (get converged (fold x-for-loop index-list {x: current-D, c: c2, b: b, D: current-D, converged: u0}))\n    )\n)\n\n;; Get X Helper\n(define-private (x-for-loop (n uint) (x-info {x: uint, c: uint, b: uint, D: uint, converged: uint})) \n    (let\n        (\n            (current-x (get x x-info))\n            (current-c (get c x-info))\n            (current-b (get b x-info))\n            (current-D (get D x-info))\n            (current-converged (get converged x-info))\n            (x-numerator (+ (* current-x current-x) current-c))\n            (x-denominator (- (+ (* u2 current-x) current-b) current-D))\n            (new-x (/ x-numerator x-denominator))\n            (threshold (var-get convergence-threshold))\n        )\n\n        (if (is-eq current-converged u0)\n            (if (> new-x  current-x)\n                (if (<= (- new-x current-x) threshold)\n                    {x: new-x, c: current-c, b: current-b, D: current-D, converged: new-x}\n                    {x: new-x, c: current-c, b: current-b, D: current-D, converged: u0}\n                )\n                (if (<= (- current-x new-x) threshold)\n                    {x: new-x, c: current-c, b: current-b, D: current-D, converged: new-x}\n                    {x: new-x, c: current-c, b: current-b, D: current-D, converged: u0}\n                )\n            )\n            x-info\n        )\n\n\n    )\n)\n\n;; Get DY\n(define-read-only (get-dy (y-token <sip-010-trait>) (lp-token <lp-trait>) (x-amount uint))\n    (let \n        (\n            \n            (pair-data (unwrap! (map-get? PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-balance-x (get balance-x pair-data))\n            (current-balance-y (get balance-y pair-data))\n            (x-decimals (get x-decimals pair-data))\n            (y-decimals (get y-decimals pair-data))\n            (swap-fee-lps (get lps (var-get buy-fees)))\n            (swap-fee-stacking-dao (get stacking-dao (var-get buy-fees)))\n            (swap-fee-bitflow (get bitflow (var-get buy-fees)))\n            (total-swap-fee (+ swap-fee-lps swap-fee-stacking-dao swap-fee-bitflow))\n\n\n            ;; Scale up balances to perform AMM calculations with get-y\n            (scaled-up-balances (get-scaled-up-token-amounts current-balance-x current-balance-y x-decimals y-decimals))\n            (current-balance-x-scaled (get scaled-x scaled-up-balances))\n            (current-balance-y-scaled (get scaled-y scaled-up-balances))\n            (scaled-up-swap-amount (get-scaled-up-token-amounts x-amount u0 x-decimals y-decimals))\n            (x-amount-scaled (get scaled-x scaled-up-swap-amount))\n            (x-amount-fees-lps-scaled (/ (* x-amount-scaled swap-fee-lps) u10000))\n            (x-amount-fees-stacking-dao-scaled (/ (* x-amount-scaled swap-fee-stacking-dao) u10000))\n            (x-amount-fees-bitflow-scaled (/ (* x-amount-scaled swap-fee-bitflow) u10000))\n            (x-amount-total-fees-scaled (/ (* x-amount total-swap-fee) u10000))\n            (updated-x-amount-scaled (- x-amount-scaled x-amount-total-fees-scaled))\n            (updated-x-balance-scaled (+ current-balance-x-scaled updated-x-amount-scaled))\n            (new-y-scaled (get-y updated-x-balance-scaled current-balance-y-scaled updated-x-amount-scaled (* (get amplification-coefficient pair-data) number-of-tokens)))\n            \n            ;; Scale down to precise amounts for y and dy, as well as x-amount-fee-lps, and x-amount-fee-stacking-dao\n            (new-y (get scaled-y (get-scaled-down-token-amounts u0 new-y-scaled x-decimals y-decimals)))\n            (dy (- current-balance-y new-y))\n        )\n        (ok dy)\n    )\n)\n\n;; Get Y\n(define-read-only (get-y (x-bal uint) (y-bal uint) (x-amount uint) (ann uint))\n    (let \n        (\n            (x-bal-new (+ x-bal x-amount))\n            (current-D (get-D x-bal y-bal ann))\n            (c0 current-D)\n            (c1 (/ (* c0 current-D) (* number-of-tokens x-bal-new)))\n            (c2 (/ (* c1 current-D) (* ann number-of-tokens)))\n            (b (+ x-bal-new (/ current-D ann)))\n        )\n        (get converged (fold y-for-loop index-list {y: current-D, c: c2, b: b, D: current-D, converged: u0}))\n    )\n)\n\n;; Get Y Helper\n(define-private (y-for-loop (n uint) (y-info {y: uint, c: uint, b: uint, D: uint, converged: uint})) \n    (let\n        (\n            (current-y (get y y-info))\n            (current-c (get c y-info))\n            (current-b (get b y-info))\n            (current-D (get D y-info))\n            (current-converged (get converged y-info))\n            (y-numerator (+ (* current-y current-y) current-c))\n            (y-denominator (- (+ (* u2 current-y) current-b) current-D))\n            (new-y (/ y-numerator y-denominator))\n            (threshold (var-get convergence-threshold))\n\n        )\n\n        (if (is-eq current-converged u0)\n            (if (> new-y  current-y)\n                (if (<= (- new-y current-y) threshold)\n                    {y: new-y, c: current-c, b: current-b, D: current-D, converged: new-y}\n                    {y: new-y, c: current-c, b: current-b, D: current-D, converged: u0}\n                )\n                (if (<= (- current-y new-y) threshold)\n                    {y: new-y, c: current-c, b: current-b, D: current-D, converged: new-y}\n                    {y: new-y, c: current-c, b: current-b, D: current-D, converged: u0}\n                )\n            )\n            y-info\n        )\n\n    )\n)\n\n\n\n;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;\n;;; Swap Functions ;;;\n;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;\n\n;; Swap X -> Y\n;; @desc: Swaps X token for Y token\n;; @params:  y-token: principal, lp-token: principal, x-amount: uint, min-y-amount: uint\n(define-public (swap-x-for-y (y-token <sip-010-trait>) (lp-token <lp-trait>) (x-amount uint) (min-y-amount uint)) \n    (let \n        (\n            (swapper tx-sender)\n            (pair-data (unwrap! (map-get? PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-approval (get approval pair-data))\n            (current-balance-x (get balance-x pair-data))\n            (current-balance-y (get balance-y pair-data))\n            (x-decimals (get x-decimals pair-data))\n            (y-decimals (get y-decimals pair-data))\n            ;; Admins pay no fees on swaps\n            (swap-fee-lps (if (is-some (index-of (var-get admins) tx-sender ))\n                (get lps (var-get buy-fees))\n                (get lps (var-get admin-swap-fees))\n            ))\n            (swap-fee-stacking-dao (if (is-some (index-of (var-get admins) tx-sender ))\n                (get stacking-dao (var-get buy-fees))\n                (get stacking-dao (var-get admin-swap-fees))\n            ))\n            (swap-fee-bitflow (if (is-some (index-of (var-get admins) tx-sender ))\n                (get bitflow (var-get buy-fees))\n                (get bitflow (var-get admin-swap-fees))\n            ))\n            (total-swap-fee (+ swap-fee-lps swap-fee-stacking-dao swap-fee-bitflow))\n\n            ;; Scale up balances and the swap amount to perform AMM calculations with get-y\n            (scaled-up-balances (get-scaled-up-token-amounts current-balance-x current-balance-y x-decimals y-decimals))\n            (current-balance-x-scaled (get scaled-x scaled-up-balances))\n            (current-balance-y-scaled (get scaled-y scaled-up-balances))\n            (scaled-up-swap-amount (get-scaled-up-token-amounts x-amount u0 x-decimals y-decimals))\n            (x-amount-scaled (get scaled-x scaled-up-swap-amount))\n            (x-amount-fees-lps-scaled (/ (* x-amount-scaled swap-fee-lps) u10000))\n            (x-amount-fees-stacking-dao-scaled (/ (* x-amount-scaled swap-fee-stacking-dao) u10000))\n            (x-amount-fees-bitflow-scaled (/ (* x-amount-scaled swap-fee-bitflow) u10000))\n            (updated-x-amount-scaled (- x-amount-scaled (+ x-amount-fees-lps-scaled x-amount-fees-stacking-dao-scaled x-amount-fees-bitflow-scaled)))\n            (updated-x-balance-scaled (+ current-balance-x-scaled updated-x-amount-scaled))\n            (new-y-scaled (get-y updated-x-balance-scaled current-balance-y-scaled updated-x-amount-scaled (* (get amplification-coefficient pair-data) number-of-tokens)))\n            \n            ;; Scale down to precise amounts for y and dy, as well as updated-x-amount and x-fees\n            (new-y (get scaled-y (get-scaled-down-token-amounts u0 new-y-scaled x-decimals y-decimals)))\n            (dy (- current-balance-y new-y))\n            (x-amount-fee-lps (get scaled-x (get-scaled-down-token-amounts x-amount-fees-lps-scaled u0 x-decimals y-decimals)))\n            (x-amount-fee-stacking-dao (get scaled-x (get-scaled-down-token-amounts x-amount-fees-stacking-dao-scaled u0 x-decimals y-decimals)))\n            (x-amount-fee-bitflow (get scaled-x (get-scaled-down-token-amounts x-amount-fees-bitflow-scaled u0 x-decimals y-decimals)))\n            (updated-x-amount (- x-amount (+ x-amount-fee-lps x-amount-fee-stacking-dao x-amount-fee-bitflow)))\n            (updated-x-balance (+ current-balance-x updated-x-amount))\n        )\n\n        ;; Assert that pair is approved\n        (asserts! current-approval (err \"err-pair-not-approved\"))\n\n        ;; Assert that x-amount is less than x10 of current-balance-x\n        (asserts! (< x-amount (* u10 current-balance-x)) (err \"err-x-amount-too-high\"))\n\n        ;; Assert that dy is greater than min-y-amount\n        (asserts! (> dy min-y-amount) (err \"err-min-y-amount\"))\n\n        ;; Transfer updated-x-amount tokens from tx-sender to this contract\n        (if (> updated-x-amount u0) \n            (unwrap! (stx-transfer? updated-x-amount swapper (as-contract tx-sender)) (err \"err-transferring-token-x\"))\n            false\n        )\n\n        ;; Transfer x-amount-fee-lps tokens from tx-sender to staking-and-rewards-contract\n        (if (> x-amount-fee-lps u0) \n            (unwrap! (stx-transfer? x-amount-fee-lps swapper (var-get staking-and-rewards-contract)) (err \"err-transferring-token-x-fee-lps\"))\n            false\n        )\n\n        ;; Transfer x-amount-fee-stacking-dao tokens from tx-sender to stacking-dao-address\n        (if (> x-amount-fee-stacking-dao u0)\n            (unwrap! (stx-transfer? x-amount-fee-stacking-dao swapper (var-get stacking-dao-contract)) (err \"err-transferring-token-x-fee-stacking-dao\"))\n            false\n        )\n\n        ;; Transfer x-amount-fee-biflow tokens from tx-sender to bitflow-address\n        (if (> x-amount-fee-bitflow u0)\n            (unwrap! (stx-transfer? x-amount-fee-bitflow swapper (var-get bitflow-contract)) (err \"err-transferring-token-x-fee-bitflow\"))\n            false\n        )\n\n        ;; Transfer dy tokens from this contract to tx-sender\n        (if (> dy u0) \n            (unwrap! (as-contract (contract-call? y-token transfer dy tx-sender swapper none)) (err \"err-transferring-token-y\")) \n            false\n        )\n\n        ;; Update all appropriate maps\n        ;; Update PairsDataMap\n        (map-set PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)} (merge \n            pair-data \n            {\n                balance-x: updated-x-balance,\n                balance-y: new-y,\n                d: (get-D updated-x-balance-scaled new-y-scaled (* (get amplification-coefficient pair-data) number-of-tokens))\n            }\n        ))\n\n        ;; Match if map-get? returns some for CycleDataMap\n        (match (map-get? CycleDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle-num: (get-current-cycle)})\n            cycle-data\n                ;; Update CycleDataMap\n                (map-set CycleDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle-num: (get-current-cycle)} (merge \n                    cycle-data \n                    {\n                        cycle-fee-balance-x: (+ (get cycle-fee-balance-x cycle-data) x-amount-fee-lps)\n                    }\n                ))\n                ;; Create new CycleDataMap\n                (map-set CycleDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle-num: (get-current-cycle)} {\n                    cycle-fee-balance-x: x-amount-fee-lps,\n                })\n        )\n\n        ;; Return the number of y tokens returned from the swap\n        (ok dy)\n\n    )\n)\n;; Swap Y -> X\n;; @desc: Swaps Y token for X token\n;; @params: y-token: principal, lp-token: principal, x-amount: uint, min-x-amount: uint\n(define-public (swap-y-for-x (y-token <sip-010-trait>) (lp-token <lp-trait>) (y-amount uint) (min-x-amount uint)) \n    (let \n        (\n            (swapper tx-sender)\n            (pair-data (unwrap! (map-get? PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-approval (get approval pair-data))\n            (current-balance-x (get balance-x pair-data))\n            (current-balance-y (get balance-y pair-data))\n            (x-decimals (get x-decimals pair-data))\n            (y-decimals (get y-decimals pair-data))\n            ;; Admins pay no fees on swaps\n            (swap-fee-lps (if (is-some (index-of (var-get admins) tx-sender ))\n                (get lps (var-get sell-fees))\n                (get lps (var-get admin-swap-fees))\n            ))\n            (swap-fee-stacking-dao (if (is-some (index-of (var-get admins) tx-sender ))\n                (get stacking-dao (var-get sell-fees))\n                (get stacking-dao (var-get admin-swap-fees))\n            ))\n            (swap-fee-bitflow (if (is-some (index-of (var-get admins) tx-sender ))\n                (get bitflow (var-get sell-fees))\n                (get bitflow (var-get admin-swap-fees))\n            ))\n            (total-swap-fee (+ swap-fee-lps swap-fee-stacking-dao))\n\n            ;; Scale up balances and the swap amount to perform AMM calculations with get-x\n            (scaled-up-balances (get-scaled-up-token-amounts current-balance-x current-balance-y x-decimals y-decimals))\n            (current-balance-x-scaled (get scaled-x scaled-up-balances))\n            (current-balance-y-scaled (get scaled-y scaled-up-balances))\n            (scaled-up-swap-amount (get-scaled-up-token-amounts u0 y-amount x-decimals y-decimals))\n            (y-amount-scaled (get scaled-y scaled-up-swap-amount))\n            (updated-y-balance-scaled (+ current-balance-y-scaled y-amount-scaled))\n            (new-x-scaled (get-x updated-y-balance-scaled current-balance-x-scaled y-amount-scaled (* (get amplification-coefficient pair-data) number-of-tokens)))\n            (new-x (get scaled-x (get-scaled-down-token-amounts new-x-scaled u0 x-decimals y-decimals)))\n            (new-y (+ current-balance-y y-amount))\n\n            ;; Apply fees on the delta in x\n            (dx-without-fees (- current-balance-x new-x)) \n            (x-amount-fee-lps (/ (* dx-without-fees swap-fee-lps) u10000))\n            (x-amount-fee-stacking-dao (/ (* dx-without-fees swap-fee-stacking-dao) u10000))\n            (x-amount-fee-bitflow (/ (* dx-without-fees swap-fee-bitflow) u10000))\n            (dx (- dx-without-fees (+ x-amount-fee-lps x-amount-fee-stacking-dao x-amount-fee-bitflow)))\n        )\n\n        ;; Assert that pair is approved\n        (asserts! current-approval (err \"err-pair-not-approved\"))\n\n        ;; Assert that y-amount is less than x10 of current-balance-y\n        (asserts! (< y-amount (* u10 current-balance-y)) (err \"err-y-amount-too-high\"))\n\n        ;; Assert that dx is greater than min-x-amount\n        (asserts! (> dx min-x-amount) (err \"err-min-x-amount\"))\n\n        ;; Transfer y-amount tokens from tx-sender to this contract\n        (if (> y-amount u0) \n            (unwrap! (contract-call? y-token transfer y-amount swapper (as-contract tx-sender) none) (err \"err-transferring-token-y\"))\n            false\n        )\n\n        ;; Transfer x-amount-fee-lps tokens from this-contract to staking-and-rewards-contract\n        (if (> x-amount-fee-lps u0) \n            (unwrap! (as-contract (stx-transfer? x-amount-fee-lps tx-sender (var-get staking-and-rewards-contract))) (err \"err-transferring-token-x-swap-fee\"))\n            false\n        )\n\n        ;; Transfer x-amount-fee-stacking-dao tokens from this-contract to stacking-dao-address\n        (if (> x-amount-fee-stacking-dao u0) \n            (unwrap! (as-contract (stx-transfer? x-amount-fee-stacking-dao tx-sender (var-get stacking-dao-contract))) (err \"err-transferring-token-x-stacking-dao-fee\"))\n            false\n        )\n\n        ;; Transfer x-amount-fee-bitflow tokens from this-contract to bitflow-address\n        (if (> x-amount-fee-bitflow u0) \n            (unwrap! (as-contract (stx-transfer? x-amount-fee-bitflow tx-sender (var-get bitflow-contract))) (err \"err-transferring-token-x-bitflow-fee\"))\n            false\n        )\n\n        ;; Transfer dx tokens from this contract to tx-sender\n        (if (> dx u0) \n            (unwrap! (as-contract (stx-transfer? dx tx-sender swapper)) (err \"err-transferring-token-x\"))\n            false\n        )\n\n        ;; Update all appropriate maps\n        ;; Update PairsDataMap\n        (map-set PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)} (merge \n            pair-data \n            {\n                balance-x: new-x,\n                balance-y: new-y,\n                d: (get-D new-x-scaled updated-y-balance-scaled (* (get amplification-coefficient pair-data) number-of-tokens))\n            }\n        ))\n\n        ;; Match if map-get? returns some for CycleDataMap\n        (match (map-get? CycleDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle-num: (get-current-cycle)})\n            cycle-data\n                ;; Update CycleDataMap\n                (map-set CycleDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle-num: (get-current-cycle)} (merge \n                    cycle-data \n                    {\n                        cycle-fee-balance-x: (+ (get cycle-fee-balance-x cycle-data) x-amount-fee-lps)\n                    }\n                ))\n                ;; Create new CycleDataMap\n                (map-set CycleDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle-num: (get-current-cycle)} {\n                    cycle-fee-balance-x: x-amount-fee-lps,\n                })\n        )\n\n        ;; Return the number of x tokens returned from the swap\n        (ok dx)\n\n    )\n)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Liquidity Functions ;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Add Liquidity\n;; @desc: Adds liquidity to a pair, mints the appropriate amount of LP tokens\n;; @params:  y-token: principal, lp-token: principal, x-amount-added: uint, y-amount-added: uint\n(define-public (add-liquidity (y-token <sip-010-trait>) (lp-token <lp-trait>) (x-amount-added uint) (y-amount-added uint) (min-lp-amount uint) )\n    (let \n        (\n            ;; Grabbing all data from PairsDataMap\n            (liquidity-provider tx-sender)\n            (current-pair (unwrap! (map-get? PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-approval (get approval current-pair))\n            (x-decimals (get x-decimals current-pair))\n            (y-decimals (get y-decimals current-pair))\n            (current-balance-x (get balance-x current-pair))\n            (new-balance-x (+ current-balance-x x-amount-added))\n            (current-balance-y (get balance-y current-pair))\n            (new-balance-y (+ current-balance-y y-amount-added))\n            (current-total-shares (get total-shares current-pair))\n            (current-amplification-coefficient (get amplification-coefficient current-pair))\n            \n            ;; Scale up for AMM calculations depending on decimal places assigned to tokens\n            (amounts-added-scaled (get-scaled-up-token-amounts x-amount-added y-amount-added x-decimals y-decimals))\n            (x-amount-added-scaled (get scaled-x amounts-added-scaled))\n            (y-amount-added-scaled (get scaled-y amounts-added-scaled))\n            (current-balances-scaled (get-scaled-up-token-amounts current-balance-x current-balance-y x-decimals y-decimals))\n            (current-balance-x-scaled (get scaled-x current-balances-scaled))\n            (current-balance-y-scaled (get scaled-y current-balances-scaled))\n            (new-balances-scaled (get-scaled-up-token-amounts new-balance-x new-balance-y x-decimals y-decimals))\n            (new-balance-x-scaled (get scaled-x new-balances-scaled))\n            (new-balance-y-scaled (get scaled-y new-balances-scaled))\n            \n            ;; Calculating the ideal balance\n            (d0 (get-D current-balance-x-scaled current-balance-y-scaled current-amplification-coefficient))\n            (d1 (get-D new-balance-x-scaled new-balance-y-scaled current-amplification-coefficient))\n            (ideal-balance-x-scaled (/ (* d1 current-balance-x-scaled) d0))\n            (ideal-balance-y-scaled (/ (* d1 current-balance-y-scaled) d0))\n            (x-difference (if (> ideal-balance-x-scaled new-balance-x-scaled) (- ideal-balance-x-scaled new-balance-x-scaled) (- new-balance-x-scaled ideal-balance-x-scaled)))\n            (y-difference (if (> ideal-balance-y-scaled new-balance-y-scaled) (- ideal-balance-y-scaled new-balance-y-scaled) (- new-balance-y-scaled ideal-balance-y-scaled)))\n            \n            ;; Fees applied if adding imbalanced liquidity\n            (ideal-x-fee-scaled (/ (* x-difference (var-get liquidity-fees)) u10000))\n            (ideal-y-fee-scaled (/ (* y-difference (var-get liquidity-fees)) u10000))\n            (x-fee-scaled (if (> x-amount-added-scaled ideal-x-fee-scaled) ideal-x-fee-scaled x-amount-added-scaled))\n            (y-fee-scaled (if (> y-amount-added-scaled ideal-y-fee-scaled) ideal-y-fee-scaled y-amount-added-scaled))\n            (x-amount-added-updated-scaled (- x-amount-added-scaled x-fee-scaled))\n            (y-amount-added-updated-scaled (- y-amount-added-scaled y-fee-scaled))\n            (new-balance-x-post-fee-scaled (+ current-balance-x-scaled x-amount-added-updated-scaled))\n            (new-balance-y-post-fee-scaled (+ current-balance-y-scaled y-amount-added-updated-scaled))\n            (d2 (get-D new-balance-x-post-fee-scaled new-balance-y-post-fee-scaled current-amplification-coefficient))\n\n            ;; Scale down for precise token balance updates and transfers\n            (precise-fees (get-scaled-down-token-amounts x-fee-scaled y-fee-scaled x-decimals y-decimals))\n            (x-fee (get scaled-x precise-fees))\n            (y-fee (get scaled-y precise-fees))\n            (amounts-added-scaled-down (get-scaled-down-token-amounts x-amount-added-updated-scaled y-amount-added-updated-scaled x-decimals y-decimals))\n            (x-amount-added-updated (get scaled-x amounts-added-scaled-down))\n            (y-amount-added-updated (get scaled-y amounts-added-scaled-down))\n            (balances-post-fee-scaled-down (get-scaled-down-token-amounts new-balance-x-post-fee-scaled new-balance-y-post-fee-scaled x-decimals y-decimals))\n            (new-balance-x-post-fee (get scaled-x balances-post-fee-scaled-down))\n            (new-balance-y-post-fee (get scaled-y balances-post-fee-scaled-down))\n        )\n\n        ;; Assert that pair is approved\n        (asserts! current-approval (err \"err-pair-not-approved\"))\n\n        ;; Assert that either x-amount-added or y-amount-added is greater than 0\n        (asserts! (or (> x-amount-added u0) (> y-amount-added u0)) (err \"err-x-or-y-amount-added-zero\"))\n\n        ;; Assert that d2 is greater than d0\n        (asserts! (> d2 d0) (err \"err-d2-less-than-d0\"))\n\n        ;; Assert that derived mint amount is greater than min-lp-amount\n        (asserts! (> (/ (* current-total-shares (- d2 d0)) d0) min-lp-amount) (err \"err-derived-amount-less-than-lp\"))\n\n        ;; ;; Transfer x-amount-added tokens from tx-sender to this contract\n        (if (> x-amount-added-updated u0)\n            (unwrap! (stx-transfer? x-amount-added-updated liquidity-provider (as-contract tx-sender)) (err \"err-transferring-token-x-escrow\"))\n            false\n        )\n\n        ;; Transfer y-amount-added tokens from tx-sender to this contract\n        (if (> y-amount-added-updated u0)\n            (unwrap! (contract-call? y-token transfer y-amount-added-updated liquidity-provider (as-contract tx-sender) none) (err \"err-transferring-token-y\"))\n            false\n        )\n        \n        ;; Transfer x-fees tokens from tx-sender to bitflow-address\n        (if (> x-fee u0)\n            (unwrap! (stx-transfer? x-fee liquidity-provider (var-get bitflow-contract)) (err \"err-transferring-token-x-protocol\"))\n            false\n        )\n         ;; Transfer y-fees tokens from tx-sender to bitflow-address\n        (if (> y-fee u0)\n            (unwrap! (contract-call? y-token transfer y-fee liquidity-provider (var-get bitflow-contract) none) (err \"err-transferring-token-y-protocol\"))\n            false\n        )\n\n        ;; Mint LP tokens to tx-sender\n        (unwrap! (as-contract (contract-call? lp-token mint liquidity-provider (/ (* current-total-shares (- d2 d0)) d0))) (err \"err-minting-lp-tokens\"))\n\n        ;; Update all appropriate maps\n        ;; Update PairsDataMap\n        (map-set PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)} \n            (merge \n                current-pair \n                {\n                    balance-x: new-balance-x-post-fee,\n                    balance-y: new-balance-y-post-fee,\n                    total-shares: (+ current-total-shares (/ (* current-total-shares (- d2 d0)) d0)),\n                    d: d2\n                }\n        ))\n        \n        ;; Return the number of LP tokens minted\n        (ok (/ (* current-total-shares (- d2 d0)) d0))\n    )\n)\n\n;; Withdraw Liquidity\n;; @desc: Withdraws liquidity from both pairs & burns the appropriate amount of LP tokens\n;; @params:  y-token: principal, lp-token: principal, lp-amount: uint, min-x-amount: uint, min-y-amount: uint\n(define-public (withdraw-liquidity (y-token <sip-010-trait>) (lp-token <lp-trait>) (lp-amount uint) (min-x-amount uint) (min-y-amount uint))\n    (let \n        (\n            ;; Grabbing all data from PairsDataMap\n            (current-pair (unwrap! (map-get? PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-approval (get approval current-pair))\n            (x-decimals (get x-decimals current-pair))\n            (y-decimals (get y-decimals current-pair))\n            (current-balance-x (get balance-x current-pair))\n            (current-balance-y (get balance-y current-pair))\n            (current-total-shares (get total-shares current-pair))\n            (current-amplification-coefficient (get amplification-coefficient current-pair))\n            (withdrawal-balance-x (/ (* current-balance-x lp-amount) current-total-shares))\n            (withdrawal-balance-y (/ (* current-balance-y lp-amount) current-total-shares))\n            (new-balance-x (- current-balance-x withdrawal-balance-x))\n            (new-balance-y (- current-balance-y withdrawal-balance-y))\n            (liquidity-remover tx-sender)\n            ;; get-D using the new-balance-x and new-balance-y\n            (new-balances-scaled (get-scaled-up-token-amounts new-balance-x new-balance-y x-decimals y-decimals))\n            (new-balance-x-scaled (get scaled-x new-balances-scaled))\n            (new-balance-y-scaled (get scaled-y new-balances-scaled))\n            (new-d (get-D new-balance-x-scaled new-balance-y-scaled current-amplification-coefficient))\n        )\n\n        ;; Assert that withdrawal-balance-x is greater than min-x-amount\n        (asserts! (> withdrawal-balance-x min-x-amount) (err \"err-withdrawal-balance-x-less-than-min-x-amount\"))\n\n        ;; Assert that withdrawal-balance-y is greater than min-y-amount\n        (asserts! (> withdrawal-balance-y min-y-amount) (err \"err-withdrawal-balance-y-less-than-min-y-amount\"))\n\n        ;; Burn LP tokens from tx-sender\n        (unwrap! (contract-call? lp-token burn liquidity-remover lp-amount) (err \"err-burning-lp-tokens\"))\n\n        ;; Transfer withdrawal-balance-x tokens from this contract to liquidity-taker\n        (unwrap! (as-contract (stx-transfer? withdrawal-balance-x  tx-sender liquidity-remover)) (err \"err-transferring-token-x\"))\n        ;; Transfer withdrawal-balance-y tokens from this contract to liquidity-taker\n        (unwrap! (as-contract (contract-call? y-token transfer withdrawal-balance-y tx-sender liquidity-remover none)) (err \"err-transferring-token-y\"))\n\n        ;; Update all appropriate maps\n        ;; Update PairsDataMap\n        (map-set PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)} (merge \n            current-pair \n            {\n                balance-x: new-balance-x,\n                balance-y: new-balance-y,\n                total-shares: (- current-total-shares lp-amount),\n                d: new-d\n            }\n        ))\n\n        ;; Return the number X tokens and Y tokens received after withdrawing from pool\n        (ok {withdrawal-x-balance: withdrawal-balance-x, withdrawal-y-balance: withdrawal-balance-y})\n    )\n)\n\n\n;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;\n;;; AMM Functions ;;;\n;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;\n\n;; D for loop\n;; Get D\n(define-read-only (get-D (x-bal uint) (y-bal uint) (ann uint))\n    (get converged (fold D-for-loop index-list {D: (+ x-bal y-bal), x-bal: x-bal, y-bal: y-bal, ann: ann, converged: u0}))\n)\n\n;; Get D Helper\n(define-private (D-for-loop (n uint) (D-info {D: uint, x-bal: uint, y-bal: uint, ann: uint, converged: uint})) \n    (let \n        (\n            ;; Grabbing everything from D-info\n            (current-D-partial (get D D-info))\n            (current-D (get D D-info))\n            (current-x-bal (get x-bal D-info))\n            (current-y-bal (get y-bal D-info))\n            (current-S (+ current-x-bal current-y-bal))\n            (current-ann (get ann D-info))\n            (current-converged (get converged D-info))\n\n            ;; Start logic for calculating new D\n            ;; Calculate new partial D with respect to x\n            (new-D-partial-x (/ (* current-D current-D-partial) (* u2 current-x-bal)))\n            ;; Calculate new partial D with respect to now x & y\n            (new-D-partial (/ (* current-D new-D-partial-x ) (* u2 current-y-bal)))\n\n            (new-numerator (* (+ (* current-ann current-S) (* number-of-tokens new-D-partial)) current-D))\n            (new-denominator (+ (* (- current-ann u1) current-D) (* (+ number-of-tokens u1 ) new-D-partial)))\n\n            (new-D (/ new-numerator new-denominator))\n            (threshold (var-get convergence-threshold))\n\n            \n        )\n        \n        ;; Check if converged value / new D was already found\n        (if (is-eq current-converged u0)\n            (if (> new-D  current-D)\n                (if (<= (- new-D current-D) threshold)\n                    {D: new-D, x-bal: current-x-bal, y-bal: current-y-bal, ann: current-ann, converged: new-D}\n                    {D: new-D, x-bal: current-x-bal, y-bal: current-y-bal, ann: current-ann, converged: u0}\n                )\n                (if (<= (- current-D new-D) threshold)\n                    {D: new-D, x-bal: current-x-bal, y-bal: current-y-bal, ann: current-ann, converged: new-D}\n                    {D: new-D, x-bal: current-x-bal, y-bal: current-y-bal, ann: current-ann, converged: u0}\n                )\n            )\n            D-info\n        )\n    \n    )\n)\n\n;; Scale up the token amounts to the same level of precision before performing AMM calculations\n;; @params: x-amount-unscaled: uint, y-amount-unscaled:uint, x-num-decimals: uint, y-num-decimals: uint\n(define-private (get-scaled-up-token-amounts (x-amount-unscaled uint) (y-amount-unscaled uint) (x-num-decimals uint) (y-num-decimals uint))\n    (let \n        (\n            (scaled-x \n                ;; if same number of decimals, set to x-amount-unscaled\n                (if (is-eq x-num-decimals y-num-decimals)\n                    x-amount-unscaled\n                    ;; if x has more decimals, set to x-amount-unscaled; otherwise scale up by the difference in decimals\n                    (if (> x-num-decimals y-num-decimals) x-amount-unscaled (* x-amount-unscaled (pow u10 (- y-num-decimals x-num-decimals))))\n                )\n            )\n            (scaled-y \n                ;; if same number of decimals, set to y-amount-unscaled\n                (if (is-eq x-num-decimals y-num-decimals)\n                    y-amount-unscaled\n                    ;; if y has more decimals, set to y-amount-unscaled; otherwise scale up by the difference in decimals\n                    (if (> y-num-decimals x-num-decimals) y-amount-unscaled (* y-amount-unscaled (pow u10 (- x-num-decimals y-num-decimals))))\n                )\n            )\n        )\n        {scaled-x: scaled-x, scaled-y: scaled-y}\n    )\n)\n\n;; Scale down the token amounts to their respective levels of precision before performing any transfers\n;; @params: x-amount-scaled: uint, y-amount-scaled:uint, x-num-decimals: uint, y-num-decimals: uint\n(define-private (get-scaled-down-token-amounts (x-amount-scaled uint) (y-amount-scaled uint) (x-num-decimals uint) (y-num-decimals uint))\n    (let \n        (\n            (scaled-x \n                ;; if same number of decimals, set to x-amount-scaled\n                (if (is-eq x-num-decimals y-num-decimals)\n                    x-amount-scaled\n                    ;; if x has more decimals, set to x-amount-scaled; otherwise scale down by the difference in decimals\n                    (if (> x-num-decimals y-num-decimals) x-amount-scaled (/ x-amount-scaled (pow u10 (- y-num-decimals x-num-decimals))))\n                )\n            )\n            (scaled-y \n                ;; if same number of decimals, set to y-amount-scaled\n                (if (is-eq x-num-decimals y-num-decimals)\n                    y-amount-scaled\n                    ;; if y has more decimals, set to y-amount-scaled; otherwise scale down by the difference in decimals\n                    (if (> y-num-decimals x-num-decimals) y-amount-scaled (/ y-amount-scaled (pow u10 (- x-num-decimals y-num-decimals))))\n                )\n            )\n        )\n        {scaled-x: scaled-x, scaled-y: scaled-y}\n    )\n)\n\n;; @desc - Helper function for removing a admin\n(define-private (is-not-removeable (admin principal))\n  (not (is-eq admin (var-get helper-principal)))\n)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Goverance Functions ;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Create Pair\n;; @desc: Creates a new pair for trading\n;; @params:  y-token: principal, lp-token: principal, amplification-coefficient: uint, pair-name: string, x-balance: uint, y-balance: uint\n(define-public (create-pair (y-token <sip-010-trait>) (lp-token <lp-trait>) (amplification-coefficient uint) (pair-name (string-ascii 32)) (initial-x-bal uint) (initial-y-bal uint))\n    (let \n        (\n            (lp-owner tx-sender)\n            (x-decimals u6) ;; STX token has precision of 6 decimals\n            (y-decimals (unwrap! (contract-call? y-token get-decimals) (err \"err-getting-y-decimals\")))\n            (scaled-up-balances (get-scaled-up-token-amounts initial-x-bal initial-y-bal x-decimals y-decimals))\n            (initial-x-bal-scaled (get scaled-x scaled-up-balances))\n            (initial-y-bal-scaled (get scaled-y scaled-up-balances))\n        )\n\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of (var-get admins) tx-sender )) (err \"err-not-admin\"))\n\n        ;; Assert using and that the pair does not already exist using is-none & map-get?\n        (asserts! (is-none (map-get? PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)})) (err \"err-pair-xy-or-yx-exists\"))\n\n        ;; Assert that both initial balances are greater than 0\n        (asserts! (or (> initial-x-bal u0) (> initial-y-bal u0)) (err \"err-initial-bal-zero\"))\n\n        ;; Assert that x & y tokens are the same\n        (asserts! (is-eq initial-x-bal-scaled initial-y-bal-scaled) (err \"err-initial-bal-odd\"))\n\n        ;; Mint LP tokens to tx-sender\n        (unwrap! (as-contract (contract-call? lp-token mint lp-owner (+ initial-x-bal-scaled initial-y-bal-scaled))) (err \"err-minting-lp-tokens\"))\n\n        ;; Transfer token x liquidity to this contract\n        (unwrap! (stx-transfer? initial-x-bal tx-sender (as-contract tx-sender)) (err \"err-transferring-token-x\"))\n\n        ;; Transfer token y liquidity to this contract\n        (unwrap! (contract-call? y-token transfer initial-y-bal tx-sender (as-contract tx-sender) none) (err \"err-transferring-token-y\"))\n\n        ;; Update all appropriate maps\n        (ok (map-set PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)} {\n            approval: true,\n            total-shares: (+ initial-x-bal-scaled initial-y-bal-scaled),\n            x-decimals: x-decimals,\n            y-decimals: y-decimals,\n            balance-x: initial-x-bal,\n            balance-y: initial-y-bal,\n            d: (+ initial-x-bal-scaled initial-y-bal-scaled),\n            amplification-coefficient: amplification-coefficient,\n        }))\n    )\n)\n\n\n;; Setting Pair Approval\n;; @desc: Sets the approval of a pair\n;; @params:  y-token: principal, lp-token: principal, approval: bool\n(define-public (set-pair-approval (y-token <sip-010-trait>) (lp-token <lp-trait>) (approval bool))\n    (let \n        (\n            (current-pair (unwrap! (map-get? PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n        )\n\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of (var-get admins) tx-sender)) (err \"err-not-admin\"))\n\n        ;; Update all appropriate maps\n        (ok (map-set PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)} (merge \n            current-pair\n            {\n                approval: approval\n            }\n        )))\n    )\n)\n\n;; Add Admin\n;; @desc: Adds an admin to the admins var list\n;; @params: admin: principal\n(define-public (add-admin (admin principal))\n    (let \n        (\n            (current-admins (var-get admins))\n            ;;(new-admins (unwrap! (as-max-len? (append current-admins admin) u5) (\"err-add-admin-overflow\")))\n        )\n\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        ;; Assert that admin is not already an admin using is-none & index-of with the admins var\n        (asserts! (is-none (index-of current-admins admin)) (err \"err-already-admin\"))\n\n        ;; Update all appropriate maps\n        (ok (var-set admins (unwrap! (as-max-len? (append current-admins admin) u5) (err \"err-admin-overflow\"))))\n    )\n)\n\n;; Remove admin\n(define-public (remove-admin (admin principal))\n  (let\n    (\n      (current-admin-list (var-get admins))\n      (caller-principal-position-in-list (index-of current-admin-list tx-sender))\n      (removeable-principal-position-in-list (index-of current-admin-list admin))\n    )\n\n    ;; asserts tx-sender is an existing whitelist address\n    (asserts! (is-some caller-principal-position-in-list) (err \"err-not-auth\"))\n\n    ;; asserts param principal (removeable whitelist) already exist\n    (asserts! (is-some removeable-principal-position-in-list) (err \"err-not-whitelisted\"))\n\n    ;; asserts the initial contract deployer cannot be removed from admin list to protect against rogue admins\n    (asserts! (not (is-eq admin contract-deployer)) (err \"err-cannot-remove-contract-deployer\"))\n\n    ;; temporary var set to help remove param principal\n    (var-set helper-principal admin)\n\n    ;; filter existing whitelist address\n    (ok \n      (var-set admins (filter is-not-removeable current-admin-list))\n    )\n  )\n)\n\n;; Change Swap Fee\n(define-public (change-buy-fee (new-lps-fee uint) (new-protocol-fee uint) (new-bitflow-fee uint)) \n    (let \n        (\n            (current-admins (var-get admins))\n        )\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        (ok (var-set buy-fees {lps: new-lps-fee, stacking-dao: new-protocol-fee, bitflow: new-bitflow-fee}))\n    )\n)\n\n;; Change Swap Fee\n(define-public (change-sell-fee (new-lps-fee uint) (new-protocol-fee uint) (new-bitflow-fee uint)) \n    (let \n        (\n            (current-admins (var-get admins))\n        )\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        (ok (var-set sell-fees {lps: new-lps-fee, stacking-dao: new-protocol-fee, bitflow: new-bitflow-fee}))\n    )\n)\n\n;; Change Swap Fee\n(define-public (change-admin-swap-fee (new-lps-fee uint) (new-protocol-fee uint) (new-bitflow-fee uint)) \n    (let \n        (\n            (current-admins (var-get admins))\n        )\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        (ok (var-set admin-swap-fees {lps: new-lps-fee, stacking-dao: new-protocol-fee, bitflow: new-bitflow-fee}))\n    )\n)\n\n;; Change Liquidity Fee\n(define-public (change-liquidity-fee (new-liquidity-fee uint)) \n    (let \n        (\n            (current-admins (var-get admins))\n        )\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        (ok (var-set liquidity-fees new-liquidity-fee))\n    )\n)\n\n;; Admins can change the amplification coefficient in PairsDataMap\n;; @params:  y-token: principal, lp-token: principal, amplification-coefficient: uint\n(define-public (change-amplification-coefficient (y-token <sip-010-trait>) (lp-token <lp-trait>) (amplification-coefficient uint))\n    (let \n        (\n            (current-pair (unwrap! (map-get? PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-admins (var-get admins))\n        )\n\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        ;; Update all appropriate maps\n        (ok (map-set PairsDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)} (merge \n            current-pair\n            {\n                amplification-coefficient: amplification-coefficient\n            }\n        )))\n    )\n)\n\n;; Change Convergence Threshold \n(define-public (change-convergence-threshold (new-convergence-threshold uint)) \n    (let \n        (\n            (current-admins (var-get admins))\n        )\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        (ok (var-set convergence-threshold new-convergence-threshold))\n    )\n)\n\n;; Admins can set the contract for handling staking and liquidity provider rewards\n;; @params: staking-contract: principal\n(define-public (set-staking-contract (staking-contract principal))\n    (let \n        (\n            (current-admins (var-get admins))\n            (is-set (var-get staking-and-rewards-contract-is-set))\n        )\n\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        ;; Assert that the staking-and-rewards contract has not already been set\n        (asserts! (not is-set) (err \"err-staking-and-rewards-contract-already-assigned\"))\n\n        ;; Set contract for handling staking and rewards\n        (var-set staking-and-rewards-contract staking-contract)\n        (var-set staking-and-rewards-contract-is-set true)\n\n        ;; Set contract for handling staking and rewards\n        (ok staking-contract)\n    )\n)\n\n;; Admins can set the contract for the stacking dao to collect fees\n;; @params: stacking-dao-contract: principal\n(define-public (set-stacking-dao-contract (stacking-dao-address principal))\n    (let \n        (\n            (current-admins (var-get admins))\n        )\n\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        ;; Set contract for handling staking and rewards\n        (ok (var-set stacking-dao-contract stacking-dao-address))\n    )\n)\n\n;; Admins can set the contract for bitflow protocol to collect fees\n;; @params: bitflow-contract: principal\n(define-public (set-bitflow-contract (bitflow-address principal))\n    (let \n        (\n            (current-admins (var-get admins))\n        )\n\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        ;; Set contract for handling staking and rewards\n        (ok (var-set bitflow-contract bitflow-address))\n    )\n)\n",
    "analysis": {
      "summary": "This contract implements the core logic for a Stableswap protocol, facilitating swaps, liquidity provision, and governance for a stSTX/STX trading pair.",
      "explanation": "The contract starts by importing necessary traits for fungible tokens and liquidity provider tokens <L12-13>. It defines constants for the contract's address, deployment height, cycle length, a list for Newton-Raphson method iterations, the number of tokens in a pair, and the contract deployer <L19-35>. Variables include addresses for staking rewards, DAO, Bitflow protocol, admin governance, swap fees, liquidity fees, a helper for admin removal, and a convergence threshold <L46-77>. Maps are used to store pair and cycle data <L84-97>.\n\nRead-only functions provide data access for pair and cycle information, current cycle calculations based on block height, and swap calculations <L107-308>. Swap functions allow users to exchange tokens, incorporating fees and updating balances accordingly <L318-557>. Liquidity functions enable adding or withdrawing liquidity, minting, or burning LP tokens while adjusting balances <L565-738>.\n\nAMM functions calculate token amounts for swaps and liquidity operations using the Newton-Raphson method and scaling for token decimal differences <L747-849>. Governance functions allow admins to create trading pairs, set approvals, adjust fees, and manage admin roles <L858-1124>.\n\nNotable qualities include the use of the Newton-Raphson method for precise mathematical calculations, a detailed governance model for protocol management, and the incorporation of fees for liquidity providers, a DAO, and the Bitflow protocol.",
      "tags": ["DeFi", "DEX", "governance", "utility"]
    }
  },
  {
    "rank": 8,
    "contract": "SP1NAZ59R1ED0V6NH9N0EQBEB3MKT48CQCMKC5Q41.swap-router-v21",
    "calls": 6086,
    "source": "(use-trait et 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.extension-trait.extension-trait) (impl-trait 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.extension-trait.extension-trait) (define-constant E8 u100000000) (define-read-only (s2e (n uint)) (* n u100)) (define-public (i1 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5k0yl5ot8l (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u1)) (ok u0))) (define-public (o1 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5k0yl5ot8l in u1)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i2 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda u5000000 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o2 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda u5000000 (s2e (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (ok u0))) (define-public (i3 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender))) none)) (ok u0))) (define-public (o3 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e in) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i4 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnyc E8 (s2e in) none)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kielx1jn7 (unwrap-panic (contract-call? 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 get-balance tx-sender)) u1)) (ok u0))) (define-public (o4 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kielx1jn7 in u1)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnyc E8 (s2e (unwrap-panic (contract-call? 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 get-balance tx-sender))) none)) (ok u0))) (define-public (i5 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wdiko E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o5 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wdiko E8 (s2e (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (i6 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o6 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda E8 (s2e (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (i7 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token in u0)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kt9nmle8c (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u1)) (ok u0))) (define-public (o7 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kt9nmle8c in u1)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i8 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-stx-stsw in u1)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kbe3oqvac (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a get-balance tx-sender)) u1)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender))) none)) (ok u0))) (define-public (o8 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e in) none)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kbe3oqvac (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)) u1)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-stx-stsw (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a get-balance tx-sender)) u1)) (ok u0))) (define-public (i9 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u27 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender))) none)) (ok u0))) (define-public (o9 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e in) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u27 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)) u1 )) (ok u0))) (define-public (i10 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) none)) (ok u0))) (define-public (o10 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (s2e in) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i11 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o11 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token in u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i12 (in uint)) (begin (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-x-for-y 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc in u1)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u22 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u21 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token get-balance tx-sender)) u1 )) (ok u0))) (define-public (o12 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u21 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u22 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token get-balance tx-sender)) u1 )) (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-y-for-x 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1)) (ok u0))) (define-public (i13 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (unwrap-panic (contract-call? 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-usda-aeusdc-v-1-4 swap-y-for-x 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.usda-aeusdc-lp-token-v-1-4 (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (unwrap-panic (contract-call? 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-usda-aeusdc-v-1-2 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.usda-aeusdc-lp-token-v-1-2 (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0))) (define-public (o13 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (unwrap-panic (contract-call? 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-usda-aeusdc-v-1-2 swap-y-for-x 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.usda-aeusdc-lp-token-v-1-2 (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (unwrap-panic (contract-call? 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-usda-aeusdc-v-1-4 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.usda-aeusdc-lp-token-v-1-4 (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0))) (define-public (i14 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u11 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wpepe E8 (* u100000 (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (o14 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wpepe E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u11 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz get-balance tx-sender)) u1 )) (ok u0))) (define-public (i15 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc u5000000 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) none)) (ok u0))) (define-public (o15 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc u5000000 (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc get-balance tx-sender)) none)) (ok u0))) (define-public (i16 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd u5000000 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt get-balance tx-sender)) none)) (ok u0))) (define-public (o16 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd u5000000 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (ok u0))) (define-public (i17 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wleo E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u28 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token get-balance tx-sender)) u1 )) (ok u0))) (define-public (o17 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u28 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wleo E8 (s2e (unwrap-panic (contract-call? 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (i18 (in uint)) (begin (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-x-for-y 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc in u1)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-waeusdc E8 (s2e (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender))) none)) (ok u0))) (define-public (o18 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-waeusdc E8 (s2e in) none)) (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-y-for-x 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1)) (ok u0))) (define-public (i19 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-y-for-x 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1)) (ok u0))) (define-public (o19 (in uint)) (begin (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-x-for-y 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc in u1)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0))) (define-public (i20 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (s2e in) none)) (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.migrate-wrapped migrate)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt get-balance tx-sender)) none)) (ok u0))) (define-public (o20 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (s2e in) none)) (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.migrate-wrapped migrate)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc get-balance tx-sender)) none)) (ok u0))) (define-public (i21 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wgoat E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u36 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx get-balance tx-sender)) u1 )) (ok u0))) (define-public (o21 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u36 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wgoat E8 (s2e (unwrap-panic (contract-call? 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (i22 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnot E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u16 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope 'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope get-balance tx-sender)) u1 )) (ok u0))) (define-public (o22 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u16 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnot E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnot get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (i23 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-pool-v1_0_0-0003 swap 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3W69VDG9VTZNG7NTW1QNCC1W45SNY98W1JSZBJH.flat-earth-stxcity 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-fees-v1_0_0-0003 in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2SF8P7AKN8NYHD57T96C51RRV9M0GKRN02BNHD2.token-wflat E8 (s2e (unwrap-panic (contract-call? 'SP3W69VDG9VTZNG7NTW1QNCC1W45SNY98W1JSZBJH.flat-earth-stxcity get-balance tx-sender))) none)) (ok u0))) (define-public (o23 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2SF8P7AKN8NYHD57T96C51RRV9M0GKRN02BNHD2.token-wflat E8 (s2e in) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-pool-v1_0_0-0003 swap 'SP3W69VDG9VTZNG7NTW1QNCC1W45SNY98W1JSZBJH.flat-earth-stxcity 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-fees-v1_0_0-0003 (unwrap-panic (contract-call? 'SP3W69VDG9VTZNG7NTW1QNCC1W45SNY98W1JSZBJH.flat-earth-stxcity get-balance tx-sender)) u1 )) (ok u0))) (define-public (callback (p principal) (bp (buff 2048))) (let ((enc (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? bp u0 u16)) u16)))) (bh (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? bp u16 u20)) u4)))) (addr (get hashbytes (unwrap-panic (element-at? (get addrs (unwrap-panic (get-burn-block-info? pox-addrs bh))) u0)))) (di (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? addr u0 u4)) u4)))) (do (mod enc (+ di u4280000000 b0))) (c (mod do u100)) (in (* do u100)) (ts (if (< c u30) (if (<= c u11) (list (if (is-eq c u1) (i1 in) (err u0)) (if (is-eq c u2) (i2 in) (err u0)) (if (is-eq c u3) (i3 in) (err u0)) (if (is-eq c u4) (i4 in) (err u0)) (if (is-eq c u5) (i5 in) (err u0)) (if (is-eq c u6) (i6 in) (err u0)) (if (is-eq c u7) (i7 in) (err u0)) (if (is-eq c u8) (i8 in) (err u0)) (if (is-eq c u9) (i9 in) (err u0)) (if (is-eq c u10) (i10 in) (err u0)) (if (is-eq c u11) (i11 in) (err u0))) (list (if (is-eq c u12) (i12 in) (err u0)) (if (is-eq c u13) (i13 in) (err u0)) (if (is-eq c u14) (i14 in) (err u0)) (if (is-eq c u15) (i15 in) (err u0)) (if (is-eq c u16) (i16 in) (err u0)) (if (is-eq c u17) (i17 in) (err u0)) (if (is-eq c u18) (i18 in) (err u0)) (if (is-eq c u19) (i19 in) (err u0)) (if (is-eq c u20) (i20 in) (err u0)) (if (is-eq c u21) (i21 in) (err u0)) (if (is-eq c u22) (i22 in) (err u0)) (if (is-eq c u23) (i23 in) (err u0)))) (if (<= c u41) (list (if (is-eq c u31) (o1 in) (err u0)) (if (is-eq c u32) (o2 in) (err u0)) (if (is-eq c u33) (o3 in) (err u0)) (if (is-eq c u34) (o4 in) (err u0)) (if (is-eq c u35) (o5 in) (err u0)) (if (is-eq c u36) (o6 in) (err u0)) (if (is-eq c u37) (o7 in) (err u0)) (if (is-eq c u38) (o8 in) (err u0)) (if (is-eq c u39) (o9 in) (err u0)) (if (is-eq c u40) (o10 in) (err u0)) (if (is-eq c u41) (o11 in) (err u0))) (list (if (is-eq c u42) (o12 in) (err u0)) (if (is-eq c u43) (o13 in) (err u0)) (if (is-eq c u44) (o14 in) (err u0)) (if (is-eq c u45) (o15 in) (err u0)) (if (is-eq c u46) (o16 in) (err u0)) (if (is-eq c u47) (o17 in) (err u0)) (if (is-eq c u48) (o18 in) (err u0)) (if (is-eq c u49) (o19 in) (err u0)) (if (is-eq c u50) (o20 in) (err u0)) (if (is-eq c u51) (o21 in) (err u0)) (if (is-eq c u52) (o22 in) (err u0)) (if (is-eq c u53) (o23 in) (err u0))))))) (ok true))) (define-private (ee (bp (buff 2048)) (t <et>)) (as-contract (begin (asserts! (is-eq tx-sender (contract-of t)) (err u0)) (try! (contract-call? 'SPB75ZW15C90ZNDPQF4GSVNGBEJJA6WACZKNFVFK.vault-v1 flash-loan-stx t (stx-get-balance 'SPB75ZW15C90ZNDPQF4GSVNGBEJJA6WACZKNFVFK.vault-v1) tx-sender bp)) (let ((ba (stx-get-balance tx-sender))) (and (> ba u0) (try! (stx-transfer? ba tx-sender 'SP1VSDGJ3RCR2K8V1SY5DGNR733YACKPXPHEMXTFD)))) (ok true)))) (define-constant b0 block-height) (define-public (r0 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r1 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r2 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r3 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r4 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r5 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r6 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r7 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r8 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r9 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ra (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rb (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rc (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rd (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (re (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rf (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rg (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rh (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ri (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rj (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rk (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rl (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rm (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rn (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ro (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rp (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rq (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rr (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rs (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rt (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ru (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rv (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rw (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rx (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ry (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rz (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (w0 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (w1 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (w2 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (w3 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (w4 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (w5 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (w6 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (w7 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (w8 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (w9 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wa (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wb (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wc (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wd (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (we (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wf (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wg (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wh (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wi (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wj (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wk (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wl (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wm (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wn (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wo (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wp (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wq (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wr (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ws (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wt (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wu (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wv (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ww (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wx (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wy (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (wz (bp (buff 2048)) (t <et>)) (ee bp t))",
    "analysis": {
      "summary": "This contract performs complex token swaps across multiple protocols and implements a callback mechanism for flash loans.",
      "explanation": "The contract is designed to interact with various decentralized finance (DeFi) protocols on the Stacks blockchain to perform token swaps and leverage flash loans. It uses a callback mechanism to execute code after receiving a flash loan, allowing for arbitrage or other financial strategies within a single transaction. The contract is highly modular, with functions dedicated to specific swap paths or strategies, and it implements a trait for extension purposes.\n\n1. Constants and Data Vars:\n- `E8` <L3> is a constant used for decimal precision adjustments in token amounts.\n- `b0` <L242> stores the block height at the time of contract deployment, possibly for timestamping or versioning purposes.\n\n2. Functions:\n- `s2e` <L4> is a utility function to scale a uint by 100, likely for adjusting token amounts.\n- `i1` to `i23` <L5-227> and `o1` to `o23` <L228-450> are public functions designed for swapping tokens across different protocols. Each function follows a specific swap path, interacting with external contracts. The exact logic involves calling other contracts' swap functions and handling the returned values or errors.\n- `callback` <L451-487> is a complex function intended to be called by other contracts as part of a flash loan operation. It decodes the passed buffer to determine the operation to perform and executes the corresponding swap function.\n- `ee` <L488-499> is a private function that handles the execution of flash loans, ensuring that the caller is authorized and that the loan is repaid.\n- `r0` to `wz` <L500-571> are public functions that wrap the `ee` function for different use cases or tokens, possibly to provide a standardized interface for flash loans.\n\nNotable Qualities:\n- The contract integrates with multiple DeFi protocols, showcasing the composability of financial primitives on the Stacks blockchain.\n- It employs a sophisticated callback mechanism to perform actions after receiving a flash loan, a feature commonly seen in DeFi applications for arbitrage.\n- The contract's design is modular, with a clear separation between the logic for different swap paths, making it easier to extend or update.\n- The use of a trait (`et`) and its implementation suggests a pattern for extending the contract's functionality, possibly for adding new swap strategies or integrating with additional protocols.",
      "tags": ["DeFi", "swap", "flash-loan", "protocol"]
    }
  },
  {
    "rank": 9,
    "contract": "SP000000000000000000002Q6VF78.pox-4",
    "calls": 5531,
    "source": ";; The .pox-4 contract\n;; Error codes\n(define-constant ERR_STACKING_UNREACHABLE 255)\n(define-constant ERR_STACKING_CORRUPTED_STATE 254)\n(define-constant ERR_STACKING_INSUFFICIENT_FUNDS 1)\n(define-constant ERR_STACKING_INVALID_LOCK_PERIOD 2)\n(define-constant ERR_STACKING_ALREADY_STACKED 3)\n(define-constant ERR_STACKING_NO_SUCH_PRINCIPAL 4)\n(define-constant ERR_STACKING_EXPIRED 5)\n(define-constant ERR_STACKING_STX_LOCKED 6)\n(define-constant ERR_STACKING_PERMISSION_DENIED 9)\n(define-constant ERR_STACKING_THRESHOLD_NOT_MET 11)\n(define-constant ERR_STACKING_POX_ADDRESS_IN_USE 12)\n(define-constant ERR_STACKING_INVALID_POX_ADDRESS 13)\n\n(define-constant ERR_STACKING_INVALID_AMOUNT 18)\n(define-constant ERR_NOT_ALLOWED 19)\n(define-constant ERR_STACKING_ALREADY_DELEGATED 20)\n(define-constant ERR_DELEGATION_EXPIRES_DURING_LOCK 21)\n(define-constant ERR_DELEGATION_TOO_MUCH_LOCKED 22)\n(define-constant ERR_DELEGATION_POX_ADDR_REQUIRED 23)\n(define-constant ERR_INVALID_START_BURN_HEIGHT 24)\n(define-constant ERR_NOT_CURRENT_STACKER 25)\n(define-constant ERR_STACK_EXTEND_NOT_LOCKED 26)\n(define-constant ERR_STACK_INCREASE_NOT_LOCKED 27)\n(define-constant ERR_DELEGATION_NO_REWARD_SLOT 28)\n(define-constant ERR_DELEGATION_WRONG_REWARD_SLOT 29)\n(define-constant ERR_STACKING_IS_DELEGATED 30)\n(define-constant ERR_STACKING_NOT_DELEGATED 31)\n(define-constant ERR_INVALID_SIGNER_KEY 32)\n(define-constant ERR_REUSED_SIGNER_KEY 33)\n(define-constant ERR_DELEGATION_ALREADY_REVOKED 34)\n(define-constant ERR_INVALID_SIGNATURE_PUBKEY 35)\n(define-constant ERR_INVALID_SIGNATURE_RECOVER 36)\n(define-constant ERR_INVALID_REWARD_CYCLE 37)\n(define-constant ERR_SIGNER_AUTH_AMOUNT_TOO_HIGH 38)\n(define-constant ERR_SIGNER_AUTH_USED 39)\n(define-constant ERR_INVALID_INCREASE 40)\n\n;; Valid values for burnchain address versions.\n;; These first four correspond to address hash modes in Stacks 2.1,\n;; and are defined in pox-mainnet.clar and pox-testnet.clar (so they\n;; cannot be defined here again).\n(define-constant ADDRESS_VERSION_P2PKH 0x00)\n(define-constant ADDRESS_VERSION_P2SH 0x01)\n(define-constant ADDRESS_VERSION_P2WPKH 0x02)\n(define-constant ADDRESS_VERSION_P2WSH 0x03)\n(define-constant ADDRESS_VERSION_NATIVE_P2WPKH 0x04)\n(define-constant ADDRESS_VERSION_NATIVE_P2WSH 0x05)\n(define-constant ADDRESS_VERSION_NATIVE_P2TR 0x06)\n\n;; Values for stacks address versions\n(define-constant STACKS_ADDR_VERSION_MAINNET 0x16)\n(define-constant STACKS_ADDR_VERSION_TESTNET 0x1a)\n\n;; Keep these constants in lock-step with the address version buffs above\n;; Maximum value of an address version as a uint\n(define-constant MAX_ADDRESS_VERSION u6)\n;; Maximum value of an address version that has a 20-byte hashbytes\n;; (0x00, 0x01, 0x02, 0x03, and 0x04 have 20-byte hashbytes)\n(define-constant MAX_ADDRESS_VERSION_BUFF_20 u4)\n;; Maximum value of an address version that has a 32-byte hashbytes\n;; (0x05 and 0x06 have 32-byte hashbytes)\n(define-constant MAX_ADDRESS_VERSION_BUFF_32 u6)\n\n;; PoX mainnet constants\n;; Min/max number of reward cycles uSTX can be locked for\n(define-constant MIN_POX_REWARD_CYCLES u1)\n(define-constant MAX_POX_REWARD_CYCLES u12)\n\n;; Default length of the PoX registration window, in burnchain blocks.\n(define-constant PREPARE_CYCLE_LENGTH (if is-in-mainnet u100 u50))\n\n;; Default length of the PoX reward cycle, in burnchain blocks.\n(define-constant REWARD_CYCLE_LENGTH (if is-in-mainnet u2100 u1050))\n\n;; Stacking thresholds\n(define-constant STACKING_THRESHOLD_25 (if is-in-mainnet u20000 u8000))\n\n;; SIP18 message prefix\n(define-constant SIP018_MSG_PREFIX 0x534950303138)\n\n;; Data vars that store a copy of the burnchain configuration.\n;; Implemented as data-vars, so that different configurations can be\n;; used in e.g. test harnesses.\n(define-data-var pox-prepare-cycle-length uint PREPARE_CYCLE_LENGTH)\n(define-data-var pox-reward-cycle-length uint REWARD_CYCLE_LENGTH)\n(define-data-var first-burnchain-block-height uint u0)\n(define-data-var configured bool false)\n(define-data-var first-pox-4-reward-cycle uint u0)\n\n;; This function can only be called once, when it boots up\n(define-public (set-burnchain-parameters (first-burn-height uint)\n                                         (prepare-cycle-length uint)\n                                         (reward-cycle-length uint)\n                                         (begin-pox-4-reward-cycle uint))\n    (begin\n        (asserts! (not (var-get configured)) (err ERR_NOT_ALLOWED))\n        (var-set first-burnchain-block-height first-burn-height)\n        (var-set pox-prepare-cycle-length prepare-cycle-length)\n        (var-set pox-reward-cycle-length reward-cycle-length)\n        (var-set first-pox-4-reward-cycle begin-pox-4-reward-cycle)\n        (var-set configured true)\n        (ok true))\n)\n\n;; The Stacking lock-up state and associated metadata.\n;; Records are inserted into this map via `stack-stx`, `delegate-stack-stx`, `stack-extend`\n;;  `delegate-stack-extend` and burnchain transactions for invoking `stack-stx`, etc.\n;; Records will be deleted from this map when auto-unlocks are processed\n;;\n;; This map de-normalizes some state from the `reward-cycle-pox-address-list` map\n;;  and the `pox-4` contract tries to keep this state in sync with the reward-cycle\n;;  state. The major invariants of this `stacking-state` map are:\n;;    (1) any entry in `reward-cycle-pox-address-list` with `some stacker` points to a real `stacking-state`\n;;    (2) `stacking-state.reward-set-indexes` matches the index of that `reward-cycle-pox-address-list`\n;;    (3) all `stacking-state.reward-set-indexes` match the index of their reward cycle entries\n;;    (4) `stacking-state.pox-addr` matches `reward-cycle-pox-address-list.pox-addr`\n;;    (5) if set, (len reward-set-indexes) == lock-period\n;;    (6) (reward-cycle-to-burn-height (+ lock-period first-reward-cycle)) == (get unlock-height (stx-account stacker))\n;;  These invariants only hold while `cur-reward-cycle < (+ lock-period first-reward-cycle)`\n;;\n(define-map stacking-state\n    { stacker: principal }\n    {\n        ;; Description of the underlying burnchain address that will\n        ;; receive PoX'ed tokens. Translating this into an address\n        ;; depends on the burnchain being used.  When Bitcoin is\n        ;; the burnchain, this gets translated into a p2pkh, p2sh,\n        ;; p2wpkh-p2sh, p2wsh-p2sh, p2wpkh, p2wsh, or p2tr UTXO,\n        ;; depending on the version.  The `hashbytes` field *must* be\n        ;; either 20 bytes or 32 bytes, depending on the output.\n        pox-addr: { version: (buff 1), hashbytes: (buff 32) },\n        ;; how long the uSTX are locked, in reward cycles.\n        lock-period: uint,\n        ;; reward cycle when rewards begin\n        first-reward-cycle: uint,\n        ;; indexes in each reward-set associated with this user.\n        ;; these indexes are only valid looking forward from\n        ;;  `first-reward-cycle` (i.e., they do not correspond\n        ;;  to entries in the reward set that may have been from\n        ;;  previous stack-stx calls, or prior to an extend)\n        reward-set-indexes: (list 12 uint),\n        ;; principal of the delegate, if stacker has delegated\n        delegated-to: (optional principal),\n    }\n)\n\n;; Delegation relationships\n(define-map delegation-state\n    { stacker: principal }\n    {\n        amount-ustx: uint,              ;; how many uSTX delegated?\n        delegated-to: principal,        ;; who are we delegating?\n        until-burn-ht: (optional uint), ;; how long does the delegation last?\n        ;; does the delegate _need_ to use a specific\n        ;; pox recipient address?\n        pox-addr: (optional { version: (buff 1), hashbytes: (buff 32) })\n    }\n)\n\n;; allowed contract-callers\n(define-map allowance-contract-callers\n    { sender: principal, contract-caller: principal }\n    { until-burn-ht: (optional uint) })\n\n;; How many uSTX are stacked in a given reward cycle.\n;; Updated when a new PoX address is registered, or when more STX are granted\n;; to it.\n(define-map reward-cycle-total-stacked\n    { reward-cycle: uint }\n    { total-ustx: uint }\n)\n\n;; Internal map read by the Stacks node to iterate through the list of\n;; PoX reward addresses on a per-reward-cycle basis.\n(define-map reward-cycle-pox-address-list\n    { reward-cycle: uint, index: uint }\n    {\n        pox-addr: { version: (buff 1), hashbytes: (buff 32) },\n        total-ustx: uint,\n        stacker: (optional principal),\n        signer: (buff 33)\n    }\n)\n\n(define-map reward-cycle-pox-address-list-len\n    { reward-cycle: uint }\n    { len: uint }\n)\n\n;; how much has been locked up for this address before\n;;   committing?\n;; this map allows stackers to stack amounts < minimum\n;;   by paying the cost of aggregation during the commit\n(define-map partial-stacked-by-cycle\n    {\n        pox-addr: { version: (buff 1), hashbytes: (buff 32) },\n        reward-cycle: uint,\n        sender: principal\n    }\n    { stacked-amount: uint }\n)\n\n;; This is identical to partial-stacked-by-cycle, but its data is never deleted.\n;; It is used to preserve data for downstream clients to observe aggregate\n;; commits.  Each key/value pair in this map is simply the last value of\n;; partial-stacked-by-cycle right after it was deleted (so, subsequent calls\n;; to the `stack-aggregation-*` functions will overwrite this).\n(define-map logged-partial-stacked-by-cycle\n    {\n        pox-addr: { version: (buff 1), hashbytes: (buff 32) },\n        reward-cycle: uint,\n        sender: principal\n    }\n    { stacked-amount: uint }\n)\n\n;; State for setting authorizations for signer keys to be used in\n;; certain stacking transactions. These fields match the fields used\n;; in the message hash for signature-based signer key authorizations.\n;; Values in this map are set in `set-signer-key-authorization`.\n(define-map signer-key-authorizations\n    {\n        ;; The signer key being authorized\n        signer-key: (buff 33),\n        ;; The reward cycle for which the authorization is valid.\n        ;; For `stack-stx` and `stack-extend`, this refers to the reward\n        ;; cycle where the transaction is confirmed. For `stack-aggregation-commit`,\n        ;; this refers to the reward cycle argument in that function.\n        reward-cycle: uint,\n        ;; For `stack-stx`, this refers to `lock-period`. For `stack-extend`,\n        ;; this refers to `extend-count`. For `stack-aggregation-commit`, this is `u1`.\n        period: uint,\n        ;; A string representing the function where this authorization is valid. Either\n        ;; `stack-stx`, `stack-extend`, `stack-increase` or `agg-commit`.\n        topic: (string-ascii 14),\n        ;; The PoX address that can be used with this signer key\n        pox-addr: { version: (buff 1), hashbytes: (buff 32) },\n        ;; The unique auth-id for this authorization\n        auth-id: uint,\n        ;; The maximum amount of uSTX that can be used (per tx) with this signer key\n        max-amount: uint,\n    }\n    bool ;; Whether the authorization can be used or not\n)\n\n;; State for tracking used signer key authorizations. This prevents re-use\n;; of the same signature or pre-set authorization for multiple transactions.\n;; Refer to the `signer-key-authorizations` map for the documentation on these fields\n(define-map used-signer-key-authorizations\n    {\n        signer-key: (buff 33),\n        reward-cycle: uint,\n        period: uint,\n        topic: (string-ascii 14),\n        pox-addr: { version: (buff 1), hashbytes: (buff 32) },\n        auth-id: uint,\n        max-amount: uint,\n    }\n    bool ;; Whether the field has been used or not\n)\n\n;; What's the reward cycle number of the burnchain block height?\n;; Will runtime-abort if height is less than the first burnchain block (this is intentional)\n(define-read-only (burn-height-to-reward-cycle (height uint))\n    (/ (- height (var-get first-burnchain-block-height)) (var-get pox-reward-cycle-length)))\n\n;; What's the block height at the start of a given reward cycle?\n(define-read-only (reward-cycle-to-burn-height (cycle uint))\n    (+ (var-get first-burnchain-block-height) (* cycle (var-get pox-reward-cycle-length))))\n\n;; What's the current PoX reward cycle?\n(define-read-only (current-pox-reward-cycle)\n    (burn-height-to-reward-cycle burn-block-height))\n\n;; Get the _current_ PoX stacking principal information.  If the information\n;; is expired, or if there's never been such a stacker, then returns none.\n(define-read-only (get-stacker-info (stacker principal))\n    (match (map-get? stacking-state { stacker: stacker })\n        stacking-info\n            (if (<= (+ (get first-reward-cycle stacking-info) (get lock-period stacking-info)) (current-pox-reward-cycle))\n                ;; present, but lock has expired\n                none\n                ;; present, and lock has not expired\n                (some stacking-info)\n            )\n        ;; no state at all\n        none\n    ))\n\n(define-read-only (check-caller-allowed)\n    (or (is-eq tx-sender contract-caller)\n        (let ((caller-allowed\n                 ;; if not in the caller map, return false\n                 (unwrap! (map-get? allowance-contract-callers\n                                    { sender: tx-sender, contract-caller: contract-caller })\n                          false))\n               (expires-at\n                 ;; if until-burn-ht not set, then return true (because no expiry)\n                 (unwrap! (get until-burn-ht caller-allowed) true)))\n          ;; is the caller allowance expired?\n          (if (>= burn-block-height expires-at)\n              false\n              true))))\n\n(define-read-only (get-check-delegation (stacker principal))\n    (let ((delegation-info (try! (map-get? delegation-state { stacker: stacker }))))\n      ;; did the existing delegation expire?\n      (if (match (get until-burn-ht delegation-info)\n                 until-burn-ht (> burn-block-height until-burn-ht)\n                 false)\n          ;; it expired, return none\n          none\n          ;; delegation is active\n          (some delegation-info))))\n\n;; Get the size of the reward set for a reward cycle.\n;; Note that this also _will_ return PoX addresses that are beneath\n;; the minimum threshold -- i.e. the threshold can increase after insertion.\n;; Used internally by the Stacks node, which filters out the entries\n;; in this map to select PoX addresses with enough STX.\n(define-read-only (get-reward-set-size (reward-cycle uint))\n    (default-to\n        u0\n        (get len (map-get? reward-cycle-pox-address-list-len { reward-cycle: reward-cycle }))))\n\n;; Add a single PoX address to a single reward cycle.\n;; Used to build up a set of per-reward-cycle PoX addresses.\n;; No checking will be done -- don't call if this PoX address is already registered in this reward cycle!\n;; Returns the index into the reward cycle that the PoX address is stored to\n(define-private (append-reward-cycle-pox-addr (pox-addr (tuple (version (buff 1)) (hashbytes (buff 32))))\n                                              (reward-cycle uint)\n                                              (amount-ustx uint)\n                                              (stacker (optional principal))\n                                              (signer (buff 33)))\n    (let ((sz (get-reward-set-size reward-cycle)))\n        (map-set reward-cycle-pox-address-list\n            { reward-cycle: reward-cycle, index: sz }\n            { pox-addr: pox-addr, total-ustx: amount-ustx, stacker: stacker, signer: signer })\n        (map-set reward-cycle-pox-address-list-len\n            { reward-cycle: reward-cycle }\n            { len: (+ u1 sz) })\n    sz))\n\n;; How many uSTX are stacked?\n(define-read-only (get-total-ustx-stacked (reward-cycle uint))\n    (default-to\n        u0\n        (get total-ustx (map-get? reward-cycle-total-stacked { reward-cycle: reward-cycle })))\n)\n\n;; Called internally by the node to iterate through the list of PoX addresses in this reward cycle.\n;; Returns (optional (tuple (pox-addr <pox-address>) (total-ustx <uint>)))\n(define-read-only (get-reward-set-pox-address (reward-cycle uint) (index uint))\n    (map-get? reward-cycle-pox-address-list { reward-cycle: reward-cycle, index: index }))\n\n;; Add a PoX address to the `cycle-index`-th reward cycle, if `cycle-index` is between 0 and the given num-cycles (exclusive).\n;; Arguments are given as a tuple, so this function can be (folded ..)'ed onto a list of its arguments.\n;; Used by add-pox-addr-to-reward-cycles.\n;; No checking is done.\n;; The returned tuple is the same as inputted `params`, but the `i` field is incremented if\n;;  the pox-addr was added to the given cycle.  Also, `reward-set-indexes` grows to include all\n;;  of the `reward-cycle-index` key parts of the `reward-cycle-pox-address-list` which get added by this function.\n;;  This way, the caller knows which items in a given reward cycle's PoX address list got updated.\n(define-private (add-pox-addr-to-ith-reward-cycle (cycle-index uint) (params (tuple\n                                                            (pox-addr (tuple (version (buff 1)) (hashbytes (buff 32))))\n                                                            (reward-set-indexes (list 12 uint))\n                                                            (first-reward-cycle uint)\n                                                            (num-cycles uint)\n                                                            (stacker (optional principal))\n                                                            (signer (buff 33))\n                                                            (amount-ustx uint)\n                                                            (i uint))))\n    (let ((reward-cycle (+ (get first-reward-cycle params) (get i params)))\n          (num-cycles (get num-cycles params))\n          (i (get i params))\n          (reward-set-index (if (< i num-cycles)\n            (let ((total-ustx (get-total-ustx-stacked reward-cycle))\n                  (reward-index\n                      ;; record how many uSTX this pox-addr will stack for in the given reward cycle\n                      (append-reward-cycle-pox-addr\n                        (get pox-addr params)\n                        reward-cycle\n                        (get amount-ustx params)\n                        (get stacker params)\n                        (get signer params)\n                        )))\n                  ;; update running total\n                  (map-set reward-cycle-total-stacked\n                     { reward-cycle: reward-cycle }\n                     { total-ustx: (+ (get amount-ustx params) total-ustx) })\n                  (some reward-index))\n            none))\n          (next-i (if (< i num-cycles) (+ i u1) i)))\n    {\n        pox-addr: (get pox-addr params),\n        first-reward-cycle: (get first-reward-cycle params),\n        num-cycles: num-cycles,\n        amount-ustx: (get amount-ustx params),\n        stacker: (get stacker params),\n        signer: (get signer params),\n        reward-set-indexes: (match\n            reward-set-index new (unwrap-panic (as-max-len? (append (get reward-set-indexes params) new) u12))\n            (get reward-set-indexes params)),\n        i: next-i\n    }))\n\n;; Add a PoX address to a given sequence of reward cycle lists.\n;; A PoX address can be added to at most 12 consecutive cycles.\n;; No checking is done.\n(define-private (add-pox-addr-to-reward-cycles (pox-addr (tuple (version (buff 1)) (hashbytes (buff 32))))\n                                               (first-reward-cycle uint)\n                                               (num-cycles uint)\n                                               (amount-ustx uint)\n                                               (stacker principal)\n                                               (signer (buff 33)))\n  (let ((cycle-indexes (list u0 u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11))\n        (results (fold add-pox-addr-to-ith-reward-cycle cycle-indexes\n                         { pox-addr: pox-addr, first-reward-cycle: first-reward-cycle, num-cycles: num-cycles,\n                           reward-set-indexes: (list), amount-ustx: amount-ustx, i: u0, stacker: (some stacker), signer: signer }))\n        (reward-set-indexes (get reward-set-indexes results)))\n    ;; For safety, add up the number of times (add-principal-to-ith-reward-cycle) returns 1.\n    ;; It _should_ be equal to num-cycles.\n    (asserts! (is-eq num-cycles (get i results)) (err ERR_STACKING_UNREACHABLE))\n    (asserts! (is-eq num-cycles (len reward-set-indexes)) (err ERR_STACKING_UNREACHABLE))\n    (ok reward-set-indexes)))\n\n(define-private (add-pox-partial-stacked-to-ith-cycle\n                 (cycle-index uint)\n                 (params { pox-addr: { version: (buff 1), hashbytes: (buff 32) },\n                           reward-cycle: uint,\n                           num-cycles: uint,\n                           amount-ustx: uint }))\n  (let ((pox-addr     (get pox-addr     params))\n        (num-cycles   (get num-cycles   params))\n        (reward-cycle (get reward-cycle params))\n        (amount-ustx  (get amount-ustx  params)))\n    (let ((current-amount\n           (default-to u0\n             (get stacked-amount\n                  (map-get? partial-stacked-by-cycle { sender: tx-sender, pox-addr: pox-addr, reward-cycle: reward-cycle })))))\n      (if (>= cycle-index num-cycles)\n          ;; do not add to cycles >= cycle-index\n          false\n          ;; otherwise, add to the partial-stacked-by-cycle\n          (map-set partial-stacked-by-cycle\n                   { sender: tx-sender, pox-addr: pox-addr, reward-cycle: reward-cycle }\n                   { stacked-amount: (+ amount-ustx current-amount) }))\n      ;; produce the next params tuple\n      { pox-addr: pox-addr,\n        reward-cycle: (+ u1 reward-cycle),\n        num-cycles: num-cycles,\n        amount-ustx: amount-ustx })))\n\n;; Add a PoX address to a given sequence of partial reward cycle lists.\n;; A PoX address can be added to at most 12 consecutive cycles.\n;; No checking is done.\n(define-private (add-pox-partial-stacked (pox-addr (tuple (version (buff 1)) (hashbytes (buff 32))))\n                                         (first-reward-cycle uint)\n                                         (num-cycles uint)\n                                         (amount-ustx uint))\n  (let ((cycle-indexes (list u0 u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11)))\n    (fold add-pox-partial-stacked-to-ith-cycle cycle-indexes\n          { pox-addr: pox-addr, reward-cycle: first-reward-cycle, num-cycles: num-cycles, amount-ustx: amount-ustx })\n    true))\n\n;; What is the minimum number of uSTX to be stacked in the given reward cycle?\n;; Used internally by the Stacks node, and visible publicly.\n(define-read-only (get-stacking-minimum)\n    (/ stx-liquid-supply STACKING_THRESHOLD_25))\n\n;; Is the address mode valid for a PoX address?\n(define-read-only (check-pox-addr-version (version (buff 1)))\n    (<= (buff-to-uint-be version) MAX_ADDRESS_VERSION))\n\n;; Is this buffer the right length for the given PoX address?\n(define-read-only (check-pox-addr-hashbytes (version (buff 1)) (hashbytes (buff 32)))\n    (if (<= (buff-to-uint-be version) MAX_ADDRESS_VERSION_BUFF_20)\n        (is-eq (len hashbytes) u20)\n        (if (<= (buff-to-uint-be version) MAX_ADDRESS_VERSION_BUFF_32)\n            (is-eq (len hashbytes) u32)\n            false)))\n\n;; Is the given lock period valid?\n(define-read-only (check-pox-lock-period (lock-period uint))\n    (and (>= lock-period MIN_POX_REWARD_CYCLES)\n         (<= lock-period MAX_POX_REWARD_CYCLES)))\n\n;; Evaluate if a participant can stack an amount of STX for a given period.\n;; This method is designed as a read-only method so that it can be used as\n;; a set of guard conditions and also as a read-only RPC call that can be\n;; performed beforehand.\n(define-read-only (can-stack-stx (pox-addr (tuple (version (buff 1)) (hashbytes (buff 32))))\n                                  (amount-ustx uint)\n                                  (first-reward-cycle uint)\n                                  (num-cycles uint))\n  (begin\n    ;; minimum uSTX must be met\n    (asserts! (<= (get-stacking-minimum) amount-ustx)\n              (err ERR_STACKING_THRESHOLD_NOT_MET))\n\n    (minimal-can-stack-stx pox-addr amount-ustx first-reward-cycle num-cycles)))\n\n;; Evaluate if a participant can stack an amount of STX for a given period.\n;; This method is designed as a read-only method so that it can be used as\n;; a set of guard conditions and also as a read-only RPC call that can be\n;; performed beforehand.\n(define-read-only (minimal-can-stack-stx\n                   (pox-addr (tuple (version (buff 1)) (hashbytes (buff 32))))\n                   (amount-ustx uint)\n                   (first-reward-cycle uint)\n                   (num-cycles uint))\n  (begin\n    ;; amount must be valid\n    (asserts! (> amount-ustx u0)\n              (err ERR_STACKING_INVALID_AMOUNT))\n\n    ;; lock period must be in acceptable range.\n    (asserts! (check-pox-lock-period num-cycles)\n              (err ERR_STACKING_INVALID_LOCK_PERIOD))\n\n    ;; address version must be valid\n    (asserts! (check-pox-addr-version (get version pox-addr))\n              (err ERR_STACKING_INVALID_POX_ADDRESS))\n\n    ;; address hashbytes must be valid for the version\n    (asserts! (check-pox-addr-hashbytes (get version pox-addr) (get hashbytes pox-addr))\n              (err ERR_STACKING_INVALID_POX_ADDRESS))\n\n    (ok true)))\n\n;; Revoke contract-caller authorization to call stacking methods\n(define-public (disallow-contract-caller (caller principal))\n  (begin\n    (asserts! (is-eq tx-sender contract-caller)\n              (err ERR_STACKING_PERMISSION_DENIED))\n    (ok (map-delete allowance-contract-callers { sender: tx-sender, contract-caller: caller }))))\n\n;; Give a contract-caller authorization to call stacking methods\n;;  normally, stacking methods may only be invoked by _direct_ transactions\n;;   (i.e., the tx-sender issues a direct contract-call to the stacking methods)\n;;  by issuing an allowance, the tx-sender may call through the allowed contract\n(define-public (allow-contract-caller (caller principal) (until-burn-ht (optional uint)))\n  (begin\n    (asserts! (is-eq tx-sender contract-caller)\n              (err ERR_STACKING_PERMISSION_DENIED))\n    (ok (map-set allowance-contract-callers\n               { sender: tx-sender, contract-caller: caller }\n               { until-burn-ht: until-burn-ht }))))\n\n;; Lock up some uSTX for stacking!  Note that the given amount here is in micro-STX (uSTX).\n;; The STX will be locked for the given number of reward cycles (lock-period).\n;; This is the self-service interface.  tx-sender will be the Stacker.\n;;\n;; * The given stacker cannot currently be stacking.\n;; * You will need the minimum uSTX threshold.  This will be determined by (get-stacking-minimum)\n;; at the time this method is called.\n;; * You may need to increase the amount of uSTX locked up later, since the minimum uSTX threshold\n;; may increase between reward cycles.\n;; * You need to provide a signer key to be used in the signer DKG process.\n;; * The Stacker will receive rewards in the reward cycle following `start-burn-ht`.\n;; Importantly, `start-burn-ht` may not be further into the future than the next reward cycle,\n;; and in most cases should be set to the current burn block height.\n;; \n;; To ensure that the Stacker is authorized to use the provided `signer-key`, the stacker\n;; must provide either a signature have an authorization already saved. Refer to\n;; `verify-signer-key-sig` for more information.\n;;\n;; The tokens will unlock and be returned to the Stacker (tx-sender) automatically.\n(define-public (stack-stx (amount-ustx uint)\n                          (pox-addr (tuple (version (buff 1)) (hashbytes (buff 32))))\n                          (start-burn-ht uint)\n                          (lock-period uint)\n                          (signer-sig (optional (buff 65)))\n                          (signer-key (buff 33))\n                          (max-amount uint)\n                          (auth-id uint))\n    ;; this stacker's first reward cycle is the _next_ reward cycle\n    (let ((first-reward-cycle (+ u1 (current-pox-reward-cycle)))\n          (specified-reward-cycle (+ u1 (burn-height-to-reward-cycle start-burn-ht))))\n      ;; the start-burn-ht must result in the next reward cycle, do not allow stackers\n      ;;  to \"post-date\" their `stack-stx` transaction\n      (asserts! (is-eq first-reward-cycle specified-reward-cycle)\n                (err ERR_INVALID_START_BURN_HEIGHT))\n\n      ;; must be called directly by the tx-sender or by an allowed contract-caller\n      (asserts! (check-caller-allowed)\n                (err ERR_STACKING_PERMISSION_DENIED))\n\n      ;; tx-sender principal must not be stacking\n      (asserts! (is-none (get-stacker-info tx-sender))\n        (err ERR_STACKING_ALREADY_STACKED))\n\n      ;; tx-sender must not be delegating\n      (asserts! (is-none (get-check-delegation tx-sender))\n        (err ERR_STACKING_ALREADY_DELEGATED))\n\n      ;; the Stacker must have sufficient unlocked funds\n      (asserts! (>= (stx-get-balance tx-sender) amount-ustx)\n        (err ERR_STACKING_INSUFFICIENT_FUNDS))\n\n      ;; Validate ownership of the given signer key\n      (try! (consume-signer-key-authorization pox-addr (- first-reward-cycle u1) \"stack-stx\" lock-period signer-sig signer-key amount-ustx max-amount auth-id))\n\n      ;; ensure that stacking can be performed\n      (try! (can-stack-stx pox-addr amount-ustx first-reward-cycle lock-period))\n\n      ;; register the PoX address with the amount stacked\n      (let ((reward-set-indexes (try! (add-pox-addr-to-reward-cycles pox-addr first-reward-cycle lock-period amount-ustx tx-sender signer-key))))\n          ;; add stacker record\n         (map-set stacking-state\n           { stacker: tx-sender }\n           { pox-addr: pox-addr,\n             reward-set-indexes: reward-set-indexes,\n             first-reward-cycle: first-reward-cycle,\n             lock-period: lock-period,\n             delegated-to: none })\n\n          ;; return the lock-up information, so the node can actually carry out the lock.\n          (ok { stacker: tx-sender, lock-amount: amount-ustx, signer-key: signer-key, unlock-burn-height: (reward-cycle-to-burn-height (+ first-reward-cycle lock-period)) }))))\n\n;; Revokes the delegation to the current stacking pool.\n;; New in pox-4: Fails if the delegation was already revoked.\n;; Returns the last delegation state.\n(define-public (revoke-delegate-stx)\n  (let ((last-delegation-state (get-check-delegation tx-sender)))\n    ;; must be called directly by the tx-sender or by an allowed contract-caller\n    (asserts! (check-caller-allowed)\n              (err ERR_STACKING_PERMISSION_DENIED))\n    (asserts! (is-some last-delegation-state) (err ERR_DELEGATION_ALREADY_REVOKED))\n    (asserts! (map-delete delegation-state { stacker: tx-sender }) (err ERR_DELEGATION_ALREADY_REVOKED))\n    (ok last-delegation-state)))\n\n;; Delegate to `delegate-to` the ability to stack from a given address.\n;;  This method _does not_ lock the funds, rather, it allows the delegate\n;;  to issue the stacking lock.\n;; The caller specifies:\n;;   * amount-ustx: the total amount of ustx the delegate may be allowed to lock\n;;   * until-burn-ht: an optional burn height at which this delegation expires\n;;   * pox-addr: an optional address to which any rewards *must* be sent\n(define-public (delegate-stx (amount-ustx uint)\n                             (delegate-to principal)\n                             (until-burn-ht (optional uint))\n                             (pox-addr (optional { version: (buff 1), hashbytes: (buff 32) })))\n\n    (begin\n      ;; must be called directly by the tx-sender or by an allowed contract-caller\n      (asserts! (check-caller-allowed)\n                (err ERR_STACKING_PERMISSION_DENIED))\n\n      ;; delegate-stx no longer requires the delegator to not currently\n      ;; be stacking.\n      ;; delegate-stack-* functions assert that\n      ;; 1. users can't swim in two pools at the same time.\n      ;; 2. users can't switch pools without cool down cycle.\n      ;;    Other pool admins can't increase or extend.\n      ;; 3. users can't join a pool while already directly stacking.\n\n      ;; pox-addr, if given, must be valid\n      (match pox-addr\n         address\n            (asserts! (check-pox-addr-version (get version address))\n                (err ERR_STACKING_INVALID_POX_ADDRESS))\n         true)\n\n      (match pox-addr\n         pox-tuple\n            (asserts! (check-pox-addr-hashbytes (get version pox-tuple) (get hashbytes pox-tuple))\n                (err ERR_STACKING_INVALID_POX_ADDRESS))\n         true)\n\n      ;; tx-sender must not be delegating\n      (asserts! (is-none (get-check-delegation tx-sender))\n        (err ERR_STACKING_ALREADY_DELEGATED))\n\n      ;; add delegation record\n      (map-set delegation-state\n        { stacker: tx-sender }\n        { amount-ustx: amount-ustx,\n          delegated-to: delegate-to,\n          until-burn-ht: until-burn-ht,\n          pox-addr: pox-addr })\n\n      (ok true)))\n\n;; Generate a message hash for validating a signer key.\n;; The message hash follows SIP018 for signing structured data. The structured data\n;; is the tuple `{ pox-addr: { version, hashbytes }, reward-cycle, auth-id, max-amount }`.\n;; The domain is `{ name: \"pox-4-signer\", version: \"1.0.0\", chain-id: chain-id }`.\n(define-read-only (get-signer-key-message-hash (pox-addr { version: (buff 1), hashbytes: (buff 32) })\n                                               (reward-cycle uint)\n                                               (topic (string-ascii 14))\n                                               (period uint)\n                                               (max-amount uint)\n                                               (auth-id uint))\n  (sha256 (concat\n    SIP018_MSG_PREFIX\n    (concat\n      (sha256 (unwrap-panic (to-consensus-buff? { name: \"pox-4-signer\", version: \"1.0.0\", chain-id: chain-id })))\n      (sha256 (unwrap-panic\n        (to-consensus-buff? {\n          pox-addr: pox-addr,\n          reward-cycle: reward-cycle,\n          topic: topic,\n          period: period,\n          auth-id: auth-id,\n          max-amount: max-amount,\n        })))))))\n\n;; Verify a signature from the signing key for this specific stacker.\n;; See `get-signer-key-message-hash` for details on the message hash.\n;;\n;; Note that `reward-cycle` corresponds to the _current_ reward cycle,\n;; when used with `stack-stx` and `stack-extend`. Both the reward cycle and\n;; the lock period are inflexible, which means that the stacker must confirm their transaction\n;; during the exact reward cycle and with the exact period that the signature or authorization was\n;; generated for.\n;; \n;; The `amount` field is checked to ensure it is not larger than `max-amount`, which is\n;; a field in the authorization. `auth-id` is a random uint to prevent authorization\n;; replays.\n;;\n;; This function does not verify the payload of the authorization. The caller of\n;; this function must ensure that the payload (reward cycle, period, topic, and pox-addr)\n;; are valid according to the caller function's requirements.\n;;\n;; When `signer-sig` is present, the public key is recovered from the signature\n;; and compared to `signer-key`. If `signer-sig` is `none`, the function verifies that an authorization was previously\n;; added for this key.\n;; \n;; This function checks to ensure that the authorization hasn't been used yet, but it\n;; does _not_ store the authorization as used. The function `consume-signer-key-authorization`\n;; handles that, and this read-only function is exposed for client-side verification.\n(define-read-only (verify-signer-key-sig (pox-addr { version: (buff 1), hashbytes: (buff 32) })\n                                         (reward-cycle uint)\n                                         (topic (string-ascii 14))\n                                         (period uint)\n                                         (signer-sig-opt (optional (buff 65)))\n                                         (signer-key (buff 33))\n                                         (amount uint)\n                                         (max-amount uint)\n                                         (auth-id uint))\n  (begin\n    ;; Validate that amount is less than or equal to `max-amount`\n    (asserts! (>= max-amount amount) (err ERR_SIGNER_AUTH_AMOUNT_TOO_HIGH))\n    (asserts! (is-none (map-get? used-signer-key-authorizations { signer-key: signer-key, reward-cycle: reward-cycle, topic: topic, period: period, pox-addr: pox-addr, auth-id: auth-id, max-amount: max-amount }))\n              (err ERR_SIGNER_AUTH_USED))\n    (match signer-sig-opt\n      ;; `signer-sig` is present, verify the signature\n      signer-sig (ok (asserts!\n        (is-eq\n          (unwrap! (secp256k1-recover?\n            (get-signer-key-message-hash pox-addr reward-cycle topic period max-amount auth-id)\n            signer-sig) (err ERR_INVALID_SIGNATURE_RECOVER))\n          signer-key)\n        (err ERR_INVALID_SIGNATURE_PUBKEY)))\n      ;; `signer-sig` is not present, verify that an authorization was previously added for this key\n      (ok (asserts! (default-to false (map-get? signer-key-authorizations\n            { signer-key: signer-key, reward-cycle: reward-cycle, period: period, topic: topic, pox-addr: pox-addr, auth-id: auth-id, max-amount: max-amount }))\n          (err ERR_NOT_ALLOWED)))\n    ))\n  )\n\n;; This function does two things:\n;;\n;; - Verify that a signer key is authorized to be used\n;; - Updates the `used-signer-key-authorizations` map to prevent reuse\n;;\n;; This \"wrapper\" method around `verify-signer-key-sig` allows that function to remain\n;; read-only, so that it can be used by clients as a sanity check before submitting a transaction.\n(define-private (consume-signer-key-authorization (pox-addr { version: (buff 1), hashbytes: (buff 32) })\n                                                  (reward-cycle uint)\n                                                  (topic (string-ascii 14))\n                                                  (period uint)\n                                                  (signer-sig-opt (optional (buff 65)))\n                                                  (signer-key (buff 33))\n                                                  (amount uint)\n                                                  (max-amount uint)\n                                                  (auth-id uint))\n  (begin\n    ;; verify the authorization\n    (try! (verify-signer-key-sig pox-addr reward-cycle topic period signer-sig-opt signer-key amount max-amount auth-id))\n    ;; update the `used-signer-key-authorizations` map\n    (asserts! (map-insert used-signer-key-authorizations\n      { signer-key: signer-key, reward-cycle: reward-cycle, topic: topic, period: period, pox-addr: pox-addr, auth-id: auth-id, max-amount: max-amount } true)\n      (err ERR_SIGNER_AUTH_USED))\n    (ok true)))\n\n;; Commit partially stacked STX and allocate a new PoX reward address slot.\n;;   This allows a stacker/delegate to lock fewer STX than the minimal threshold in multiple transactions,\n;;   so long as: 1. The pox-addr is the same.\n;;               2. This \"commit\" transaction is called _before_ the PoX anchor block.\n;;   This ensures that each entry in the reward set returned to the stacks-node is greater than the threshold,\n;;   but does not require it be all locked up within a single transaction\n;;\n;; Returns (ok uint) on success, where the given uint is the reward address's index in the list of reward\n;; addresses allocated in this reward cycle.  This index can then be passed to `stack-aggregation-increase`\n;; to later increment the STX this PoX address represents, in amounts less than the stacking minimum.\n;;\n;; *New in Stacks 2.1.*\n(define-private (inner-stack-aggregation-commit (pox-addr { version: (buff 1), hashbytes: (buff 32) })\n                                                (reward-cycle uint)\n                                                (signer-sig (optional (buff 65)))\n                                                (signer-key (buff 33))\n                                                (max-amount uint)\n                                                (auth-id uint))\n  (let ((partial-stacked\n         ;; fetch the partial commitments\n         (unwrap! (map-get? partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })\n                  (err ERR_STACKING_NO_SUCH_PRINCIPAL))))\n    ;; must be called directly by the tx-sender or by an allowed contract-caller\n    (asserts! (check-caller-allowed)\n              (err ERR_STACKING_PERMISSION_DENIED))\n    (let ((amount-ustx (get stacked-amount partial-stacked)))\n      (try! (consume-signer-key-authorization pox-addr reward-cycle \"agg-commit\" u1 signer-sig signer-key amount-ustx max-amount auth-id))\n      (try! (can-stack-stx pox-addr amount-ustx reward-cycle u1))\n      ;; Add the pox addr to the reward cycle, and extract the index of the PoX address\n      ;; so the delegator can later use it to call stack-aggregation-increase.\n      (let ((add-pox-addr-info\n                (add-pox-addr-to-ith-reward-cycle\n                   u0\n                   { pox-addr: pox-addr,\n                     first-reward-cycle: reward-cycle,\n                     num-cycles: u1,\n                     reward-set-indexes: (list),\n                     stacker: none,\n                     signer: signer-key,\n                     amount-ustx: amount-ustx,\n                     i: u0 }))\n           (pox-addr-index (unwrap-panic\n                (element-at (get reward-set-indexes add-pox-addr-info) u0))))\n\n        ;; don't update the stacking-state map,\n        ;;  because it _already has_ this stacker's state\n        ;; don't lock the STX, because the STX is already locked\n        ;;\n        ;; clear the partial-stacked state, and log it\n        (map-delete partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })\n        (map-set logged-partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle } partial-stacked)\n        (ok pox-addr-index)))))\n\n;; Legacy interface for stack-aggregation-commit.\n;; Wraps inner-stack-aggregation-commit.  See its docstring for details.\n;; Returns (ok true) on success\n;; Returns (err ...) on failure.\n(define-public (stack-aggregation-commit (pox-addr { version: (buff 1), hashbytes: (buff 32) })\n                                         (reward-cycle uint)\n                                         (signer-sig (optional (buff 65)))\n                                         (signer-key (buff 33))\n                                         (max-amount uint)\n                                         (auth-id uint))\n    (match (inner-stack-aggregation-commit pox-addr reward-cycle signer-sig signer-key max-amount auth-id)\n        pox-addr-index (ok true)\n        commit-err (err commit-err)))\n\n;; Public interface to `inner-stack-aggregation-commit`.  See its documentation for details.\n;; *New in Stacks 2.1.*\n(define-public (stack-aggregation-commit-indexed (pox-addr { version: (buff 1), hashbytes: (buff 32) })\n                                                 (reward-cycle uint)\n                                                 (signer-sig (optional (buff 65)))\n                                                 (signer-key (buff 33))\n                                                 (max-amount uint)\n                                                 (auth-id uint))\n    (inner-stack-aggregation-commit pox-addr reward-cycle signer-sig signer-key max-amount auth-id))\n\n;; Commit partially stacked STX to a PoX address which has already received some STX (more than the Stacking min).\n;; This allows a delegator to lock up marginally more STX from new delegates, even if they collectively do not\n;; exceed the Stacking minimum, so long as the target PoX address already represents at least as many STX as the\n;; Stacking minimum.\n;;\n;; The `reward-cycle-index` is emitted as a contract event from `stack-aggregation-commit` when the initial STX are\n;; locked up by this delegator.  It must be passed here to add more STX behind this PoX address.  If the delegator\n;; called `stack-aggregation-commit` multiple times for the same PoX address, then any such `reward-cycle-index` will\n;; work here.\n;;\n;; *New in Stacks 2.1*\n;;\n(define-public (stack-aggregation-increase (pox-addr { version: (buff 1), hashbytes: (buff 32) })\n                                           (reward-cycle uint)\n                                           (reward-cycle-index uint)\n                                           (signer-sig (optional (buff 65)))\n                                           (signer-key (buff 33))\n                                           (max-amount uint)\n                                           (auth-id uint))\n  (let ((partial-stacked\n         ;; fetch the partial commitments\n         (unwrap! (map-get? partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })\n                  (err ERR_STACKING_NO_SUCH_PRINCIPAL))))\n\n    ;; must be called directly by the tx-sender or by an allowed contract-caller\n    (asserts! (check-caller-allowed)\n              (err ERR_STACKING_PERMISSION_DENIED))\n\n    ;; reward-cycle must be in the future\n    (asserts! (> reward-cycle (current-pox-reward-cycle))\n              (err ERR_STACKING_INVALID_LOCK_PERIOD))\n\n    (let ((partial-amount-ustx (get stacked-amount partial-stacked))\n          ;; reward-cycle and reward-cycle-index must point to an existing record in reward-cycle-pox-address-list\n          (existing-entry (unwrap! (map-get? reward-cycle-pox-address-list { reward-cycle: reward-cycle, index: reward-cycle-index })\n                          (err ERR_DELEGATION_NO_REWARD_SLOT)))\n          ;; reward-cycle must point to an existing record in reward-cycle-total-stacked\n          ;; infallible; getting existing-entry succeeded so this must succeed\n          (existing-cycle (unwrap-panic (map-get? reward-cycle-total-stacked { reward-cycle: reward-cycle })))\n          (increased-entry-total (+ (get total-ustx existing-entry) partial-amount-ustx))\n          (increased-cycle-total (+ (get total-ustx existing-cycle) partial-amount-ustx))\n          (existing-signer-key (get signer existing-entry)))\n\n          ;; must be stackable\n          (try! (minimal-can-stack-stx pox-addr increased-entry-total reward-cycle u1))\n\n          ;; new total must exceed the stacking minimum\n          (asserts! (<= (get-stacking-minimum) increased-entry-total)\n                    (err ERR_STACKING_THRESHOLD_NOT_MET))\n\n          ;; there must *not* be a stacker entry (since this is a delegator)\n          (asserts! (is-none (get stacker existing-entry))\n                    (err ERR_DELEGATION_WRONG_REWARD_SLOT))\n\n          ;; the given PoX address must match the one on record\n          (asserts! (is-eq pox-addr (get pox-addr existing-entry))\n                    (err ERR_DELEGATION_WRONG_REWARD_SLOT))\n\n          ;; Validate that amount is less than or equal to `max-amount`\n          (asserts! (>= max-amount increased-entry-total) (err ERR_SIGNER_AUTH_AMOUNT_TOO_HIGH))\n\n          ;; Validate that signer-key matches the existing signer-key\n          (asserts! (is-eq existing-signer-key signer-key) (err ERR_INVALID_SIGNER_KEY))\n\n          ;; Verify signature from delegate that allows this sender for this cycle\n          ;; 'lock-period' param set to one period, same as aggregation-commit-indexed\n          (try! (consume-signer-key-authorization pox-addr reward-cycle \"agg-increase\" u1 signer-sig signer-key increased-entry-total max-amount auth-id))\n\n          ;; update the pox-address list -- bump the total-ustx\n          (map-set reward-cycle-pox-address-list\n                   { reward-cycle: reward-cycle, index: reward-cycle-index }\n                   { pox-addr: pox-addr,\n                     total-ustx: increased-entry-total,\n                     stacker: none,\n                     signer: signer-key })\n\n          ;; update the total ustx in this cycle\n          (map-set reward-cycle-total-stacked\n                   { reward-cycle: reward-cycle }\n                   { total-ustx: increased-cycle-total })\n\n          ;; don't update the stacking-state map,\n          ;;  because it _already has_ this stacker's state\n          ;; don't lock the STX, because the STX is already locked\n          ;;\n          ;; clear the partial-stacked state, and log it\n          (map-delete partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle })\n          (map-set logged-partial-stacked-by-cycle { pox-addr: pox-addr, sender: tx-sender, reward-cycle: reward-cycle } partial-stacked)\n          (ok true))))\n\n;; As a delegate, stack the given principal's STX using partial-stacked-by-cycle\n;; Once the delegate has stacked > minimum, the delegate should call stack-aggregation-commit\n(define-public (delegate-stack-stx (stacker principal)\n                                   (amount-ustx uint)\n                                   (pox-addr { version: (buff 1), hashbytes: (buff 32) })\n                                   (start-burn-ht uint)\n                                   (lock-period uint))\n    ;; this stacker's first reward cycle is the _next_ reward cycle\n    (let ((first-reward-cycle (+ u1 (current-pox-reward-cycle)))\n          (specified-reward-cycle (+ u1 (burn-height-to-reward-cycle start-burn-ht)))\n          (unlock-burn-height (reward-cycle-to-burn-height (+ (current-pox-reward-cycle) u1 lock-period))))\n      ;; the start-burn-ht must result in the next reward cycle, do not allow stackers\n      ;;  to \"post-date\" their `stack-stx` transaction\n      (asserts! (is-eq first-reward-cycle specified-reward-cycle)\n                (err ERR_INVALID_START_BURN_HEIGHT))\n\n      ;; must be called directly by the tx-sender or by an allowed contract-caller\n      (asserts! (check-caller-allowed)\n        (err ERR_STACKING_PERMISSION_DENIED))\n\n      ;; stacker must have delegated to the caller\n      (let ((delegation-info (unwrap! (get-check-delegation stacker) (err ERR_STACKING_PERMISSION_DENIED))))\n        ;; must have delegated to tx-sender\n        (asserts! (is-eq (get delegated-to delegation-info) tx-sender)\n                  (err ERR_STACKING_PERMISSION_DENIED))\n        ;; must have delegated enough stx\n        (asserts! (>= (get amount-ustx delegation-info) amount-ustx)\n                  (err ERR_DELEGATION_TOO_MUCH_LOCKED))\n        ;; if pox-addr is set, must be equal to pox-addr\n        (asserts! (match (get pox-addr delegation-info)\n                         specified-pox-addr (is-eq pox-addr specified-pox-addr)\n                         true)\n                  (err ERR_DELEGATION_POX_ADDR_REQUIRED))\n        ;; delegation must not expire before lock period\n        (asserts! (match (get until-burn-ht delegation-info)\n                         until-burn-ht (>= until-burn-ht\n                                           unlock-burn-height)\n                      true)\n                  (err ERR_DELEGATION_EXPIRES_DURING_LOCK))\n        )\n\n      ;; stacker principal must not be stacking\n      (asserts! (is-none (get-stacker-info stacker))\n        (err ERR_STACKING_ALREADY_STACKED))\n\n      ;; the Stacker must have sufficient unlocked funds\n      (asserts! (>= (stx-get-balance stacker) amount-ustx)\n        (err ERR_STACKING_INSUFFICIENT_FUNDS))\n\n      ;; ensure that stacking can be performed\n      (try! (minimal-can-stack-stx pox-addr amount-ustx first-reward-cycle lock-period))\n\n      ;; register the PoX address with the amount stacked via partial stacking\n      ;;   before it can be included in the reward set, this must be committed!\n      (add-pox-partial-stacked pox-addr first-reward-cycle lock-period amount-ustx)\n\n      ;; add stacker record\n      (map-set stacking-state\n        { stacker: stacker }\n        { pox-addr: pox-addr,\n          first-reward-cycle: first-reward-cycle,\n          reward-set-indexes: (list),\n          lock-period: lock-period,\n          delegated-to: (some tx-sender) })\n\n      ;; return the lock-up information, so the node can actually carry out the lock.\n      (ok { stacker: stacker,\n            lock-amount: amount-ustx,\n            unlock-burn-height: unlock-burn-height })))\n\n\n;; Used for PoX parameters discovery\n(define-read-only (get-pox-info)\n    (ok {\n        min-amount-ustx: (get-stacking-minimum),\n        reward-cycle-id: (current-pox-reward-cycle),\n        prepare-cycle-length: (var-get pox-prepare-cycle-length),\n        first-burnchain-block-height: (var-get first-burnchain-block-height),\n        reward-cycle-length: (var-get pox-reward-cycle-length),\n        total-liquid-supply-ustx: stx-liquid-supply,\n    })\n)\n\n;; Update the number of stacked STX in a given reward cycle entry.\n;; `reward-cycle-index` is the index into the `reward-cycle-pox-address-list` map for a given reward cycle number.\n;; `updates`, if `(some ..)`, encodes which PoX reward cycle entry (if any) gets updated.  In particular, it must have\n;; `(some stacker)` as the listed stacker, and must be an upcoming reward cycle.\n(define-private (increase-reward-cycle-entry\n                  (reward-cycle-index uint)\n                  (updates (optional { first-cycle: uint, reward-cycle: uint, stacker: principal, add-amount: uint, signer-key: (buff 33) })))\n    (let ((data (try! updates))\n          (first-cycle (get first-cycle data))\n          (reward-cycle (get reward-cycle data))\n          (passed-signer-key (get signer-key data)))\n    (if (> first-cycle reward-cycle)\n        ;; not at first cycle to process yet\n        (some { first-cycle: first-cycle, reward-cycle: (+ u1 reward-cycle), stacker: (get stacker data), add-amount: (get add-amount data), signer-key: (get signer-key data) })\n        (let ((existing-entry (unwrap-panic (map-get? reward-cycle-pox-address-list { reward-cycle: reward-cycle, index: reward-cycle-index })))\n              (existing-total (unwrap-panic (map-get? reward-cycle-total-stacked { reward-cycle: reward-cycle })))\n              (existing-signer-key (get signer existing-entry))\n              (add-amount (get add-amount data))\n              (total-ustx (+ (get total-ustx existing-total) add-amount)))\n            ;; stacker must match\n            (asserts! (is-eq (get stacker existing-entry) (some (get stacker data))) none)\n            ;; signer-key must match\n            (asserts! (is-eq existing-signer-key passed-signer-key) none)\n            ;; update the pox-address list\n            (map-set reward-cycle-pox-address-list\n                     { reward-cycle: reward-cycle, index: reward-cycle-index }\n                     { pox-addr: (get pox-addr existing-entry),\n                       ;; This addresses the bug in pox-2 (see SIP-022)\n                       total-ustx: (+ (get total-ustx existing-entry) add-amount),\n                       stacker: (some (get stacker data)),\n                       signer: (get signer existing-entry) })\n            ;; update the total\n            (map-set reward-cycle-total-stacked\n                     { reward-cycle: reward-cycle }\n                     { total-ustx: total-ustx })\n            (some { first-cycle: first-cycle,\n                    reward-cycle: (+ u1 reward-cycle),\n                    stacker: (get stacker data),\n                    add-amount: (get add-amount data),\n                    signer-key: passed-signer-key })))))\n\n;; Increase the number of STX locked.\n;; *New in Stacks 2.1*\n;; This method locks up an additional amount of STX from `tx-sender`'s, indicated\n;; by `increase-by`.  The `tx-sender` must already be Stacking & must not be\n;; straddling more than one signer-key for the cycles effected. \n;; Refer to `verify-signer-key-sig` for more information on the authorization parameters\n;; included here.\n(define-public (stack-increase \n  (increase-by uint)\n  (signer-sig (optional (buff 65)))\n  (signer-key (buff 33))\n  (max-amount uint)\n  (auth-id uint))\n   (let ((stacker-info (stx-account tx-sender))\n         (amount-stacked (get locked stacker-info))\n         (amount-unlocked (get unlocked stacker-info))\n         (unlock-height (get unlock-height stacker-info))\n         (cur-cycle (current-pox-reward-cycle))\n         (first-increased-cycle (+ cur-cycle u1))\n         (stacker-state (unwrap! (map-get? stacking-state\n                                          { stacker: tx-sender })\n                                          (err ERR_STACK_INCREASE_NOT_LOCKED)))\n         (cur-pox-addr (get pox-addr stacker-state))\n         (cur-period (get lock-period stacker-state)))\n      ;; tx-sender must be currently locked\n      (asserts! (> amount-stacked u0)\n                (err ERR_STACK_INCREASE_NOT_LOCKED))\n      ;; must be called with positive `increase-by`\n      (asserts! (>= increase-by u1)\n                (err ERR_STACKING_INVALID_AMOUNT))\n      ;; stacker must have enough stx to lock\n      (asserts! (>= amount-unlocked increase-by)\n                (err ERR_STACKING_INSUFFICIENT_FUNDS))\n      ;; must be called directly by the tx-sender or by an allowed contract-caller\n      (asserts! (check-caller-allowed)\n                (err ERR_STACKING_PERMISSION_DENIED))\n      ;; stacker must be directly stacking\n      (asserts! (> (len (get reward-set-indexes stacker-state)) u0)\n                (err ERR_STACKING_IS_DELEGATED))\n      ;; stacker must not be delegating\n      (asserts! (is-none (get delegated-to stacker-state))\n                (err ERR_STACKING_IS_DELEGATED))\n\n      ;; Validate that amount is less than or equal to `max-amount`\n      (asserts! (>= max-amount (+ increase-by amount-stacked)) (err ERR_SIGNER_AUTH_AMOUNT_TOO_HIGH))\n\n      ;; Verify signature from delegate that allows this sender for this cycle\n      (try! (consume-signer-key-authorization cur-pox-addr cur-cycle \"stack-increase\" cur-period signer-sig signer-key increase-by max-amount auth-id))\n\n      ;; update reward cycle amounts\n      (asserts! (is-some (fold increase-reward-cycle-entry\n            (get reward-set-indexes stacker-state)\n            (some { first-cycle: first-increased-cycle,\n                    reward-cycle: (get first-reward-cycle stacker-state),\n                    stacker: tx-sender,\n                    add-amount: increase-by,\n                    signer-key: signer-key })))\n            (err ERR_INVALID_INCREASE))\n      ;; NOTE: stacking-state map is unchanged: it does not track amount-stacked in PoX-4\n      (ok { stacker: tx-sender, total-locked: (+ amount-stacked increase-by)})))\n\n;; Extend an active Stacking lock.\n;; *New in Stacks 2.1*\n;; This method extends the `tx-sender`'s current lockup for an additional `extend-count`\n;;    and associates `pox-addr` with the rewards, The `signer-key` will be the key\n;;    used for signing. The `tx-sender` can thus decide to change the key when extending.\n;; \n;; Because no additional STX are locked in this function, the `amount` field used\n;; to verify the signer key authorization is zero. Refer to `verify-signer-key-sig` for more information.\n(define-public (stack-extend (extend-count uint)\n                             (pox-addr { version: (buff 1), hashbytes: (buff 32) })\n                             (signer-sig (optional (buff 65)))\n                             (signer-key (buff 33))\n                             (max-amount uint)\n                             (auth-id uint))\n   (let ((stacker-info (stx-account tx-sender))\n         ;; to extend, there must already be an etry in the stacking-state\n         (stacker-state (unwrap! (get-stacker-info tx-sender) (err ERR_STACK_EXTEND_NOT_LOCKED)))\n         (amount-ustx (get locked stacker-info))\n         (unlock-height (get unlock-height stacker-info))\n         (cur-cycle (current-pox-reward-cycle))\n         ;; first-extend-cycle will be the cycle in which tx-sender *would have* unlocked\n         (first-extend-cycle (burn-height-to-reward-cycle unlock-height))\n         ;; new first cycle should be max(cur-cycle, stacker-state.first-reward-cycle)\n         (cur-first-reward-cycle (get first-reward-cycle stacker-state))\n         (first-reward-cycle (if (> cur-cycle cur-first-reward-cycle) cur-cycle cur-first-reward-cycle)))\n\n    ;; must be called with positive extend-count\n    (asserts! (>= extend-count u1)\n              (err ERR_STACKING_INVALID_LOCK_PERIOD))\n\n    ;; stacker must be directly stacking\n      (asserts! (> (len (get reward-set-indexes stacker-state)) u0)\n                (err ERR_STACKING_IS_DELEGATED))\n\n    ;; stacker must not be delegating\n    (asserts! (is-none (get delegated-to stacker-state))\n              (err ERR_STACKING_IS_DELEGATED))\n\n    ;; Verify signature from delegate that allows this sender for this cycle\n    (try! (consume-signer-key-authorization pox-addr cur-cycle \"stack-extend\" extend-count signer-sig signer-key u0 max-amount auth-id))\n\n    (let ((last-extend-cycle  (- (+ first-extend-cycle extend-count) u1))\n          (lock-period (+ u1 (- last-extend-cycle first-reward-cycle)))\n          (new-unlock-ht (reward-cycle-to-burn-height (+ u1 last-extend-cycle))))\n\n      ;; first cycle must be after the current cycle\n      (asserts! (> first-extend-cycle cur-cycle) (err ERR_STACKING_INVALID_LOCK_PERIOD))\n      ;; lock period must be positive\n      (asserts! (> lock-period u0) (err ERR_STACKING_INVALID_LOCK_PERIOD))\n\n      ;; must be called directly by the tx-sender or by an allowed contract-caller\n      (asserts! (check-caller-allowed)\n                (err ERR_STACKING_PERMISSION_DENIED))\n\n      ;; tx-sender must be locked\n      (asserts! (> amount-ustx u0)\n        (err ERR_STACK_EXTEND_NOT_LOCKED))\n\n      ;; tx-sender must not be delegating\n      (asserts! (is-none (get-check-delegation tx-sender))\n        (err ERR_STACKING_ALREADY_DELEGATED))\n\n      ;; standard can-stack-stx checks\n      (try! (can-stack-stx pox-addr amount-ustx first-extend-cycle lock-period))\n\n      ;; register the PoX address with the amount stacked\n      ;;   for the new cycles\n      (let ((extended-reward-set-indexes (try! (add-pox-addr-to-reward-cycles pox-addr first-extend-cycle extend-count amount-ustx tx-sender signer-key)))\n            (reward-set-indexes\n                ;; use the active stacker state and extend the existing reward-set-indexes\n                (let ((cur-cycle-index (- first-reward-cycle (get first-reward-cycle stacker-state)))\n                      (old-indexes (get reward-set-indexes stacker-state))\n                      ;; build index list by taking the old-indexes starting from cur cycle\n                      ;;  and adding the new indexes to it. this way, the index is valid starting from the current cycle\n                      (new-list (concat (default-to (list) (slice? old-indexes cur-cycle-index (len old-indexes)))\n                                        extended-reward-set-indexes)))\n                  (unwrap-panic (as-max-len? new-list u12)))))\n          ;; update stacker record\n          (map-set stacking-state\n            { stacker: tx-sender }\n            { pox-addr: pox-addr,\n              reward-set-indexes: reward-set-indexes,\n              first-reward-cycle: first-reward-cycle,\n              lock-period: lock-period,\n              delegated-to: none })\n\n        ;; return lock-up information\n        (ok { stacker: tx-sender, unlock-burn-height: new-unlock-ht })))))\n\n;; As a delegator, increase an active Stacking lock, issuing a \"partial commitment\" for the\n;;   increased cycles.\n;; *New in Stacks 2.1*\n;; This method increases `stacker`'s current lockup and partially commits the additional\n;;   STX to `pox-addr`\n(define-public (delegate-stack-increase\n                    (stacker principal)\n                    (pox-addr { version: (buff 1), hashbytes: (buff 32) })\n                    (increase-by uint))\n    (let ((stacker-info (stx-account stacker))\n          (existing-lock (get locked stacker-info))\n          (available-stx (get unlocked stacker-info))\n          (unlock-height (get unlock-height stacker-info)))\n\n     ;; must be called with positive `increase-by`\n     (asserts! (>= increase-by u1)\n               (err ERR_STACKING_INVALID_AMOUNT))\n\n     (let ((unlock-in-cycle (burn-height-to-reward-cycle unlock-height))\n           (cur-cycle (current-pox-reward-cycle))\n           (first-increase-cycle (+ cur-cycle u1))\n           (last-increase-cycle (- unlock-in-cycle u1))\n           (cycle-count (try! (if (<= first-increase-cycle last-increase-cycle)\n                                  (ok (+ u1 (- last-increase-cycle first-increase-cycle)))\n                                  (err ERR_STACKING_INVALID_LOCK_PERIOD))))\n           (new-total-locked (+ increase-by existing-lock))\n           (stacker-state\n                (unwrap! (map-get? stacking-state { stacker: stacker })\n                 (err ERR_STACK_INCREASE_NOT_LOCKED))))\n\n      ;; must be called directly by the tx-sender or by an allowed contract-caller\n      (asserts! (check-caller-allowed)\n        (err ERR_STACKING_PERMISSION_DENIED))\n\n      ;; stacker must not be directly stacking\n      (asserts! (is-eq (len (get reward-set-indexes stacker-state)) u0)\n                (err ERR_STACKING_NOT_DELEGATED))\n\n      ;; stacker must be delegated to tx-sender\n      (asserts! (is-eq (unwrap! (get delegated-to stacker-state)\n                                (err ERR_STACKING_NOT_DELEGATED))\n                       tx-sender)\n                (err ERR_STACKING_PERMISSION_DENIED))\n\n      ;; stacker must be currently locked\n      (asserts! (> existing-lock u0)\n        (err ERR_STACK_INCREASE_NOT_LOCKED))\n\n      ;; stacker must have enough stx to lock\n      (asserts! (>= available-stx increase-by)\n        (err ERR_STACKING_INSUFFICIENT_FUNDS))\n\n      ;; stacker must have delegated to the caller\n      (let ((delegation-info (unwrap! (get-check-delegation stacker) (err ERR_STACKING_PERMISSION_DENIED)))\n            (delegated-to (get delegated-to delegation-info))\n            (delegated-amount (get amount-ustx delegation-info))\n            (delegated-pox-addr (get pox-addr delegation-info))\n            (delegated-until (get until-burn-ht delegation-info)))\n        ;; must have delegated to tx-sender\n        (asserts! (is-eq delegated-to tx-sender)\n                  (err ERR_STACKING_PERMISSION_DENIED))\n        ;; must have delegated enough stx\n        (asserts! (>= delegated-amount new-total-locked)\n                  (err ERR_DELEGATION_TOO_MUCH_LOCKED))\n        ;; if pox-addr is set, must be equal to pox-addr\n        (asserts! (match delegated-pox-addr\n                         specified-pox-addr (is-eq pox-addr specified-pox-addr)\n                         true)\n                  (err ERR_DELEGATION_POX_ADDR_REQUIRED))\n        ;; delegation must not expire before lock period\n        (asserts! (match delegated-until\n                        until-burn-ht\n                            (>= until-burn-ht unlock-height)\n                        true)\n                  (err ERR_DELEGATION_EXPIRES_DURING_LOCK)))\n\n      ;; delegate stacking does minimal-can-stack-stx\n      (try! (minimal-can-stack-stx pox-addr new-total-locked first-increase-cycle (+ u1 (- last-increase-cycle first-increase-cycle))))\n\n      ;; register the PoX address with the amount stacked via partial stacking\n      ;;   before it can be included in the reward set, this must be committed!\n      (add-pox-partial-stacked pox-addr first-increase-cycle cycle-count increase-by)\n\n      ;; stacking-state is unchanged, so no need to update\n\n      ;; return the lock-up information, so the node can actually carry out the lock.\n      (ok { stacker: stacker, total-locked: new-total-locked}))))\n\n;; As a delegator, extend an active stacking lock, issuing a \"partial commitment\" for the\n;;   extended-to cycles.\n;; *New in Stacks 2.1*\n;; This method extends `stacker`'s current lockup for an additional `extend-count`\n;;    and partially commits those new cycles to `pox-addr`\n(define-public (delegate-stack-extend\n                    (stacker principal)\n                    (pox-addr { version: (buff 1), hashbytes: (buff 32) })\n                    (extend-count uint))\n    (let ((stacker-info (stx-account stacker))\n          ;; to extend, there must already be an entry in the stacking-state\n          (stacker-state (unwrap! (get-stacker-info stacker) (err ERR_STACK_EXTEND_NOT_LOCKED)))\n          (amount-ustx (get locked stacker-info))\n          (unlock-height (get unlock-height stacker-info))\n          ;; first-extend-cycle will be the cycle in which tx-sender *would have* unlocked\n          (first-extend-cycle (burn-height-to-reward-cycle unlock-height))\n          (cur-cycle (current-pox-reward-cycle))\n          ;; new first cycle should be max(cur-cycle, stacker-state.first-reward-cycle)\n          (cur-first-reward-cycle (get first-reward-cycle stacker-state))\n          (first-reward-cycle (if (> cur-cycle cur-first-reward-cycle) cur-cycle cur-first-reward-cycle)))\n\n     ;; must be called with positive extend-count\n     (asserts! (>= extend-count u1)\n               (err ERR_STACKING_INVALID_LOCK_PERIOD))\n\n     (let ((last-extend-cycle  (- (+ first-extend-cycle extend-count) u1))\n           (lock-period (+ u1 (- last-extend-cycle first-reward-cycle)))\n           (new-unlock-ht (reward-cycle-to-burn-height (+ u1 last-extend-cycle))))\n\n      ;; first cycle must be after the current cycle\n      (asserts! (> first-extend-cycle cur-cycle) (err ERR_STACKING_INVALID_LOCK_PERIOD))\n      ;; lock period must be positive\n      (asserts! (> lock-period u0) (err ERR_STACKING_INVALID_LOCK_PERIOD))\n\n      ;; must be called directly by the tx-sender or by an allowed contract-caller\n      (asserts! (check-caller-allowed)\n        (err ERR_STACKING_PERMISSION_DENIED))\n\n      ;; stacker must not be directly stacking\n      (asserts! (is-eq (len (get reward-set-indexes stacker-state)) u0)\n                (err ERR_STACKING_NOT_DELEGATED))\n\n      ;; stacker must be delegated to tx-sender\n      (asserts! (is-eq (unwrap! (get delegated-to stacker-state)\n                                (err ERR_STACKING_NOT_DELEGATED))\n                       tx-sender)\n                (err ERR_STACKING_PERMISSION_DENIED))\n\n      ;; check valid lock period\n      (asserts! (check-pox-lock-period lock-period)\n        (err ERR_STACKING_INVALID_LOCK_PERIOD))\n\n      ;; stacker must be currently locked\n      (asserts! (> amount-ustx u0)\n        (err ERR_STACK_EXTEND_NOT_LOCKED))\n\n      ;; stacker must have delegated to the caller\n      (let ((delegation-info (unwrap! (get-check-delegation stacker) (err ERR_STACKING_PERMISSION_DENIED))))\n        ;; must have delegated to tx-sender\n        (asserts! (is-eq (get delegated-to delegation-info) tx-sender)\n                  (err ERR_STACKING_PERMISSION_DENIED))\n        ;; must have delegated enough stx\n        (asserts! (>= (get amount-ustx delegation-info) amount-ustx)\n                  (err ERR_DELEGATION_TOO_MUCH_LOCKED))\n        ;; if pox-addr is set, must be equal to pox-addr\n        (asserts! (match (get pox-addr delegation-info)\n                         specified-pox-addr (is-eq pox-addr specified-pox-addr)\n                         true)\n                  (err ERR_DELEGATION_POX_ADDR_REQUIRED))\n        ;; delegation must not expire before lock period\n        (asserts! (match (get until-burn-ht delegation-info)\n                         until-burn-ht (>= until-burn-ht\n                                           new-unlock-ht)\n                      true)\n                  (err ERR_DELEGATION_EXPIRES_DURING_LOCK))\n        )\n\n      ;; delegate stacking does minimal-can-stack-stx\n      (try! (minimal-can-stack-stx pox-addr amount-ustx first-extend-cycle lock-period))\n\n      ;; register the PoX address with the amount stacked via partial stacking\n      ;;   before it can be included in the reward set, this must be committed!\n      (add-pox-partial-stacked pox-addr first-extend-cycle extend-count amount-ustx)\n\n      (map-set stacking-state\n        { stacker: stacker }\n        { pox-addr: pox-addr,\n          reward-set-indexes: (list),\n          first-reward-cycle: first-reward-cycle,\n          lock-period: lock-period,\n          delegated-to: (some tx-sender) })\n\n      ;; return the lock-up information, so the node can actually carry out the lock.\n      (ok { stacker: stacker,\n            unlock-burn-height: new-unlock-ht }))))\n\n;; Add an authorization for a signer key.\n;; When an authorization is added, the `signer-sig` argument is not required\n;; in the functions that use it as an argument.\n;; The `allowed` flag can be used to either enable or disable the authorization.\n;; Only the Stacks principal associated with `signer-key` can call this function.\n;;\n;; Refer to the documentation for `verify-signer-key-sig` for more information\n;; regarding the parameters used in an authorization. When the authorization is used\n;; in `stack-stx` and `stack-extend`, the `reward-cycle` refers to the reward cycle\n;; where the transaction is confirmed, **not** the reward cycle where stacking begins.\n;; The `period` parameter must match the exact lock period (or extend count) used\n;; in the stacking transaction. The `max-amount` parameter specifies the maximum amount\n;; of STX that can be locked in an individual stacking transaction. `auth-id` is a\n;; random uint to prevent replays.\n;;\n;; *New in Stacks 3.0*\n(define-public (set-signer-key-authorization (pox-addr { version: (buff 1), hashbytes: (buff 32)})\n                                             (period uint)\n                                             (reward-cycle uint)\n                                             (topic (string-ascii 14))\n                                             (signer-key (buff 33))\n                                             (allowed bool)\n                                             (max-amount uint)\n                                             (auth-id uint))\n  (begin\n    ;; must be called directly by the tx-sender or by an allowed contract-caller\n    (asserts! (check-caller-allowed)\n      (err ERR_NOT_ALLOWED))\n    ;; Validate that `tx-sender` has the same pubkey hash as `signer-key`\n    (asserts! (is-eq\n      (unwrap! (principal-construct? (if is-in-mainnet STACKS_ADDR_VERSION_MAINNET STACKS_ADDR_VERSION_TESTNET) (hash160 signer-key)) (err ERR_INVALID_SIGNER_KEY))\n      tx-sender) (err ERR_NOT_ALLOWED))\n    ;; Must be called with positive period\n    (asserts! (>= period u1) (err ERR_STACKING_INVALID_LOCK_PERIOD))\n    ;; Must be current or future reward cycle\n    (asserts! (>= reward-cycle (current-pox-reward-cycle)) (err ERR_INVALID_REWARD_CYCLE))\n    (map-set signer-key-authorizations { pox-addr: pox-addr, period: period, reward-cycle: reward-cycle, topic: topic, signer-key: signer-key, auth-id: auth-id, max-amount: max-amount } allowed)\n    (ok allowed)))\n\n;; Get the _current_ PoX stacking delegation information for a stacker.  If the information\n;; is expired, or if there's never been such a stacker, then returns none.\n;; *New in Stacks 2.1*\n(define-read-only (get-delegation-info (stacker principal))\n    (get-check-delegation stacker)\n)\n\n;; Get the burn height at which a particular contract is allowed to stack for a particular principal.\n;; *New in Stacks 2.1*\n;; Returns (some (some X)) if X is the burn height at which the allowance terminates\n;; Returns (some none) if the caller is allowed indefinitely\n;; Returns none if there is no allowance record\n(define-read-only (get-allowance-contract-callers (sender principal) (calling-contract principal))\n    (map-get? allowance-contract-callers { sender: sender, contract-caller: calling-contract })\n)\n\n;; How many PoX addresses in this reward cycle?\n;; *New in Stacks 2.1*\n(define-read-only (get-num-reward-set-pox-addresses (reward-cycle uint))\n    (match (map-get? reward-cycle-pox-address-list-len { reward-cycle: reward-cycle })\n        num-addrs\n            (get len num-addrs)\n        u0\n    )\n)\n\n;; How many uSTX have been locked up for this address so far, before the delegator commits them?\n;; *New in Stacks 2.1*\n(define-read-only (get-partial-stacked-by-cycle (pox-addr { version: (buff 1), hashbytes: (buff 32) }) (reward-cycle uint) (sender principal))\n    (map-get? partial-stacked-by-cycle { pox-addr: pox-addr, reward-cycle: reward-cycle, sender: sender })\n)\n",
    "analysis": {
      "summary": "The contract implements PoX (Proof of Transfer) stacking functionalities, including stacking, delegation, and reward distribution for the Stacks blockchain.",
      "explanation": "**Key Variables and Constants**\n\nError Handling & Versions <L3-54>:\n- Extensive error codes for different failure scenarios\n- Constants for address versions\n- Stacks-specific address parameters\n\nPoX Parameters <L67-90>:\n- Reward cycle configurations\n- Minimum/maximum cycle lengths\n- Core PoX state variables\n\n**Core Functions**\n\nset-burnchain-parameters <L92-104>: one-time initialization function that sets up crucial PoX parameters:\n- first-burn-height: starting block\n- prepare-cycle-length: prep phase duration\n- reward-cycle-length: main cycle length\n- begin-pox-4-reward-cycle: PoX 4 start cycle\n\nthe cool thing here is it's immutable after first setup - can only be called once, which is a nice safety feature\n\nstack-stx <L571-621>: the main stacking function that lets users lock their STX:\n- handles direct stacking participation\n- manages reward cycle registration\n- includes solid safety checks for funds and stacking status\n- takes optional signing params for more complex setups\n\ndelegate-stx <L642-685>: delegation system that adds flexibility to the stacking model:\n- lets users authorize others to stack their STX\n- has configurable timeouts\n- maintains clear delegation relationships\n\nget-stacker-info <L279-290>: view function to check stacking status:\n- returns current stacking state\n- validates lock expiration\n\n**Notable Features**\n\n- really thorough error handling system\n- flexible participation model with both direct and delegated stacking\n- strong safety checks throughout\n- clean data architecture for upgrades\n\ngotta say the error handling is particularly well done here - they clearly thought through all the edge cases",
      "tags": ["staking", "governance", "utility", "protocol"]
    }
  },
  {
    "rank": 10,
    "contract": "SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-oracle-v2-3",
    "calls": 5142,
    "source": ";; @contract Arkadiko multisig oracle\n;; @version 2.3\n\n(impl-trait .arkadiko-oracle-trait-v1.oracle-trait)\n\n;; ---------------------------------------------------------\n;; Constants\n;; ---------------------------------------------------------\n\n(define-constant ERR-NOT-AUTHORIZED u8401)\n(define-constant ERR-OLD-MESSAGE u8402)\n(define-constant ERR-SIGNATURES-NOT-UNIQUE u8403)\n\n;; ---------------------------------------------------------\n;; Variables\n;; ---------------------------------------------------------\n\n(define-data-var minimum-valid-signers uint u3)\n\n;; ---------------------------------------------------------\n;; Maps\n;; ---------------------------------------------------------\n\n(define-map prices\n  { token: (string-ascii 12) }\n  {\n    last-price: uint,\n    last-block: uint,\n    decimals: uint\n  }\n)\n\n(define-map trusted-oracles (buff 33) bool)\n(define-map signatures-used (buff 65) bool)\n\n(define-map token-id-to-names uint (list 4 (string-ascii 12)))\n(define-map token-name-to-id (string-ascii 12) uint)\n\n;; ---------------------------------------------------------\n;; Getters\n;; ---------------------------------------------------------\n\n;; @desc check if given public key is trusted\n(define-read-only (is-trusted-oracle (pubkey (buff 33)))\n  (default-to false (map-get? trusted-oracles pubkey))\n)\n\n;; @desc check if given signature is already used\n(define-read-only (is-signature-used (signature (buff 65)))\n  (default-to false (map-get? signatures-used signature))\n)\n\n;; @desc get token ID for given name\n(define-read-only (get-token-id-from-name (name (string-ascii 12)))\n  (default-to u0 (map-get? token-name-to-id name))\n)\n\n;; @desc get list of token names for given token ID\n(define-read-only (get-token-names-from-id (id uint))\n  (default-to (list ) (map-get? token-id-to-names id))\n)\n\n;; @desc get minimum valid signers needed\n(define-read-only (get-minimum-valid-signers)\n  (var-get minimum-valid-signers)\n)\n\n;; @desc get price info for given token name\n(define-read-only (get-price (token (string-ascii 12)))\n  (unwrap! (map-get? prices { token: token }) { last-price: u0, last-block: u0, decimals: u0 })\n)\n\n;; @desc get price info response for given token name\n(define-public (fetch-price (token (string-ascii 12)))\n  (ok (get-price token))\n)\n\n;; ---------------------------------------------------------\n;; Message signing\n;; ---------------------------------------------------------\n\n;; @desc update token price as DAO owner\n;; @param token; token to update price for\n;; @param price; price value\n;; @param decimals; amount of decimals\n;; @post bool; returns true\n(define-public (update-price-owner (token-id uint) (price uint) (decimals uint))\n  (begin\n    (asserts! (is-eq tx-sender (contract-call? .arkadiko-dao get-dao-owner)) (err ERR-NOT-AUTHORIZED))\n    (unwrap-panic (update-price-multi-helper token-id price decimals))\n    (ok price)\n  )\n)\n\n;; @desc update token price as multisig node\n;; @param block; the block on which the message was created\n;; @param token-id; token ID to update price for\n;; @param price; price value\n;; @param decimals; amount of decimals\n;; @param signatures; list of signatures from oracle nodes\n;; @post bool; returns true if successful\n(define-public (update-price-multi (block uint) (token-id uint) (price uint) (decimals uint) (signatures (list 10 (buff 65))))\n  (let (\n    (block-list (list block block block block block block block block block block))\n    (token-id-list (list token-id token-id token-id token-id token-id token-id token-id token-id token-id token-id))\n    (price-list (list price price price price price price price price price price))\n    (decimals-list (list decimals decimals decimals decimals decimals decimals decimals decimals decimals decimals))\n\n    (check-result (fold + (map check-price-signer block-list token-id-list price-list decimals-list signatures) u0))\n  )\n    (asserts! (< burn-block-height (+ block u10)) (err ERR-OLD-MESSAGE))\n    (asserts! (is-eq (fold and (map check-unique-signatures-iter signatures) true) true) (err ERR-SIGNATURES-NOT-UNIQUE))\n\n    (if (>= check-result (var-get minimum-valid-signers))\n      (update-price-multi-helper token-id price decimals)\n      (ok false)\n    )\n  )\n)\n\n;; Helper method to update price for given token ID\n;; Will iterate over all token names based on token ID\n(define-private (update-price-multi-helper (token-id uint) (price uint) (decimals uint) )\n  (let (\n    (names-list (get-token-names-from-id token-id))\n    (prices-list (list price price price price))\n    (decimals-list (list decimals decimals decimals decimals))\n  )\n    (map update-price-token-iter names-list prices-list decimals-list)\n    (ok true)\n  )\n)\n\n;; Helper method to iterate over all token names and update prices\n(define-private (update-price-token-iter (token (string-ascii 12)) (price uint) (decimals uint))\n  (begin\n    (map-set prices { token: token } { last-price: price, last-block: burn-block-height, decimals: decimals })\n    (ok true)\n  )\n)\n\n;; Helper method to iterate over all signatures in a list\n;; The signatures are added to a map, so that a signature can only be used once\n(define-private (check-unique-signatures-iter (signature (buff 65)))\n  (if (is-signature-used signature)\n    false\n    (begin\n      (map-set signatures-used signature true)\n      true\n    )\n  )\n)\n\n;; ---------------------------------------------------------\n;; Message signers\n;; ---------------------------------------------------------\n\n;; Recover the public key given the values and a signature\n(define-read-only (pubkey-price-signer (block uint) (token-id uint) (price uint) (decimals uint) (signature (buff 65)))\n  (secp256k1-recover? (get-signable-message-hash block token-id price decimals) signature)\n)\n\n;; Recover the public key given the values and a signature, check if trusted\n;; If not trusted it could be that the oracle itself is not trusted, or the values have been tampered with\n(define-read-only (check-price-signer (block uint) (token-id uint) (price uint) (decimals uint) (signature (buff 65)))\n  (let (\n    (pubKey (unwrap! (pubkey-price-signer block token-id price decimals signature) u0))\n  )\n    (if (is-trusted-oracle pubKey) u1 u0)\n  )\n)\n\n;; ---------------------------------------------------------\n;; Signable message\n;; ---------------------------------------------------------\n\n;; Create a message hash to sign, given price values\n(define-read-only (get-signable-message-hash (block uint) (token-id uint) (price uint) (decimals uint))\n  (keccak256 (concat (concat (concat (uint256-to-buff-be block) (uint256-to-buff-be token-id)) (uint256-to-buff-be price)) (uint256-to-buff-be decimals)))\n)\n\n(define-read-only (uint256-to-buff-be (n uint))\n  (unwrap-panic (as-max-len? (get a (fold uint-to-buff-iter 0x0000000000000000000000000000000000000000000000000000000000000000 {n: n, a: 0x})) u32))\n)\n\n(define-constant byte-list 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff)\n\n(define-private (uint-to-buff-iter (b (buff 1)) (p {n: uint, a: (buff 32)}))\n  {\n    a: (unwrap-panic (as-max-len? (concat (if (is-eq (get n p) u0) 0x00 (unwrap-panic (element-at byte-list (mod (get n p) u256)))) (get a p)) u32)),\n    n: (/ (get n p) u256)\n  }\n)\n\n;; ---------------------------------------------------------\n;; Admin\n;; ---------------------------------------------------------\n\n;; Link token ID to token name\n(define-public (set-token-id (token-id uint) (token-name (string-ascii 12)))\n  (let (\n    (current-list (get-token-names-from-id token-id))\n    (new-list (unwrap-panic (as-max-len? (append current-list token-name) u4)))\n  )\n    (asserts! (is-eq tx-sender (contract-call? .arkadiko-dao get-dao-owner)) (err ERR-NOT-AUTHORIZED))\n\n    (map-set token-id-to-names token-id new-list)\n    (map-set token-name-to-id token-name token-id)\n    (ok true)\n  )\n)\n\n;; Set minimum signers needed to update price\n(define-public (set-minimum-valid-signers (minimum uint))\n  (begin\n    (asserts! (is-eq tx-sender (contract-call? .arkadiko-dao get-dao-owner)) (err ERR-NOT-AUTHORIZED))\n    \n    (var-set minimum-valid-signers minimum)\n    (ok true)\n  )\n)\n\n;; Add trusted oracle public keys\n(define-public (set-trusted-oracle (pubkey (buff 33)) (trusted bool))\n  (begin\n    (asserts! (is-eq tx-sender (contract-call? .arkadiko-dao get-dao-owner)) (err ERR-NOT-AUTHORIZED))\n\n    (map-set trusted-oracles pubkey trusted)\n    (ok true)\n  )\n)\n\n;; ---------------------------------------------------------\n;; Init\n;; ---------------------------------------------------------\n\n(begin\n  (map-set token-id-to-names u1 (list \"STX\" \"xSTX\"))\n  (map-set token-name-to-id \"STX\" u1)\n  (map-set token-name-to-id \"xSTX\" u1)\n\n  (map-set token-id-to-names u2 (list \"BTC\" \"xBTC\"))\n  (map-set token-name-to-id \"BTC\" u2)\n  (map-set token-name-to-id \"xBTC\" u2)\n\n  (map-set token-id-to-names u3 (list \"USDA\"))\n  (map-set token-name-to-id \"USDA\" u3)\n\n  (map-set token-id-to-names u4 (list \"STX/USDA\"))\n  (map-set token-name-to-id \"STX/USDA\" u4)\n\n  (map-set token-id-to-names u5 (list \"DIKO\"))\n  (map-set token-name-to-id \"DIKO\" u5)\n\n  (map-set token-id-to-names u6 (list \"atALEX\" \"auto-alex\"))\n  (map-set token-name-to-id \"atALEX\" u6)\n  (map-set token-name-to-id \"auto-alex\" u6)\n\n  (map-set token-id-to-names u7 (list \"atALEXv2\" \"auto-alex-v2\"))\n  (map-set token-name-to-id \"atALEXv2\" u7)\n  (map-set token-name-to-id \"auto-alex-v2\" u7)\n\n  (map-set token-id-to-names u8 (list \"stSTX\" \"ststx-token\"))\n  (map-set token-name-to-id \"stSTX\" u8)\n  (map-set token-name-to-id \"ststx-token\" u8)\n)\n",
    "analysis": {
      "summary": "This contract is a multisig oracle for updating and managing token prices on the Arkadiko platform.",
      "explanation": "The contract integrates with the Arkadiko oracle trait and allows updating token prices through a multisig mechanism. It includes safety checks to ensure only authorized and unique signatures can update prices, and it maintains a mapping of token IDs to names for easy reference.\n\n1. Constants <L10-12> define error codes for unauthorized access, outdated messages, and non-unique signatures.\n\n2. A single data variable 'minimum-valid-signers' <L18> tracks the minimum number of valid signatures required to update a token's price.\n\n3. Maps:\n   - 'prices' <L24-30> stores token price information.\n   - 'trusted-oracles' <L33> tracks which public keys are authorized to sign price updates.\n   - 'signatures-used' <L34> ensures a signature can only be used once.\n   - 'token-id-to-names' and 'token-name-to-id' <L36-37> link token IDs to their names and vice versa.\n\n4. Getters <L43-71> provide read-only access to check if a public key is trusted, if a signature has been used, retrieve token IDs/names, the minimum valid signers, and current prices.\n\n5. The 'fetch-price' function <L73-76> is a public interface to retrieve price information for a given token name.\n\n6. 'update-price-owner' <L87-92> allows the DAO owner to update a token's price directly.\n\n7. 'update-price-multi' <L102-118> enables price updates through a multisig mechanism, requiring a minimum number of valid signatures from trusted oracles.\n\n8. Helper functions <L121-193> support the main functionalities by updating prices, checking signatures, and converting uints to buffers for hashing.\n\n9. Administrative functions <L199-231> allow the DAO owner to link token IDs to names, set the minimum valid signers, and add or remove trusted oracles.\n\n10. The contract initialization <L237-266> pre-defines a set of token IDs and names.\n\nNotable qualities include the use of multisig for critical operations, ensuring high security for price updates, and the detailed mapping of token IDs to names for clarity and ease of reference.",
      "tags": ["oracle", "multisig", "DeFi", "protocol"]
    }
  },
  {
    "rank": 11,
    "contract": "SP2VCQJGH7PHP2DJK7Z0V48AGBHQAW3R3ZW1QF4N.borrow-helper-v2-0-0",
    "calls": 4909,
    "source": "(use-trait ft .ft-trait.ft-trait)\n(use-trait ft-mint-trait .ft-mint-trait.ft-mint-trait)\n(use-trait a-token .a-token-trait.a-token-trait)\n(use-trait flash-loan .flash-loan-trait.flash-loan-trait)\n(use-trait oracle-trait .oracle-trait.oracle-trait)\n(use-trait redeemeable-token .redeemeable-trait-v1-2.redeemeable-trait)\n\n\n(define-constant ERR_UNAUTHORIZED (err u1000000000000))\n\n(define-public (supply\n  (lp <redeemeable-token>)\n  (pool-reserve principal)\n  (asset <ft>)\n  (amount uint)\n  (owner principal)\n  (referral (optional principal)))\n  (let ((asset-principal (contract-of asset)))\n\n    (asserts! (is-eq tx-sender contract-caller) ERR_UNAUTHORIZED)\n    (try! (contract-call? .pool-borrow-v2-0 supply lp pool-reserve asset amount owner))\n\n    (print { type: \"supply-call\", payload: { key: owner, data: {\n      reserve-state: (try! (contract-call? .pool-0-reserve-v2-0 get-reserve-state asset-principal)),\n      user-reserve-state: (contract-call? .pool-0-reserve-v2-0 get-user-reserve-data owner asset-principal),\n      user-index: (contract-call? .pool-0-reserve-v2-0 get-user-index owner asset-principal),\n      user-assets: (contract-call? .pool-0-reserve-v2-0 get-user-assets owner),\n      asset: asset,\n      amount: amount,\n      new-balance: (try! (contract-call? lp get-balance owner)),\n      referral: referral,\n    }}})\n    (ok true)\n  )\n)\n\n(define-public (borrow\n  (pool-reserve principal)\n  (oracle <oracle-trait>)\n  (asset-to-borrow <ft>)\n  (lp <ft>)\n  (assets (list 100 { asset: <ft>, lp-token: <ft>, oracle: <oracle-trait> }))\n  (amount-to-be-borrowed uint)\n  (fee-calculator principal)\n  (interest-rate-mode uint)\n  (owner principal))\n  (let ((asset-principal (contract-of asset-to-borrow)))\n\n    (asserts! (is-eq tx-sender contract-caller) ERR_UNAUTHORIZED)\n    (try! (contract-call? .pool-borrow-v2-0 borrow pool-reserve oracle asset-to-borrow lp assets amount-to-be-borrowed fee-calculator interest-rate-mode owner))\n\n    (print { type: \"borrow-call\", payload: { key: owner, data: {\n        reserve-state: (try! (contract-call? .pool-0-reserve-v2-0 get-reserve-state asset-principal)),\n        user-reserve-state: (contract-call? .pool-0-reserve-v2-0 get-user-reserve-data owner asset-principal),\n        user-index: (contract-call? .pool-0-reserve-v2-0 get-user-index owner asset-principal),\n        user-assets: (contract-call? .pool-0-reserve-v2-0 get-user-assets owner),\n        asset: asset-to-borrow,\n        amount: amount-to-be-borrowed,\n        new-borrow-balance: (get compounded-balance (try! (contract-call? .pool-0-reserve-v2-0 get-user-borrow-balance owner asset-to-borrow))),\n      }}})\n    (ok true)\n  )\n)\n\n(define-public (repay\n  (asset <ft>)\n  (amount-to-repay uint)\n  (on-behalf-of principal)\n  (payer principal)\n  )\n  (let (\n    (asset-principal (contract-of asset))\n    (check-ok (asserts! (is-eq tx-sender contract-caller) ERR_UNAUTHORIZED))\n    (payback-amount (try! (contract-call? .pool-borrow-v2-0 repay asset amount-to-repay on-behalf-of payer)))\n    )\n\n    (print { type: \"repay-call\", payload: { key: on-behalf-of, data: {\n        reserve-state: (try! (contract-call? .pool-0-reserve-v2-0 get-reserve-state asset-principal)),\n        user-reserve-state: (contract-call? .pool-0-reserve-v2-0 get-user-reserve-data on-behalf-of asset-principal),\n        user-index: (contract-call? .pool-0-reserve-v2-0 get-user-index on-behalf-of asset-principal),\n        user-assets: (contract-call? .pool-0-reserve-v2-0 get-user-assets on-behalf-of),\n        asset: asset,\n        amount: payback-amount,\n        on-behalf-of: on-behalf-of,\n        payer: payer,\n        new-borrow-balance: (get compounded-balance (try! (contract-call? .pool-0-reserve-v2-0 get-user-borrow-balance on-behalf-of asset))),\n      }}})\n    (ok true)\n  )\n)\n\n(define-public (set-user-use-reserve-as-collateral\n  (who principal)\n  (lp-token <ft>)\n  (asset <ft>)\n  (enable-as-collateral bool)\n  (oracle <oracle-trait>)\n  (assets-to-calculate (list 100 { asset: <ft>, lp-token: <ft>, oracle: <oracle-trait> })))\n  (let (\n    (asset-principal (contract-of asset))\n    (reserve-state (try! (contract-call? .pool-0-reserve-v2-0 get-reserve-state asset-principal)))\n    )\n\n    (asserts! (is-eq tx-sender contract-caller) ERR_UNAUTHORIZED)\n    (try! (contract-call? .pool-borrow-v2-0 set-user-use-reserve-as-collateral who lp-token asset enable-as-collateral oracle assets-to-calculate))\n\n    (print { type: \"set-user-use-reserve-as-collateral-call\", payload: { key: who, data: {\n        reserve-state: (try! (contract-call? .pool-0-reserve-v2-0 get-reserve-state asset-principal)),\n        user-reserve-state: (contract-call? .pool-0-reserve-v2-0 get-user-reserve-data who asset-principal),\n        user-index: (contract-call? .pool-0-reserve-v2-0 get-user-index who asset-principal),\n        user-assets: (contract-call? .pool-0-reserve-v2-0 get-user-assets who),\n        asset: asset,\n      }}})\n    (ok true)\n  )\n)\n\n(define-public (withdraw\n  (lp <redeemeable-token>)\n  (pool-reserve principal)\n  (asset <ft>)\n  (oracle <oracle-trait>)\n  (amount uint)\n  (owner principal)\n  (assets (list 100 { asset: <ft>, lp-token: <ft-mint-trait>, oracle: <oracle-trait> }))\n  )\n  (let (\n    (asset-principal (contract-of asset))\n    (check-ok (asserts! (is-eq tx-sender contract-caller) ERR_UNAUTHORIZED))\n    (withdraw-res (try! (contract-call? .pool-borrow-v2-0 withdraw pool-reserve asset lp oracle assets amount owner)))\n    )\n\n    (print { type: \"withdraw-call\", payload: { key: owner, data: {\n        reserve-state: (try! (contract-call? .pool-0-reserve-v2-0 get-reserve-state asset-principal)),\n        user-reserve-state: (contract-call? .pool-0-reserve-v2-0 get-user-reserve-data owner asset-principal),\n        user-index: (contract-call? .pool-0-reserve-v2-0 get-user-index owner asset-principal),\n        user-assets: (contract-call? .pool-0-reserve-v2-0 get-user-assets owner),\n        asset: asset,\n        withdrawn-amount: withdraw-res,\n        balance: (try! (contract-call? lp get-balance owner)),\n      }}})\n    (ok true)\n  )\n)\n\n(define-public (liquidation-call\n  (assets (list 100 { asset: <ft>, lp-token: <ft>, oracle: <oracle-trait> }))\n  (collateral-lp <a-token>)\n  (collateral-to-liquidate <ft>)\n  (debt-asset <ft>)\n  (collateral-oracle <oracle-trait>)\n  (debt-oracle <oracle-trait>)\n  (liquidated-user principal)\n  (debt-amount uint)\n  (to-receive-atoken bool))\n  (let (\n    (debt-asset-principal (contract-of debt-asset))\n    (collateral-asset-principal (contract-of collateral-to-liquidate))\n    (liquidator tx-sender)\n    )\n\n    (asserts! (is-eq liquidator contract-caller) ERR_UNAUTHORIZED)\n\n    (try! (contract-call? .pool-borrow-v2-0 liquidation-call\n      assets\n      collateral-lp\n      collateral-to-liquidate\n      debt-asset\n      collateral-oracle\n      debt-oracle\n      liquidated-user\n      debt-amount\n      to-receive-atoken)\n    )\n    (print { type: \"liquidation-call\", payload: { key: liquidated-user, data: {\n        debt-reserve-state: (try! (contract-call? .pool-0-reserve-v2-0 get-reserve-state debt-asset-principal)),\n        collateral-reserve-state: (try! (contract-call? .pool-0-reserve-v2-0 get-reserve-state debt-asset-principal)),\n        \n        liquidator-debt-reserve-state: (contract-call? .pool-0-reserve-v2-0 get-user-reserve-data liquidator debt-asset-principal),\n        liquidator-debt-index: (contract-call? .pool-0-reserve-v2-0 get-user-index liquidator debt-asset-principal),\n        liquidator-collateral-reserve-state: (contract-call? .pool-0-reserve-v2-0 get-user-reserve-data liquidator collateral-asset-principal),\n        liquidator-collateral-index: (contract-call? .pool-0-reserve-v2-0 get-user-index liquidator collateral-asset-principal),\n        liquidator-user-assets: (contract-call? .pool-0-reserve-v2-0 get-user-assets liquidator),\n\n        liquidated-user-debt-reserve-state: (contract-call? .pool-0-reserve-v2-0 get-user-reserve-data liquidated-user debt-asset-principal),\n        liquidated-user-debt-index: (contract-call? .pool-0-reserve-v2-0 get-user-index liquidated-user debt-asset-principal),\n        liquidated-user-collateral-reserve-state: (contract-call? .pool-0-reserve-v2-0 get-user-reserve-data liquidated-user collateral-asset-principal),\n        liquidated-user-collateral-index: (contract-call? .pool-0-reserve-v2-0 get-user-index liquidated-user collateral-asset-principal),\n        liquidated-user-assets: (contract-call? .pool-0-reserve-v2-0 get-user-assets liquidated-user),\n\n        collateral-to-liquidate: collateral-to-liquidate,\n        debt-asset: debt-asset-principal,\n        debt-amount: debt-amount,\n      }}})\n    (ok u0)\n  )\n)\n\n(define-public (set-e-mode\n  (user principal)\n  (assets (list 100 { asset: <ft>, lp-token: <ft>, oracle: <oracle-trait> }))\n  (new-e-mode-type (buff 1))\n  )\n  (begin\n    (asserts! (is-eq tx-sender contract-caller) ERR_UNAUTHORIZED)\n    (try! (contract-call? .pool-borrow-v2-0 set-e-mode user assets new-e-mode-type))\n\n    (print { type: \"set-e-mode-call\", payload: { key: user, data: {\n        user-e-mode: (contract-call? .pool-reserve-data-2 get-user-e-mode-read user),\n      }}})\n    (ok true)\n  )\n)\n\n(define-public (flashloan\n  (receiver principal)\n  (asset <ft>)\n  (amount uint)\n  (flashloan-script <flash-loan>))\n  (begin\n    (asserts! (is-eq tx-sender contract-caller) ERR_UNAUTHORIZED)\n\n    (try! \n      (contract-call? .pool-borrow-v2-0 flashloan\n        receiver\n        asset\n        amount\n        flashloan-script))\n\n    (print { type: \"flashloan-call\", payload: { key: receiver, data: {\n      reserve-state: (try! (contract-call? .pool-0-reserve-v2-0 get-reserve-state (contract-of asset))),\n    }}})\n    (ok u0)\n  )\n)\n",
    "analysis": {
      "summary": "This contract interfaces with a lending pool to facilitate supply, borrow, repay, collateral management, withdrawal, liquidation, emergency mode settings, and flash loans for users.",
      "explanation": "The contract acts as an intermediary between users and a lending pool, handling various financial operations like supplying liquidity, borrowing, repaying loans, managing collateral, withdrawing liquidity, executing liquidations, setting emergency modes, and initiating flash loans. Each function interfaces with the lending pool's contract to perform the specified action and logs the operation details for transparency and tracking purposes. Here's a detailed breakdown of its components and functionalities: \n\n1. **Constants and Error Codes**\n- `ERR_UNAUTHORIZED` <L9>: A constant error code used to indicate unauthorized access, typically when the transaction sender is not the expected caller of a function.\n\n2. **Functions**\n- `supply` <L11-34>: Allows users to supply assets to the lending pool. It checks for authorization <L20>, calls the lending pool's supply function <L21>, and logs the operation <L23-32>.\n- `borrow` <L37-62>: Enables users to borrow assets from the lending pool. It includes authorization checks <L49>, interaction with the lending pool's borrow function <L50>, and operation logging <L52-59>.\n- `repay` <L65-89>: Facilitates users to repay borrowed assets. It includes authorization checks <L73>, calls the lending pool's repay function <L74>, and logs the repayment <L77-86>.\n- `set-user-use-reserve-as-collateral` <L92-115>: Allows users to set their assets as collateral. It checks for authorization <L104>, interacts with the lending pool to update collateral settings <L105>, and logs the operation <L107-113>.\n- `withdraw` <L118-143>: Enables users to withdraw their supplied assets. It includes authorization checks <L129>, calls the lending pool's withdraw function <L130>, and logs the withdrawal <L133-140>.\n- `liquidation-call` <L146-196>: Initiates a liquidation process against a user's collateral. It checks for authorization <L162>, calls the lending pool's liquidation function <L164-173>, and logs the liquidation details <L175-193>.\n- `set-e-mode` <L199-212>: Allows users to set an emergency mode for their assets. It includes authorization checks <L205>, interacts with the lending pool to set the emergency mode <L206>, and logs the operation <L208-210>.\n- `flashloan` <L215-234>: Facilitates flash loans, temporary loans without collateral. It checks for authorization <L221>, calls the lending pool's flashloan function <L223-228>, and logs the operation <L230-232>.\n\nEach function meticulously checks for authorization to ensure that only the intended users or contracts can execute them, enhancing security. The contract leverages Clarity's capabilities for interacting with other contracts and managing complex financial operations in a decentralized environment.",
      "tags": ["lending", "DeFi", "collateral-management", "flash-loans"]
    }
  },
  {
    "rank": 12,
    "contract": "SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.farming-v3b-logic",
    "calls": 4867,
    "source": "(use-trait liquidity-token .liquidity-token-trait-v4c.liquidity-token-trait)\n(use-trait oracle-trait .stackwap-oracle-trait-v1b.oracle-trait)\n(define-constant ERR_ZERO_LP_INPUT u4301)\n(define-constant ERR_INSUFFICIENT_LP_BALANCE u4302)\n(define-constant ERR_NOT_CORRECT_ROUND u4303)\n(define-constant ERR_NO_PREVIOUS_DATA u4304)\n(define-constant ERR_PERMISSION_DENIED u4305)\n(define-constant ERR_INVALID_ROUTER u4306)\n(define-constant ERR_POOL_NOT_FARMABLE u4307)\n(define-constant ERR_FARM_STOPPED u4308)\n(define-constant ERR_FARM_ENDED u4314)\n(define-constant ERR_CLAIMABLE_ROUNDS_EXCEEDED u4316)\n\n(define-constant FIRST_FARMING_BLOCK u70843)\n(define-constant REWARD_ROUND_LENGTH u504)\n(define-constant MAX_REWARD_ROUNDS u64)\n(define-constant REWARD_ROUND_INDEXES (list u0 u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13 u14 u15 u16 u17 u18 u19 u20 u21 u22 u23 u24 u25 u26 u27 u28 u29 u30 u31 u32 u33 u34 u35 u36 u37 u38 u39 u40 u41 u42 u43 u44 u45 u46 u47 u48 u49 u50 u51 u52 u53 u54 u55 u56 u57 u58 u59 u60 u61 u62 u63))\n(define-constant MIN_STAKING_ROUND_REWARDS u10000000)\n(define-data-var farm_end_round uint u9999999999)\n(define-data-var farm_start_round uint u65)\n\n(define-data-var emergency_stop bool true)\n\n(define-data-var UPDATED_ROUND uint u139)\n\n(define-private (is-dao (user principal)) \n    (ok (asserts! (is-eq user (contract-call? .stackswap-dao-v5k get-dao-owner)) (err ERR_PERMISSION_DENIED))))\n\n(define-read-only (getFarmingRound (stacksHeight uint))\n (if (>= stacksHeight FIRST_FARMING_BLOCK) (/ (- stacksHeight FIRST_FARMING_BLOCK) REWARD_ROUND_LENGTH) u0))\n\n(define-read-only (getGroupRewardsPerRound (target_round uint) (reward_basis uint))\n  (let (\n    (rounds_per_year u52)\n    (year_number (+ (/ target_round rounds_per_year) u1))\n    (staking_rewards_divider (pow u2 (/ (- year_number u1) u4)))\n    (actual_round_rewards (/ reward_basis staking_rewards_divider))\n  )\n      (if (>= actual_round_rewards MIN_STAKING_ROUND_REWARDS)\n        actual_round_rewards\n        MIN_STAKING_ROUND_REWARDS\n    )\n  )\n)\n\n(define-private (claimRewardInner (user principal) (round uint) (amount_staked uint) (pool principal) (group uint))\n  (let\n    (\n        (GroupHistory_ (contract-call? .stackswap-farming-v3-data getGroupHistoryOrDefault group round))\n        (LPHistory_ (contract-call? .stackswap-farming-v3-data getLPHistoryOrDefault pool round))\n        (userTVL (* (* (get Weight LPHistory_) (get Price LPHistory_)) amount_staked))\n        (currentRound (getFarmingRound block-height))\n    )\n    (if (or (<= currentRound round) (is-eq u0 userTVL) (< (var-get farm_end_round) round) (is-eq u0 (get GroupWeightedTVL GroupHistory_)))\n        true\n    (let (\n        (rewardAmt (/ (* (getGroupRewardsPerRound round (get GroupRewardAmt GroupHistory_)) userTVL) (get GroupWeightedTVL GroupHistory_)))\n        )\n        (if (> rewardAmt u0)\n            (begin  \n                (try! (contract-call? .stackswap-farming-v3-data transferReward user rewardAmt))\n            )\n            false\n        )\n    )\n    )\n    (ok true)\n  )\n)\n\n(define-private (claimRewardClosure (reward_round_idx uint)\n  (commitmentResponse (response \n    {\n      user: principal,\n      StakingLockedAmt: uint,\n      StartRoundAmt: uint,\n      pool: principal,\n      first: uint,\n      last: uint,\n      group: uint,\n    }\n    uint\n  )))\n\n  (match commitmentResponse\n    commitment \n    (let\n      (\n        (round (+ (get first commitment) reward_round_idx))\n      )\n      (begin\n        (if (and (>= round (get first commitment)) (< round (get last commitment)))\n            (if (is-eq round (get first commitment))\n                (try! (claimRewardInner (get user commitment) round (get StartRoundAmt commitment) (get pool commitment) (get group commitment)))\n                (try! (claimRewardInner (get user commitment) round (get StakingLockedAmt commitment) (get pool commitment) (get group commitment)))\n            )\n            false\n        )\n        commitmentResponse\n      )\n    )\n    errValue commitmentResponse\n  )\n)\n\n(define-private (claimRewardPrivate (pool principal)) \n    (let (\n            (user tx-sender)\n            (current_round (getFarmingRound block-height))\n            (LPUser_ (contract-call? .stackswap-farming-v3-data getLPUserOrDefault pool user))\n            (LP_ (contract-call? .stackswap-farming-v3-data getLPOrDefault pool))\n            (CurLPHistory_ (contract-call? .stackswap-farming-v3-data getLPHistoryOrDefault pool current_round))   \n            (end_round1 (if \n                (or \n                    (< current_round (get WithdrawEndRound LPUser_)) \n                    (is-eq (get WithdrawEndRound LPUser_) u0)\n                )\n                current_round\n                (+ (get WithdrawEndRound LPUser_) u1)))         \n            (end_round (if \n                (< end_round1 (+ u64 (get StartRound LPUser_)))\n                end_round1\n                (+ u64 (get StartRound LPUser_))\n                ))         \n        )\n        (asserts! (contract-call? .stackswap-farming-v3-data isFarmAvailable  pool) (err ERR_POOL_NOT_FARMABLE))\n        (asserts! (contract-call? .stackswap-security-list-v1a is-secure-router-or-user contract-caller) (err ERR_INVALID_ROUTER))\n        (if (and (> (+ (get StakingLockedAmt LPUser_) (get StartRoundAmt LPUser_)) u0) (>= end_round (+ (get StartRound LPUser_) u1)))\n            (begin\n                (try! (contract-call? .stackswap-farming-v3-data setLPUser\n                    pool\n                    user\n                    (merge LPUser_ {\n                        StartRound: end_round,\n                        StartRoundAmt: (get StakingLockedAmt LPUser_),\n                    })\n                ))\n                (try! (match (fold claimRewardClosure REWARD_ROUND_INDEXES (ok {\n                        user: user,\n                        StakingLockedAmt: (get StakingLockedAmt LPUser_),\n                        StartRoundAmt: (get StartRoundAmt LPUser_),\n                        pool: pool,\n                        first: (get StartRound LPUser_),\n                        last: end_round,\n                        group: (get Group LP_),\n                    }))\n                    okValue (ok true)\n                    errValue (err errValue)\n                ))\n                (ok (contract-call? .stackswap-farming-v3-data getLPUserOrDefault pool user))\n            )\n            (ok LPUser_)\n        )\n\n        \n    )\n)\n\n(define-public (stake (pool <liquidity-token>) (amount uint) (oracle <oracle-trait>))\n    (let (\n            (user tx-sender)\n            (current_round (getFarmingRound block-height))\n            (res (try! (updateRoundStatus pool current_round oracle)))\n            (start_round (var-get farm_start_round)) \n            (round (if (> start_round current_round) start_round current_round))\n            (LPUser_ (try! (claimRewardPrivate (contract-of pool))))\n            (LP_ (contract-call? .stackswap-farming-v3-data getLPOrDefault (contract-of pool)))\n            (CurLPHistory_ (contract-call? .stackswap-farming-v3-data getLPHistoryOrDefault (contract-of pool) round))\n        )\n        (asserts! (contract-call? .stackswap-farming-v3-data isFarmAvailable  (contract-of pool)) (err ERR_POOL_NOT_FARMABLE))\n        (asserts! (contract-call? .stackswap-security-list-v1a is-secure-router-or-user contract-caller) (err ERR_INVALID_ROUTER))\n        (asserts! (<= round (var-get farm_end_round)) (err ERR_FARM_ENDED))\n        (asserts! (> amount u0) (err ERR_ZERO_LP_INPUT))\n        (asserts! (or (is-eq (get StartRound LPUser_) u0) (is-eq (get StartRound LPUser_) current_round)) (err ERR_CLAIMABLE_ROUNDS_EXCEEDED))\n        (asserts! (not (var-get emergency_stop)) (err ERR_FARM_STOPPED))\n\n        (unwrap! (contract-call? pool transfer amount user .stackswap-farming-v3-data none) (err ERR_INSUFFICIENT_LP_BALANCE))\n        (try! (contract-call? .stackswap-farming-v3-data setLPUser\n             (contract-of pool) user\n            (merge LPUser_ {\n                ViewAmt: (+ (get ViewAmt LPUser_) amount),\n                StakingLockedAmt: (+ (get StakingLockedAmt LPUser_) amount),\n                StartRound: round,\n            })\n        ))\n        (try! (contract-call? .stackswap-farming-v3-data setLPHistory \n             (contract-of pool) round\n            (merge CurLPHistory_ {\n                NextDepositAmt: (+ (get NextDepositAmt CurLPHistory_) amount),\n            })\n        ))\n        (try! (updateRoundStatus pool current_round oracle))\n        (ok true)\n    )\n)\n\n(define-public (withdrawDirect (pool <liquidity-token>) (amount uint) (oracle <oracle-trait>))\n    (let (\n            (user tx-sender)\n            (current_round (getFarmingRound block-height))\n            (res (try! (updateRoundStatus pool current_round oracle)))\n            (start_round (var-get farm_start_round)) \n            (round (if (> start_round current_round) start_round current_round))\n            (LPUser_ (try! (claimRewardPrivate (contract-of pool))))\n            (LP_ (contract-call? .stackswap-farming-v3-data getLPOrDefault (contract-of pool)))\n            (LPHistory_ (contract-call? .stackswap-farming-v3-data getLPHistoryOrDefault (contract-of pool) round))\n        )\n        (asserts! (contract-call? .stackswap-farming-v3-data isFarmAvailable  (contract-of pool)) (err ERR_POOL_NOT_FARMABLE))\n        (asserts! (contract-call? .stackswap-security-list-v1a is-secure-router-or-user contract-caller) (err ERR_INVALID_ROUTER))\n        (asserts! (or (> round (get WithdrawEndRound LPUser_)) (> round (var-get farm_end_round))) (err ERR_FARM_ENDED)) \n        (asserts! (<= amount (get StakingLockedAmt LPUser_)) (err u9990))\n        (asserts! (or (is-eq (get StartRound LPUser_) u0) (is-eq (get StartRound LPUser_) current_round)) (err ERR_CLAIMABLE_ROUNDS_EXCEEDED))\n        (asserts! (not (var-get emergency_stop)) (err ERR_FARM_STOPPED))\n\n        (if (<= amount (- (get StakingLockedAmt LPUser_) (get StartRoundAmt LPUser_)) )\n            (begin  \n                (try! (contract-call? .stackswap-farming-v3-data setLPUser\n                    (contract-of pool)\n                    user\n                    (merge LPUser_ {\n                        ViewAmt: (- (get ViewAmt LPUser_) amount),\n                        StakingLockedAmt: (- (get StakingLockedAmt LPUser_) amount),\n                    })\n                ))\n                (try! (contract-call? .stackswap-farming-v3-data setLPHistory \n                    (contract-of pool)\n                    round\n                    (merge LPHistory_ {\n                        NextDepositAmt: (- (get NextDepositAmt LPHistory_) amount),\n                    })\n                ))\n            )\n            (begin\n                (try! (contract-call? .stackswap-farming-v3-data setLPUser\n                    (contract-of pool)\n                    user\n                    (merge LPUser_ {\n                        ViewAmt: (- (get ViewAmt LPUser_) amount),\n                        StakingLockedAmt: (- (get StakingLockedAmt LPUser_) amount),\n                        StartRoundAmt: (- (get StartRoundAmt LPUser_) (- amount (- (get StakingLockedAmt LPUser_) (get StartRoundAmt LPUser_)))),\n                    })\n                ))\n                (try! (contract-call? .stackswap-farming-v3-data setLPHistory \n                    (contract-of pool)\n                    round\n                    (merge LPHistory_ {\n                        LockedAmt: (- (get LockedAmt LPHistory_) (- amount (- (get StakingLockedAmt LPUser_) (get StartRoundAmt LPUser_)))),\n                        NextDepositAmt: (- (get NextDepositAmt LPHistory_) (- (get StakingLockedAmt LPUser_) (get StartRoundAmt LPUser_))),\n                    })\n                ))\n            )\n        )\n\n        (if (is-eq amount (get StakingLockedAmt LPUser_))\n            (try! (contract-call? .stackswap-farming-v3-data deleteLPUser\n                (contract-of pool) user\n            ))\n            false\n        )\n        (try! (contract-call? .stackswap-farming-v3-data transferAsset pool user amount))\n        (try! (updateRoundStatus pool current_round oracle))\n        (ok true)\n    )\n)\n\n(define-private (updateRoundStatus (pool <liquidity-token>) (round uint) (oracle <oracle-trait>))\n  (let  (\n        (LP_ (contract-call? .stackswap-farming-v3-data getLPOrDefault (contract-of pool)))\n        (Group_ (contract-call? .stackswap-farming-v3-data getGroupOrDefault (get Group LP_)))\n        (GroupHistory_ (contract-call? .stackswap-farming-v3-data getGroupHistoryOrDefault (get Group LP_) round))\n        (LPHistory_ (contract-call? .stackswap-farming-v3-data getLPHistoryOrDefault (contract-of pool) round))\n        (lpBalance (- (try! (contract-call? pool get-balance .stackswap-farming-v3-data)) (get NextDepositAmt LPHistory_)))\n        (price (try! (getLPPrice pool oracle)))\n        (lockedAmt (if (> lpBalance (get LockedAmt LPHistory_)) lpBalance (get LockedAmt LPHistory_)))\n        (new_lp_TVL (* (* lockedAmt (get CurWeight LP_)) price))\n    )\n    (asserts! (contract-call? .stackswap-farming-v3-data isFarmAvailable  (contract-of pool)) (err ERR_POOL_NOT_FARMABLE))\n    (try! (contract-call? .stackswap-farming-v3-data setGroupHistory\n         (get Group LP_) round\n        {\n            GroupWeightedTVL : (- (+ (get GroupWeightedTVL GroupHistory_) new_lp_TVL) (get WeightedTVL LPHistory_)),\n            GroupRewardAmt : (get CurRewardAmt Group_)\n        }\n    ))\n    (try! (contract-call? .stackswap-farming-v3-data setLPHistory\n        (contract-of pool) round \n        (merge LPHistory_\n            {\n                LockedAmt: lockedAmt,\n                Price: price,\n                Weight: (get CurWeight LP_),\n                WeightedTVL: new_lp_TVL,\n            }\n        )))\n    (ok true)\n  )\n)\n\n\n(define-public (updateRoundStatusPassed (pool <liquidity-token>) (round uint) )\n  (let  (\n        (LP_ (contract-call? .stackswap-farming-v3-data getLPOrDefault (contract-of pool)))\n        (Group_ (contract-call? .stackswap-farming-v3-data getGroupOrDefault (get Group LP_)))\n        (GroupHistory_ (contract-call? .stackswap-farming-v3-data getGroupHistoryOrDefault (get Group LP_) round))\n        (LPHistory_ (contract-call? .stackswap-farming-v3-data getLPHistoryOrDefault (contract-of pool) round))\n        (LPHistoryEx_ (contract-call? .stackswap-farming-v3-data getLPHistoryOrDefault (contract-of pool) (- round u1)))\n        (LPHistoryNext_ (contract-call? .stackswap-farming-v3-data getLPHistoryOrDefault (contract-of pool) (+ round u1)))\n        (lockedAmtEx (- (+ (get LockedAmt LPHistoryEx_) (get NextDepositAmt LPHistoryEx_)) (get NextWithdrawAmt LPHistoryEx_)))\n        (new_lp_TVL (* (* lockedAmtEx (get CurWeight LP_)) (get Price LPHistory_)))\n    )\n    (asserts! (and (>= (getFarmingRound block-height) round) (> round u1)) (err ERR_NOT_CORRECT_ROUND))\n    (asserts! (contract-call? .stackswap-farming-v3-data isFarmAvailable  (contract-of pool)) (err ERR_POOL_NOT_FARMABLE))\n    (asserts! (> (get Weight LPHistoryEx_) u0)  (err ERR_NO_PREVIOUS_DATA))\n    (try! (is-dao contract-caller)) \n\n    (try! (contract-call? .stackswap-farming-v3-data setGroupHistory\n         (get Group LP_) round\n        {\n            GroupWeightedTVL : (- (+ (get GroupWeightedTVL GroupHistory_) new_lp_TVL) (get WeightedTVL LPHistory_)),\n            GroupRewardAmt : (get CurRewardAmt Group_)\n        }\n    ))\n    (try! (contract-call? .stackswap-farming-v3-data setLPHistory\n        (contract-of pool) round \n        (merge LPHistory_\n            {\n                LockedAmt: lockedAmtEx,\n                WeightedTVL: new_lp_TVL,\n                Weight: (if (is-eq u0 (get Weight LPHistory_)) \n                    u1\n                    (get Weight LPHistory_)\n                ),\n                NextWithdrawAmt: (if \n                    (and \n                        (not (is-eq lockedAmtEx (get LockedAmt LPHistory_))) ;; calculated from ex round should be differnt with this round\n                        (> (+ (get LockedAmt LPHistory_) (get NextDepositAmt LPHistory_)) (get LockedAmt LPHistoryNext_))\n                        (> (var-get UPDATED_ROUND) round)\n                    )\n                    (- (+ (get LockedAmt LPHistory_) (get NextDepositAmt LPHistory_)) (get LockedAmt LPHistoryNext_) )\n                    (if \n                        (and \n                            (or \n                                (not (is-eq lockedAmtEx (get LockedAmt LPHistory_))) ;; calculated from ex round should be differnt with this round\n                                (and \n                                    (is-eq u0 (get Weight LPHistory_))\n                                    (> (getFarmingRound block-height) round)\n                                )\n                            )\n                            (> (+ lockedAmtEx (get NextDepositAmt LPHistory_)) (get LockedAmt LPHistoryNext_))\n                            (<= (var-get UPDATED_ROUND) round)\n                        )\n                        (- (+ lockedAmtEx (get NextDepositAmt LPHistory_)) (get LockedAmt LPHistoryNext_) )\n                        (get NextWithdrawAmt LPHistory_)\n                    )\n                )\n            }\n        )))\n    (ok true)\n  )\n)\n\n(define-private (updateRoundStatusPassedClosure (round uint)\n  (commitmentResponse (response \n    {\n      pool: <liquidity-token>\n    }\n    uint\n  )))\n\n  (match commitmentResponse\n    commitment \n    (begin\n        (try! (updateRoundStatusPassed (get pool commitment) round))\n        commitmentResponse\n    )\n    errValue commitmentResponse\n  )\n)\n\n\n(define-public (updateRoundStatusPassedList (pool <liquidity-token>) (rounds (list 64 uint)))\n    (begin \n        (match (fold updateRoundStatusPassedClosure rounds (ok {\n                        pool: pool\n                    }))\n            okValue (ok true)\n            errValue (err errValue)\n        )\n    )\n)\n\n(define-public (claimReward (pool <liquidity-token>) (oracle <oracle-trait>))\n    (begin\n        (asserts! (not (var-get emergency_stop)) (err ERR_FARM_STOPPED))\n        (try! (updateRoundStatus pool (getFarmingRound block-height) oracle))\n        (try! (claimRewardPrivate (contract-of pool)))\n        (ok true)\n    )\n)\n\n(define-public (updateCurrentRoundStatus (pool <liquidity-token>) (oracle <oracle-trait>))\n    (begin\n        (try! (updateRoundStatus pool (getFarmingRound block-height) oracle))\n        (ok true)\n    )\n)\n\n(define-read-only (getFirstBlockOfRound (round uint)) (+ FIRST_FARMING_BLOCK (* REWARD_ROUND_LENGTH round)))\n\n(define-private (getLPPrice (pool <liquidity-token>) (oracle <oracle-trait>))\n  (let  (\n      (lp_data (try! (contract-call? pool get-lp-data)))\n      (LP_ (contract-call? .stackswap-farming-v3-data getLPOrDefault (contract-of pool)))\n      (price (unwrap-panic (contract-call? oracle fetch-price (get QuoteToken LP_))))\n    )\n    (asserts! (is-eq (contract-of oracle) (unwrap-panic (contract-call? .stackswap-dao-v5k get-qualified-name-by-name \"oracle-l\"))) (err ERR_PERMISSION_DENIED))\n    (ok\n      (if (get QuoteSide LP_)\n        (/ (/ (* (* u1000000 (get balance-x lp_data)) (get last-price price)) (get shares-total lp_data)) (get decimals price))\n        (/ (/ (* (* u1000000 (get balance-y lp_data)) (get last-price price)) (get shares-total lp_data)) (get decimals price))\n      )\n    )\n  )\n)    \n\n\n(define-private (getUserStakingRewardAtRound_ (group uint) (pool principal) (round uint) (userStartRound uint) (userStartRoundAmt uint) (userStakingLockedAmt uint))\n  (let\n    (\n        (GroupHistory_ (contract-call? .stackswap-farming-v3-data getGroupHistoryOrDefault group round))\n        (LPHistory_ (contract-call? .stackswap-farming-v3-data getLPHistoryOrDefault pool round))\n        (userTVL (* (* (get Weight LPHistory_) (get Price LPHistory_)) (if (is-eq round userStartRound)\n            userStartRoundAmt userStakingLockedAmt\n        )))\n        (current_round (getFarmingRound block-height))\n    )\n    (if (or (<= current_round round) (is-eq u0 userTVL) (< (var-get farm_end_round) round) (< round userStartRound) (is-eq u0 (get GroupWeightedTVL GroupHistory_)))\n        u0\n        (/ (* (getGroupRewardsPerRound round (get GroupRewardAmt GroupHistory_)) userTVL) (get GroupWeightedTVL GroupHistory_))\n    )\n\n  )\n)\n\n(define-read-only (getUserStakingRewardAtRound (pool principal) (user principal) (round uint))\n    (let\n        (\n            (LP_ (contract-call? .stackswap-farming-v3-data getLPOrDefault pool))\n            (LPUser_ (contract-call? .stackswap-farming-v3-data getLPUserOrDefault pool user))\n        )\n        (ok (getUserStakingRewardAtRound_ (get Group LP_) pool round (get StartRound LPUser_) (get StartRoundAmt LPUser_) (get StakingLockedAmt LPUser_)))\n    )\n)\n\n(define-private (getEntitledStakingRewardClosure (round uint)\n    (commitment \n        {   \n            group: uint,\n            pool: principal,\n            rewardSum: uint,\n            userStartRound: uint,\n            userStartRoundAmt: uint, \n            userStakingLockedAmt: uint,\n        }\n    ))\n    (merge \n        commitment\n        {\n            rewardSum: (+ (get rewardSum commitment) (getUserStakingRewardAtRound_ (get group commitment) (get pool commitment) round (get userStartRound commitment) (get userStartRoundAmt commitment) (get userStakingLockedAmt commitment)))\n        }\n    )\n)\n\n(define-read-only (getFarmingRewardFromList (user principal) (pool principal) (unclaimedList (list 64 uint)))\n    (let\n        (\n            (LP_ (contract-call? .stackswap-farming-v3-data getLPOrDefault pool))\n            (LPUser_ (contract-call? .stackswap-farming-v3-data getLPUserOrDefault pool user))\n        )\n    (ok (fold getEntitledStakingRewardClosure unclaimedList {\n            group: (get Group LP_),\n            pool: pool,\n            rewardSum: u0,  \n            userStartRound: (get StartRound LPUser_),\n            userStartRoundAmt: (get StartRoundAmt LPUser_), \n            userStakingLockedAmt: (get StakingLockedAmt LPUser_),\n        }))\n    )\n)\n\n\n\n(define-public (addPool (new-pool <liquidity-token>) (quoteSide bool) (quoteToken (string-ascii 12)) (group uint) (weight uint)) \n    (let \n        (\n            (new_pool_principal (contract-of new-pool))\n        ) \n        (try! (is-dao contract-caller)) \n        (try! (contract-call? .stackswap-farming-v3-data setLP new_pool_principal     {\n                Group: group,\n                CurWeight: weight,\n                QuoteSide: quoteSide,\n                QuoteToken: quoteToken,\n            }))\n        (ok true)))\n\n\n\n(define-public (removePool (remove-pool <liquidity-token>) (oracle <oracle-trait>)) \n  (begin\n    (try! (is-dao contract-caller))  \n    (try! (changeLPWeight remove-pool u0 oracle))\n    (ok (try! (contract-call? .stackswap-farming-v3-data deleteLP (contract-of remove-pool))))\n  )\n)\n\n(define-public (changeRewardAmount (group uint) (to_change uint))\n    (let  (\n            (current_round (getFarmingRound block-height))\n            (GroupHistory_ (contract-call? .stackswap-farming-v3-data getGroupHistoryOrDefault group current_round))\n        )\n        (try! (is-dao contract-caller))  \n        (try! (contract-call? .stackswap-farming-v3-data setGroup group\n            {\n                CurRewardAmt: to_change,\n            }\n        ))\n       (try! (contract-call? .stackswap-farming-v3-data setGroupHistory group current_round\n            (merge GroupHistory_\n                {\n                    GroupRewardAmt: to_change\n                }\n             )  \n        ))\n        (ok true)\n    )\n)\n\n\n(define-public (changeLPWeight (pool <liquidity-token>) (to_change uint) (oracle <oracle-trait>))\n    (let  (\n            (current_round (getFarmingRound block-height))\n            (LP_ (contract-call? .stackswap-farming-v3-data getLPOrDefault (contract-of pool)))\n        )\n        (try! (is-dao contract-caller))  \n\n        (try! (contract-call? .stackswap-farming-v3-data setLP \n            (contract-of pool)\n            (merge LP_\n                {\n                    CurWeight: to_change\n                })\n        ))\n        (try! (updateRoundStatus pool current_round oracle))\n        (ok true)\n    )\n)\n\n(define-public (setFarmEndRound (end_round uint)) \n  (begin\n    (try! (is-dao contract-caller))  \n    (ok (var-set farm_end_round end_round))\n  )\n)\n\n(define-read-only (getFarmEndRound)\n  (var-get farm_end_round) \n)\n\n(define-public (setFarmStartRound (start_round uint)) \n  (begin\n    (try! (is-dao contract-caller))  \n    (ok (var-set farm_start_round start_round))\n  )\n)\n\n(define-read-only (getFarmStartRound)\n  (var-get farm_start_round) \n)\n\n\n(define-public (setFarmStop (is_stop bool)) \n  (begin\n    (try! (is-dao contract-caller))  \n    (ok (var-set emergency_stop is_stop))\n  )\n)\n\n(define-read-only (getFarmStop)\n  (var-get emergency_stop) \n)\n\n\n\n(define-public (setUpdatedRound (round_ uint)) \n  (begin\n    (try! (is-dao contract-caller))  \n    (ok (var-set UPDATED_ROUND round_))\n  )\n)",
    "analysis": {
      "summary": "This contract manages a farming system for liquidity providers, allowing users to stake LP tokens, claim rewards, and manage pools.",
      "explanation": "High Level Overview\n\nThe contract integrates with an oracle for price data and a DAO for governance. It supports staking LP tokens, calculating rewards based on staked amounts and pool performance, and claiming those rewards. It includes emergency controls and allows DAO-driven updates to pool parameters.\n\n**Data Variables and Constants**\n\nError Codes <L3-12>: standard set of error codes for various failure states\n\nFarming Parameters <L14-18>: crucial constants that define how the farming system works:\n- FIRST_FARMING_BLOCK: when farming begins\n- REWARD_ROUND_LENGTH: duration of each round\n- MAX_REWARD_ROUNDS: caps the number of rounds\n- REWARD_ROUND_INDEXES: tracks round progression\n- MIN_STAKING_ROUND_REWARDS: minimum reward threshold\n\nState Tracking <L19-25>: key variables that manage the farming lifecycle:\n- farm_end_round & farm_start_round: define the active period\n- emergency_stop: safety switch\n- UPDATED_ROUND: tracks last update\n\n**Key Functions**\n\nis-dao <L26-27>: checks if a user has DAO permissions\n\ngetFarmingRound <L29-30>: figures out which farming round we're in based on block height\n\ngetGroupRewardsPerRound <L32-43>: calculates rewards for a pool group in a specific round, making sure rewards don't drop below minimum thresholds\n\nclaimRewardInner <L46-69>: does the heavy lifting for reward distribution:\n- calculates user's share of the pool\n- handles reward transfers\n- manages the actual claiming process\n\nclaimRewardClosure <L71-104>: smart implementation using fold to process multiple rounds of rewards at once\n\nclaimRewardPrivate <L106-157>: orchestrates the whole reward claiming process\n\nPublic Interface Functions <L159-600>: all the user-facing and admin functions:\n- stake/withdraw mechanics\n- reward claiming\n- pool management\n- admin controls and emergency functions\n\n**Notable Features**\n\n- thorough error handling with specific error codes\n- dao-based governance model\n- smart reward calculations that consider staking duration and pool performance\n- built-in emergency controls for safety",
      "tags": ["staking", "liquidity-providing", "governance", "DeFi"]
    }
  },
  {
    "rank": 13,
    "contract": "SP2VCQJGH7PHP2DJK7Z0V48AGBHQAW3R3ZW1QF4N.borrow-helper-v1-3",
    "calls": 4341,
    "source": "(use-trait ft .ft-trait.ft-trait)\n(use-trait ft-mint-trait .ft-mint-trait.ft-mint-trait)\n(use-trait a-token .a-token-trait.a-token-trait)\n(use-trait flash-loan .flash-loan-trait.flash-loan-trait)\n(use-trait oracle-trait .oracle-trait.oracle-trait)\n(use-trait redeemeable-token .redeemeable-trait-v1-2.redeemeable-trait)\n\n(define-public (supply\n  (lp <redeemeable-token>)\n  (pool-reserve principal)\n  (asset <ft>)\n  (amount uint)\n  (owner principal)\n  (referral (optional principal)))\n  (let ((asset-principal (contract-of asset)))\n    (try! (contract-call? .pool-borrow-v1-2 supply lp pool-reserve asset amount owner))\n    (print { type: \"supply-call\", payload: { key: owner, data: {\n      reserve-state: (try! (contract-call? .pool-0-reserve-v1-2 get-reserve-state asset-principal)),\n      user-reserve-state: (contract-call? .pool-0-reserve-v1-2 get-user-reserve-data owner asset-principal),\n      user-index: (contract-call? .pool-0-reserve-v1-2 get-user-index owner asset-principal),\n      user-assets: (contract-call? .pool-0-reserve-v1-2 get-user-assets owner),\n      asset: asset,\n      amount: amount,\n      new-balance: (try! (contract-call? lp get-balance owner)),\n      referral: referral,\n    }}})\n    (ok true)\n  )\n)\n\n(define-public (borrow\n  (pool-reserve principal)\n  (oracle <oracle-trait>)\n  (asset-to-borrow <ft>)\n  (lp <ft>)\n  (assets (list 100 { asset: <ft>, lp-token: <ft>, oracle: <oracle-trait> }))\n  (amount-to-be-borrowed uint)\n  (fee-calculator principal)\n  (interest-rate-mode uint)\n  (owner principal))\n  (let (\n    (asset-principal (contract-of asset-to-borrow))\n  )\n    (try! (contract-call? .pool-borrow-v1-2 borrow pool-reserve oracle asset-to-borrow lp assets amount-to-be-borrowed fee-calculator interest-rate-mode owner))\n    (print { type: \"borrow-call\", payload: { key: owner, data: {\n        reserve-state: (try! (contract-call? .pool-0-reserve-v1-2 get-reserve-state asset-principal)),\n        user-reserve-state: (contract-call? .pool-0-reserve-v1-2 get-user-reserve-data owner asset-principal),\n        user-index: (contract-call? .pool-0-reserve-v1-2 get-user-index owner asset-principal),\n        user-assets: (contract-call? .pool-0-reserve-v1-2 get-user-assets owner),\n        asset: asset-to-borrow,\n        amount: amount-to-be-borrowed,\n        new-borrow-balance: (get compounded-balance (try! (contract-call? .pool-0-reserve-v1-2 get-user-borrow-balance owner asset-to-borrow))),\n      }}})\n    (ok true)\n  )\n)\n\n(define-public (repay\n  (asset <ft>)\n  (amount-to-repay uint)\n  (on-behalf-of principal)\n  (payer principal)\n  )\n  (let (\n    (asset-principal (contract-of asset))\n    (payback-amount (try! (contract-call? .pool-borrow-v1-2 repay asset amount-to-repay on-behalf-of payer))))\n    (print { type: \"repay-call\", payload: { key: on-behalf-of, data: {\n        reserve-state: (try! (contract-call? .pool-0-reserve-v1-2 get-reserve-state asset-principal)),\n        user-reserve-state: (contract-call? .pool-0-reserve-v1-2 get-user-reserve-data on-behalf-of asset-principal),\n        user-index: (contract-call? .pool-0-reserve-v1-2 get-user-index on-behalf-of asset-principal),\n        user-assets: (contract-call? .pool-0-reserve-v1-2 get-user-assets on-behalf-of),\n        asset: asset,\n        amount: payback-amount,\n        on-behalf-of: on-behalf-of,\n        payer: payer,\n        new-borrow-balance: (get compounded-balance (try! (contract-call? .pool-0-reserve-v1-2 get-user-borrow-balance on-behalf-of asset))),\n      }}})\n    (ok true)\n  )\n)\n\n(define-public (set-user-use-reserve-as-collateral\n  (who principal)\n  (lp-token <ft>)\n  (asset <ft>)\n  (enable-as-collateral bool)\n  (oracle <oracle-trait>)\n  (assets-to-calculate (list 100 { asset: <ft>, lp-token: <ft>, oracle: <oracle-trait> })))\n  (let (\n    (asset-principal (contract-of asset))\n    (reserve-state (try! (contract-call? .pool-0-reserve-v1-2 get-reserve-state asset-principal)))\n    )\n    (try! (contract-call? .pool-borrow-v1-2 set-user-use-reserve-as-collateral who lp-token asset enable-as-collateral oracle assets-to-calculate))\n    (print { type: \"set-user-use-reserve-as-collateral-call\", payload: { key: who, data: {\n        reserve-state: (try! (contract-call? .pool-0-reserve-v1-2 get-reserve-state asset-principal)),\n        user-reserve-state: (contract-call? .pool-0-reserve-v1-2 get-user-reserve-data who asset-principal),\n        user-index: (contract-call? .pool-0-reserve-v1-2 get-user-index who asset-principal),\n        user-assets: (contract-call? .pool-0-reserve-v1-2 get-user-assets who),\n        asset: asset,\n      }}})\n    (ok true)\n  )\n)\n\n(define-public (withdraw\n  (lp <redeemeable-token>)\n  (pool-reserve principal)\n  (asset <ft>)\n  (oracle <oracle-trait>)\n  (amount uint)\n  (owner principal)\n  (assets (list 100 { asset: <ft>, lp-token: <ft-mint-trait>, oracle: <oracle-trait> }))\n  )\n  (let (\n    (asset-principal (contract-of asset))\n    (withdraw-res (try! (contract-call? .pool-borrow-v1-2 withdraw pool-reserve asset lp oracle assets amount owner)))\n    )\n    (print { type: \"withdraw-call\", payload: { key: owner, data: {\n        reserve-state: (try! (contract-call? .pool-0-reserve-v1-2 get-reserve-state asset-principal)),\n        user-reserve-state: (contract-call? .pool-0-reserve-v1-2 get-user-reserve-data owner asset-principal),\n        user-index: (contract-call? .pool-0-reserve-v1-2 get-user-index owner asset-principal),\n        user-assets: (contract-call? .pool-0-reserve-v1-2 get-user-assets owner),\n        asset: asset,\n        withdrawn-amount: withdraw-res,\n        balance: (try! (contract-call? lp get-balance owner)),\n      }}})\n    (ok true)\n  )\n)\n\n(define-public (liquidation-call\n  (assets (list 100 { asset: <ft>, lp-token: <ft>, oracle: <oracle-trait> }))\n  (collateral-lp <a-token>)\n  (collateral-to-liquidate <ft>)\n  (debt-asset <ft>)\n  (collateral-oracle <oracle-trait>)\n  (debt-oracle <oracle-trait>)\n  (liquidated-user principal)\n  (debt-amount uint)\n  (to-receive-atoken bool))\n  (let (\n    (debt-asset-principal (contract-of debt-asset))\n    (collateral-asset-principal (contract-of collateral-to-liquidate))\n    (liquidator tx-sender)\n    )\n    (try! (contract-call? .pool-borrow-v1-2 liquidation-call\n      assets\n      collateral-lp\n      collateral-to-liquidate\n      debt-asset\n      collateral-oracle\n      debt-oracle\n      liquidated-user\n      debt-amount\n      to-receive-atoken)\n    )\n    (print { type: \"liquidation-call\", payload: { key: liquidated-user, data: {\n        debt-reserve-state: (try! (contract-call? .pool-0-reserve-v1-2 get-reserve-state debt-asset-principal)),\n        collateral-reserve-state: (try! (contract-call? .pool-0-reserve-v1-2 get-reserve-state debt-asset-principal)),\n        \n        liquidator-debt-reserve-state: (contract-call? .pool-0-reserve-v1-2 get-user-reserve-data liquidator debt-asset-principal),\n        liquidator-debt-index: (contract-call? .pool-0-reserve-v1-2 get-user-index liquidator debt-asset-principal),\n        liquidator-collateral-reserve-state: (contract-call? .pool-0-reserve-v1-2 get-user-reserve-data liquidator collateral-asset-principal),\n        liquidator-collateral-index: (contract-call? .pool-0-reserve-v1-2 get-user-index liquidator collateral-asset-principal),\n        liquidator-user-assets: (contract-call? .pool-0-reserve-v1-2 get-user-assets liquidator),\n\n        liquidated-user-debt-reserve-state: (contract-call? .pool-0-reserve-v1-2 get-user-reserve-data liquidated-user debt-asset-principal),\n        liquidated-user-debt-index: (contract-call? .pool-0-reserve-v1-2 get-user-index liquidated-user debt-asset-principal),\n        liquidated-user-collateral-reserve-state: (contract-call? .pool-0-reserve-v1-2 get-user-reserve-data liquidated-user collateral-asset-principal),\n        liquidated-user-collateral-index: (contract-call? .pool-0-reserve-v1-2 get-user-index liquidated-user collateral-asset-principal),\n        liquidated-user-assets: (contract-call? .pool-0-reserve-v1-2 get-user-assets liquidated-user),\n\n        collateral-to-liquidate: collateral-to-liquidate,\n        debt-asset: debt-asset-principal,\n        debt-amount: debt-amount,\n      }}})\n    (ok u0)\n  )\n)\n",
    "analysis": {
      "summary": "This contract interfaces with a lending pool to facilitate operations like supply, borrow, repay, collateral management, withdrawal, and liquidation for users.",
      "explanation": "The contract acts as an intermediary between users and a lending pool, handling various financial operations by interacting with external contracts and managing state based on those interactions. It uses multiple traits to ensure compatibility with different token standards and lending pool functionalities. Here's a detailed breakdown of its components and functionalities: \n\n1. The contract uses several traits from lines <L1-6> to ensure compatibility with fungible tokens, mintable tokens, redeemable tokens, flash loans, and oracles. These traits define standardized interfaces for interacting with external contracts.\n\n2. The 'supply' function <L8-29> allows users to supply assets to the lending pool. It records the transaction and updates the user's balance in the pool. Parameters include the type of redeemable token, the pool reserve, the asset being supplied, the amount, the owner, and an optional referral.\n\n3. The 'borrow' function <L31-56> enables users to borrow assets from the pool. It requires specifying the pool reserve, an oracle for price feeds, the asset to borrow, a list of assets for collateral calculation, the amount, a fee calculator, the interest rate mode, and the owner.\n\n4. The 'repay' function <L58-80> allows users to repay borrowed assets. Parameters include the asset, the amount to repay, the beneficiary of the repayment, and the payer.\n\n5. The 'set-user-use-reserve-as-collateral' function <L82-102> lets users set certain assets as collateral. It requires the user's principal, the LP token, the asset, a boolean to enable or disable as collateral, an oracle, and a list of assets for collateral calculation.\n\n6. The 'withdraw' function <L105-129> permits users to withdraw their supplied assets from the pool. It needs the redeemable token, pool reserve, asset, oracle, amount, owner, and a list of assets for collateral calculation.\n\n7. The 'liquidation-call' function <L131-179> is used in liquidation scenarios where a user's collateral is sold to cover their debt. It requires a list of assets, the collateral and debt assets, their respective oracles, the liquidated user, the debt amount, and a boolean indicating if the user will receive aTokens as part of the liquidation process.\n\nEach function performs safety checks by using the 'try!' macro to ensure that calls to external contracts succeed. If these calls fail, the entire transaction is reverted to maintain consistency and prevent partial updates to the state. The contract extensively uses the 'contract-call?' function to interact with external contracts, demonstrating a complex interplay between different components of the lending ecosystem.",
      "tags": ["DeFi", "lending", "borrowing", "collateral-management"]
    }
  },
  {
    "rank": 14,
    "contract": "SP4SZE494VC2YC5JYG7AYFQ44F5Q4PYV7DVMDPBG.stacking-dao-core-v3",
    "calls": 4314,
    "source": ";; @contract Core\n;; @version 3\n;;\n;; Core contract for the user to interact with (deposit, withdraw)\n\n(use-trait reserve-trait .reserve-trait-v1.reserve-trait)\n(use-trait direct-helpers-trait .direct-helpers-trait-v1.direct-helpers-trait)\n(use-trait staking-trait .staking-trait-v1.staking-trait)\n(use-trait commission-trait .commission-trait-v1.commission-trait)\n\n;;-------------------------------------\n;; Constants \n;;-------------------------------------\n\n(define-constant ERR_WITHDRAW_LOCKED u204001)\n(define-constant ERR_SHUTDOWN u204002)\n(define-constant ERR_WITHDRAW_NOT_NFT_OWNER u204003)\n(define-constant ERR_WITHDRAW_NFT_DOES_NOT_EXIST u204004)\n(define-constant ERR_GET_OWNER u204005)\n(define-constant ERR_WITHDRAW_CANCEL u204006)\n(define-constant ERR_WRONG_BPS u204007)\n\n(define-constant DENOMINATOR_6 u1000000)\n(define-constant DENOMINATOR_BPS u10000)\n\n;;-------------------------------------\n;; Variables\n;;-------------------------------------\n\n(define-data-var shutdown-deposits bool false)\n(define-data-var stack-fee uint u0) ;; in bps\n(define-data-var unstack-fee uint u0) ;; in bps\n\n;;-------------------------------------\n;; Getters \n;;-------------------------------------\n\n(define-read-only (get-shutdown-deposits)\n  (var-get shutdown-deposits)\n)\n\n(define-read-only (get-stack-fee)\n  (var-get stack-fee)\n)\n\n(define-read-only (get-unstack-fee)\n  (var-get unstack-fee)\n)\n\n(define-read-only (get-withdraw-unlock-burn-height)\n  (let (\n    (current-cycle (current-pox-reward-cycle))\n    (start-block-next-cycle (reward-cycle-to-burn-height (+ current-cycle u1)))\n    (withdraw-offset (contract-call? .data-core-v1 get-cycle-withdraw-offset))\n  )\n    (if (< burn-block-height (- start-block-next-cycle withdraw-offset))\n      ;; Can withdraw next cycle\n      (ok start-block-next-cycle)\n\n      ;; Withdraw cycle after next\n      (ok (+ start-block-next-cycle (get-reward-cycle-length)))\n    )\n  )\n)\n\n;;-------------------------------------\n;; User  \n;;-------------------------------------\n\n;; Deposit STX for stSTX\n(define-public (deposit \n  (reserve <reserve-trait>) \n  (commission-contract <commission-trait>) \n  (staking-contract <staking-trait>) \n  (direct-helpers <direct-helpers-trait>)\n  (stx-amount uint)\n  (referrer (optional principal)) \n  (pool (optional principal))\n)\n  (let (\n    (stx-fee-amount (/ (* (get-stack-fee) stx-amount) DENOMINATOR_BPS))\n    (stx-user-amount (- stx-amount stx-fee-amount))\n\n    (stx-ststx (try! (contract-call? .data-core-v1 get-stx-per-ststx reserve)))\n    (ststx-amount (/ (* stx-user-amount DENOMINATOR_6) stx-ststx))\n  )\n    (try! (contract-call? .dao check-is-enabled))\n    (try! (contract-call? .dao check-is-protocol (contract-of reserve)))\n    (try! (contract-call? .dao check-is-protocol (contract-of commission-contract)))\n    (try! (contract-call? .dao check-is-protocol (contract-of staking-contract)))\n    (try! (contract-call? .dao check-is-protocol (contract-of direct-helpers)))\n    (asserts! (not (get-shutdown-deposits)) (err ERR_SHUTDOWN))\n\n    (try! (contract-call? direct-helpers add-direct-stacking tx-sender pool stx-user-amount))\n\n    ;; User\n    (try! (stx-transfer? stx-user-amount tx-sender (contract-of reserve)))\n    (try! (contract-call? .ststx-token mint-for-protocol ststx-amount tx-sender))\n\n    ;; Fee\n    (if (> stx-fee-amount u0)\n      (begin\n        (try! (stx-transfer? stx-fee-amount tx-sender (as-contract tx-sender)))\n        (try! (as-contract (contract-call? commission-contract add-commission staking-contract stx-fee-amount)))\n      )\n      u0\n    )\n\n    (print { action: \"deposit\", data: { stacker: tx-sender, stx-amount: stx-amount, stxstx-amount: ststx-amount, referrer: referrer, pool: pool, block-height: block-height } })\n    (ok ststx-amount)\n  )\n)\n\n;; Initiate withdrawal, given stSTX amount. Can update amount as long as cycle not started.\n;; The stSTX tokens are transferred to this contract, and are burned on the actual withdrawal.\n;; An NFT is minted for the user as a token representation of the withdrawal.\n(define-public (init-withdraw \n  (reserve <reserve-trait>) \n  (direct-helpers <direct-helpers-trait>)\n  (ststx-amount uint)\n)\n  (let (\n    (sender tx-sender)\n    (unlock-burn-height (unwrap-panic (get-withdraw-unlock-burn-height)))\n\n    (stx-ststx (try! (contract-call? .data-core-v1 get-stx-per-ststx reserve)))\n    (stx-amount (/ (* ststx-amount stx-ststx) DENOMINATOR_6))\n\n    (nft-id (unwrap-panic (contract-call? .ststx-withdraw-nft-v2 get-last-token-id)))\n  )\n    (try! (contract-call? .dao check-is-enabled))\n    (try! (contract-call? .dao check-is-protocol (contract-of reserve)))\n    (try! (contract-call? .dao check-is-protocol (contract-of direct-helpers)))\n\n    (try! (contract-call? .data-core-v1 set-withdrawals-by-nft nft-id stx-amount ststx-amount unlock-burn-height))\n    \n    (try! (contract-call? direct-helpers subtract-direct-stacking tx-sender stx-amount))\n\n    ;; Transfer stSTX token to contract, only burn on actual withdraw\n    (try! (as-contract (contract-call? reserve lock-stx-for-withdrawal stx-amount)))\n    (try! (contract-call? .ststx-token transfer ststx-amount tx-sender (as-contract tx-sender) none))\n    (try! (as-contract (contract-call? .ststx-withdraw-nft-v2 mint-for-protocol sender)))\n\n    (print { action: \"init-withdraw\", data: { stacker: tx-sender, nft-id: nft-id, ststx-amount: ststx-amount, stx-amount: stx-amount, block-height: block-height } })\n    (ok nft-id)\n  )\n)\n\n;; Actual withdrawal for given NFT. \n;; The NFT and stSTX tokens will be burned and the user will receive STX tokens.\n(define-public (withdraw \n  (reserve <reserve-trait>)\n  (commission-contract <commission-trait>) \n  (staking-contract <staking-trait>) \n  (nft-id uint)\n)\n  (let (\n    (receiver tx-sender)\n\n    (withdrawal-entry (contract-call? .data-core-v1 get-withdrawals-by-nft nft-id))\n    (unlock-burn-height (get unlock-burn-height withdrawal-entry))\n    (stx-amount (get stx-amount withdrawal-entry))\n    (ststx-amount (get ststx-amount withdrawal-entry))\n\n    (nft-owner (unwrap! (contract-call? .ststx-withdraw-nft-v2 get-owner nft-id) (err ERR_GET_OWNER)))\n\n    (stx-fee-amount (/ (* (get-unstack-fee) stx-amount) DENOMINATOR_BPS))\n    (stx-user-amount (- stx-amount stx-fee-amount))\n  )\n    (try! (contract-call? .dao check-is-enabled))\n    (try! (contract-call? .dao check-is-protocol (contract-of reserve)))\n    (try! (contract-call? .dao check-is-protocol (contract-of commission-contract)))\n    (try! (contract-call? .dao check-is-protocol (contract-of staking-contract)))\n    (asserts! (is-some nft-owner) (err ERR_WITHDRAW_NFT_DOES_NOT_EXIST))\n    (asserts! (is-eq (unwrap! nft-owner (err ERR_GET_OWNER)) tx-sender) (err ERR_WITHDRAW_NOT_NFT_OWNER))\n    (asserts! (>= burn-block-height unlock-burn-height) (err ERR_WITHDRAW_LOCKED))\n\n    (try! (contract-call? .data-core-v1 delete-withdrawals-by-nft nft-id))\n\n    ;; STX to user, burn stSTX\n    (try! (as-contract (contract-call? reserve request-stx-for-withdrawal stx-user-amount receiver)))\n    (try! (contract-call? .ststx-token burn-for-protocol (get ststx-amount withdrawal-entry) (as-contract tx-sender)))\n    (try! (as-contract (contract-call? .ststx-withdraw-nft-v2 burn-for-protocol nft-id)))\n\n    ;; Fee\n    (if (> stx-fee-amount u0)\n      (begin\n        (try! (as-contract (contract-call? reserve request-stx-for-withdrawal stx-fee-amount tx-sender)))\n        (try! (as-contract (contract-call? commission-contract add-commission staking-contract stx-fee-amount)))\n      )\n      u0\n    )\n\n    (print { action: \"withdraw\", data: { stacker: tx-sender, ststx-amount: ststx-amount, stx-amount: stx-amount, block-height: block-height } })\n    (ok { stx-user-amount: stx-user-amount, stx-fee-amount: stx-fee-amount})\n  )\n)\n\n;;-------------------------------------\n;; Admin\n;;-------------------------------------\n\n(define-public (set-shutdown-deposits (shutdown bool))\n  (begin\n    (try! (contract-call? .dao check-is-protocol contract-caller))\n    \n    (var-set shutdown-deposits shutdown)\n    (ok true)\n  )\n)\n\n(define-public (set-stack-fee (fee uint))\n  (begin\n    (try! (contract-call? .dao check-is-protocol contract-caller))\n    (asserts! (<= fee DENOMINATOR_BPS) (err ERR_WRONG_BPS))\n\n    (var-set stack-fee fee)\n    (ok true)\n  )\n)\n\n(define-public (set-unstack-fee (fee uint))\n  (begin\n    (try! (contract-call? .dao check-is-protocol contract-caller))\n    (asserts! (<= fee DENOMINATOR_BPS) (err ERR_WRONG_BPS))\n\n    (var-set unstack-fee fee)\n    (ok true)\n  )\n)\n\n;;-------------------------------------\n;; PoX Helpers\n;;-------------------------------------\n\n(define-read-only (current-pox-reward-cycle) \n  (contract-call? 'SP000000000000000000002Q6VF78.pox-4 current-pox-reward-cycle)\n)\n\n(define-read-only (reward-cycle-to-burn-height (cycle-id uint)) \n  (contract-call? 'SP000000000000000000002Q6VF78.pox-4 reward-cycle-to-burn-height cycle-id)\n)\n\n(define-read-only (get-reward-cycle-length)\n  (get reward-cycle-length (unwrap-panic (contract-call? 'SP000000000000000000002Q6VF78.pox-4 get-pox-info)))\n)\n\n\n;;-------------------------------------\n;; Migrate stSTX from V1\n;;-------------------------------------\n\n(define-public (migrate-ststx)\n  (let (\n    (balance-v1 (unwrap-panic (contract-call? .ststx-token get-balance .stacking-dao-core-v1)))\n  )\n    (try! (contract-call? .dao check-is-protocol contract-caller))\n    \n    (try! (contract-call? .ststx-token burn-for-protocol balance-v1 .stacking-dao-core-v1))\n    (try! (contract-call? .ststx-token mint-for-protocol balance-v1 (as-contract tx-sender)))\n\n    (ok true)\n  )\n)\n",
    "analysis": {
      "summary": "This contract facilitates user interactions such as depositing and withdrawing STX in exchange for stSTX, including fee handling and NFT issuance for withdrawals.",
      "explanation": "The contract serves as a core interface for users to deposit STX to receive stSTX, initiate withdrawals of STX using stSTX, and manage fees associated with these processes. It integrates with multiple traits for direct helpers, staking, and commission calculations, and interacts with a DAO for protocol checks. It also includes functionality for shutting down deposits and setting fees. The contract uses NFTs to represent withdrawal requests, ensuring a secure and verifiable method for users to reclaim their STX. \n\n1. Constants and Variables: \n- Error codes <L15-22> are defined for various failure states. \n- DENOMINATOR_6 and DENOMINATOR_BPS <L23-24> are constants for mathematical calculations. \n- Data variables <L30-32> include flags for shutting down deposits and fees for stacking and unstacking. \n\n2. Getters <L38-48>: Provide read-only access to the contract's state, such as shutdown status and fees. \n\n3. Deposit Function <L70-112>: Allows users to deposit STX, calculates fees, and mints stSTX for the user. It checks for protocol enablement and deposit shutdown, and interacts with the reserve and commission contracts for fee handling. \n\n4. Initiate Withdraw Function <L114-147>: Users can initiate a withdrawal of STX by transferring stSTX to the contract. An NFT is minted as a token representation of the withdrawal request. \n\n5. Withdraw Function <L149-197>: Handles the actual withdrawal process, burning the NFT and stSTX tokens, transferring STX to the user, and managing withdrawal fees. \n\n6. Admin Functions <L203-230>: Allow protocol administrators to toggle the shutdown state and adjust fees. \n\n7. PoX Helpers <L236-246>: Interact with the PoX contract for reward cycles and calculations related to withdrawals. \n\n8. Migrate stSTX Function <L253-264>: Provides a mechanism for migrating stSTX tokens from a previous version of the contract.",
      "tags": ["utility", "staking", "NFT", "protocol"]
    }
  },
  {
    "rank": 15,
    "contract": "SP001SFSMC2ZY76PD4M68P3WGX154XCH7NE3TYMX.pox4-pools",
    "calls": 4263,
    "source": ";; @contract pox-4 wrapper contract for stacking pools\n;; @version 3\n;; Changelog: fix decrease error, add stacking stats for this pool, add metadata for users\n\n;; User calls delegate-stx at first and provides a btc address to receive rewards.\n;; Pool operators lock the user's delegated STX tokens according to their rules.\n;; Some pools require a minimum amount. Most pool operators lock the delegated STX\n;; for the next cycle only.\n;; Users can delegate more stx by calling delegate-stx with a higher amount for the next cycle.\n\n;;\n;; Data storage\n;;\n(define-constant err-not-found (err u404))\n(define-constant err-non-positive-amount (err u500))\n(define-constant err-no-stacker-info (err u501))\n(define-constant err-no-user-info (err u502))\n(define-constant err-decrease-forbidden (err u503))\n;; Error code 3 is used by pox-4 contract for already stacking errors\n(define-constant err-already-stacking (err u603))\n;; Error code 9 is used by pox-4 contract for stacking-permission-denied\n(define-constant err-stacking-permission-denied (err u609))\n\n(define-constant pox-info (unwrap-panic (contract-call? 'SP000000000000000000002Q6VF78.pox-4 get-pox-info)))\n\n;; Allowed contract-callers handling a user's stacking activity.\n(define-map allowance-contract-callers\n  { sender: principal, contract-caller: principal}\n  { until-burn-ht: (optional uint)})\n\n;; Keep track of the last delegation\n;; pox-addr: raw bytes of user's account to receive rewards, can be encoded as btc or stx address\n;; cycle: cycle id of time of delegation\n(define-map user-data principal {pox-addr: {hashbytes: (buff 32), version: (buff 1)}, cycle: uint})\n\n;; more metadata for each stacker\n(define-map metadata {stacker: principal, key: (string-ascii 8)} (string-ascii 80))\n\n;; Keep track of stackers grouped by pool and reward-cycle id\n;; \"grouped-stackers-len\" returns the number of lists for the given group\n;; \"grouped-stackers\" returns the actual list\n(define-map grouped-stackers {pool: principal, reward-cycle: uint, index: uint}\n  (list 30 {lock-amount: uint, stacker: principal, unlock-burn-height: uint, pox-addr: {hashbytes: (buff 32), version: (buff 1)}, cycle: uint}))\n(define-map grouped-stackers-len {pool: principal, reward-cycle: uint} uint)\n\n;; Keep track of total stxs stacked grouped by pool and reward-cycle id\n(define-map grouped-totals {pool: principal, reward-cycle: uint} uint)\n\n;;\n;; Helper functions for \"grouped-stackers\" map\n;;\n\n(define-private (merge-details (stacker {lock-amount: uint, stacker: principal, unlock-burn-height: uint}) (user {pox-addr: {hashbytes: (buff 32), version: (buff 1)}, cycle: uint}))\n  {lock-amount: (get lock-amount stacker),\n   stacker: (get stacker stacker),\n   unlock-burn-height: (get unlock-burn-height stacker),\n   pox-addr: (get pox-addr user),\n   cycle: (get cycle user)})\n\n(define-private (insert-in-new-list (pool principal) (reward-cycle uint) (last-index uint) (details {lock-amount: uint, stacker: principal, unlock-burn-height: uint, pox-addr: {hashbytes: (buff 32), version: (buff 1)}, cycle: uint}))\n  (let ((index (+ last-index u1)))\n    (map-insert grouped-stackers (print {pool: pool, reward-cycle: reward-cycle, index: index}) (list details))\n    (map-set grouped-stackers-len {pool: pool, reward-cycle: reward-cycle} index)))\n\n(define-private (map-set-details (pool principal) (details {lock-amount: uint, stacker: principal, unlock-burn-height: uint, pox-addr: {hashbytes: (buff 32), version: (buff 1)}, cycle: uint}))\n  (let ((reward-cycle (+ (current-pox-reward-cycle) u1))\n        (last-index (get-status-lists-last-index pool reward-cycle))\n        (stacker-key {pool: pool, reward-cycle: reward-cycle, index: last-index}))\n    (match (map-get? grouped-stackers stacker-key)\n      stackers (match (as-max-len? (append stackers details) u30)\n                 updated-list (map-set grouped-stackers stacker-key updated-list)\n                 (insert-in-new-list pool reward-cycle last-index details))\n      (map-insert grouped-stackers stacker-key (list details)))\n    (map-set grouped-totals {pool: pool, reward-cycle: reward-cycle} \n      (+ (get-total pool reward-cycle) (get lock-amount details)))))\n\n;;\n;; Helper functions for pox-4 calls\n;;\n\n;; Get stacker info\n(define-private (pox-get-stacker-info (user principal))\n  (contract-call? 'SP000000000000000000002Q6VF78.pox-4 get-stacker-info user))\n\n;; Revokes and delegates stx\n(define-private (delegate-stx-inner (amount-ustx uint) (delegate-to principal) (until-burn-ht (optional uint)))\n  (let ((result-revoke\n            ;; Calls revoke and ignores result\n          (contract-call? 'SP000000000000000000002Q6VF78.pox-4 revoke-delegate-stx)))\n    ;; Calls delegate-stx, converts any error to uint\n    (match (contract-call? 'SP000000000000000000002Q6VF78.pox-4 delegate-stx amount-ustx delegate-to until-burn-ht none)\n      success (ok success)\n      error (err (* u1000 (to-uint error))))))\n\n\n;; Calls pox-4 delegate-stack-extend and delegate-stack-increase.\n;; parameter amount-ustx must be lower or equal the stx balance and the delegated amount\n;; returns the new unlock height and the new total locked stx amount\n(define-private (delegate-stack-extend-increase (user principal)\n                  (amount-ustx uint)\n                  (pox-address {hashbytes: (buff 32), version: (buff 1)}))\n  (let ((status (stx-account user))\n        (locked-amount (get locked status)))\n    (asserts! (>= amount-ustx locked-amount) err-decrease-forbidden)\n    (match (maybe-extend-for-next-cycle user pox-address status)\n      success-extend (let ((unlock-burn-height (get unlock-burn-height success-extend)))\n            (if (is-eq amount-ustx locked-amount)\n                ;; do not increase\n                (begin\n                  (asserts! (> unlock-burn-height (get unlock-height status)) err-already-stacking)\n                  (ok {lock-amount: (get locked status),\n                      stacker: user,\n                      unlock-burn-height: unlock-burn-height}))\n                ;; else increase\n                (let ((increase-by (- amount-ustx locked-amount)))\n                  (match (contract-call? 'SP000000000000000000002Q6VF78.pox-4 delegate-stack-increase\n                          user pox-address increase-by)\n                    success-increase (ok {lock-amount: increase-by,\n                                          stacker: user,\n                                          unlock-burn-height: unlock-burn-height})\n                    error-increase (err (* u1000000000 (to-uint error-increase)))))))\n      error (err (* u1000000 (to-uint error))))))\n\n;; Tries to extend the user's locking to the next cycle\n;; if not yet locked until the end of the next cycle.\n(define-private (maybe-extend-for-next-cycle\n                  (user principal)\n                  (pox-address {hashbytes: (buff 32), version: (buff 1)})\n                  (status {locked: uint, unlocked: uint, unlock-height: uint})\n                )\n  (let ((current-cycle (current-pox-reward-cycle))\n        (unlock-height (get unlock-height status)))\n    (if (not-locked-for-cycle unlock-height (+ u1 current-cycle))\n      (contract-call? 'SP000000000000000000002Q6VF78.pox-4 delegate-stack-extend\n             user pox-address u1)\n      (ok {stacker: user, unlock-burn-height: unlock-height}))))\n\n;; Stacks given amount of delegated stx tokens.\n;; Stores the result in \"grouped-stackers\".\n(define-private (delegate-stack-stx-fold (details {user: principal, amount-ustx: uint})\n                  (context {pox-address: {hashbytes: (buff 32), version: (buff 1)},\n                            start-burn-ht: uint,\n                            result: (list 30 (response {lock-amount: uint, stacker: principal, unlock-burn-height: uint} uint))}))\n  (let ((user (get user details))\n        (user-account (stx-account user))\n        (amount-ustx (min (get amount-ustx details) (+ (get locked user-account) (get unlocked user-account)))))\n    (pox-delegate-stack-stx-amount user amount-ustx context)))\n\n;; Stacks maximal amount of delegated stx tokens.\n;; Stores the result in \"grouped-stackers\".\n(define-private (delegate-stack-stx-simple-fold (user principal)\n                  (context {pox-address: {hashbytes: (buff 32), version: (buff 1)},\n                            start-burn-ht: uint,\n                            result: (list 30 (response {lock-amount: uint, stacker: principal, unlock-burn-height: uint} uint))}))\n  (let ((buffer-amount u1000000)\n        (user-account (stx-account user))\n        (allowed-amount (min (get-delegated-amount user) (+ (get locked user-account) (get unlocked user-account))))\n        ;; Amount to lock must be leq allowed-amount and geq locked amount.\n        ;; Increase the locked amount if possible, but leave a buffer for revoke tx fees if possible.\n        ;; Decreasing the locked amount requires a cool down cycle.\n        (amount-ustx (if (> allowed-amount buffer-amount)\n                            (max (get locked user-account) (- allowed-amount buffer-amount))\n                            allowed-amount)))\n    (pox-delegate-stack-stx-amount user amount-ustx context)))\n\n;; Stacks the given amount of delegated stx tokens\n(define-private (pox-delegate-stack-stx-amount (user principal) (amount-ustx uint)\n                  (context {pox-address: {hashbytes: (buff 32), version: (buff 1)},\n                            start-burn-ht: uint,\n                            result: (list 30 (response {lock-amount: uint, stacker: principal, unlock-burn-height: uint} uint))}))\n  (let ((pox-address (get pox-address context))\n        (start-burn-ht (get start-burn-ht context))\n        (stack-result\n          (if (> amount-ustx u0)\n            (match (map-get? user-data user)\n              user-details\n                ;; Call delegate-stack-stx\n                ;; On failure, call delegate-stack-extend and increase\n                (match (contract-call? 'SP000000000000000000002Q6VF78.pox-4 delegate-stack-stx\n                        user amount-ustx\n                        pox-address start-burn-ht u1)\n                  stacker-details  (begin\n                                    ;; Store result on success\n                                    (map-set-details tx-sender (merge-details stacker-details user-details))\n                                    (ok stacker-details))\n                  error (if (is-eq error 3) ;; Check whether user is already stacked\n                          (match (delegate-stack-extend-increase user amount-ustx pox-address)\n                            stacker-details-2 (begin\n                                    ;; Store result on success\n                                    (map-set-details tx-sender (merge-details stacker-details-2 user-details))\n                                    (ok stacker-details-2))\n                            error-extend-increase (err error-extend-increase))\n                          (err (* u1000 (to-uint error)))))\n              err-not-found)\n            err-non-positive-amount)))\n        ;; Return a tuple even if delegate-stack-stx call failed\n    {pox-address: pox-address,\n     start-burn-ht: start-burn-ht,\n     result: (unwrap-panic (as-max-len? (append (get result context) stack-result) u30))}))\n;;\n;; Public functions\n;;\n\n;; @desc User calls this function to delegate the stacking rights to a pool.\n;; Users can revoke delegation and stx tokens will unlock at the end of the locking period.\n;;\n;; @param amount-ustx; amount to delegate. Can be higher than current stx balance.\n;; @param delegate-to; the pool's Stacks address.\n;; @param until-burn-ht; optional maximal duration of the pool membership. Can be none for undetermined membership.\n;; @param pool-pox-addr; the optional pool's bitcoin reward address. Can be none, so that the pool operator can choose different addresses.\n;; @param user-pox-addr; raw bytes of user's address that should be used for payout of rewards by pool admins.\n(define-public (delegate-stx (amount-ustx uint) (delegate-to principal) (until-burn-ht (optional uint))\n                 (pool-pox-addr (optional {hashbytes: (buff 32), version: (buff 1)}))\n                 (user-pox-addr {hashbytes: (buff 32), version: (buff 1)})\n                 (user-metadata (optional {keys: (list 30 (string-ascii 8)), values: (list 30 (string-ascii 80))})))\n  (begin\n    ;; Must be called directly by the tx-sender or by an allowed contract-caller\n    (asserts! (check-caller-allowed) err-stacking-permission-denied)\n    (match user-metadata\n      md (map set-metadata-internal (get keys md) (get values md))\n      (list true))\n    (map-set user-data tx-sender\n      {pox-addr: user-pox-addr, cycle: (current-pox-reward-cycle)})\n    (delegate-stx-inner amount-ustx delegate-to until-burn-ht)))\n\n;; @desc Pool admins call this function to lock stacks of their pool members in batches for 1 cycle.\n;; @param users; list of users with amounts to lock.\n;; @param pox-address; the pool's bitcoin reward address.\n;; @param start-burn-ht; a future bitcoin height of the current cycle.\n(define-public (delegate-stack-stx (users (list 30 {user: principal, amount-ustx: uint}))\n                 (pox-address { version: (buff 1), hashbytes: (buff 32)})\n                 (start-burn-ht uint))\n  (begin\n    (asserts! (check-caller-allowed) err-stacking-permission-denied)\n    (ok (get result\n          (fold delegate-stack-stx-fold users {start-burn-ht: start-burn-ht, pox-address: pox-address, result: (list)})))))\n\n;; @desc Pool admins call this function to lock stacks of their pool members in batches for a lock period of 1 cycle.\n;; The locking amount is determined from the delegated amount and the users balances.\n;; @param users; list of current pool members.\n;; @param pox-address; the pool's bitcoin reward address.\n;; @param start-burn-ht; a future bitcoin height of the current cycle.\n(define-public (delegate-stack-stx-simple (users (list 30 principal))\n                 (pox-address { version: (buff 1), hashbytes: (buff 32)})\n                 (start-burn-ht uint))\n  (begin\n    (asserts! (check-caller-allowed) err-stacking-permission-denied)\n    (ok (get result\n          (fold delegate-stack-stx-simple-fold users {start-burn-ht: start-burn-ht, pox-address: pox-address, result: (list)})))))\n;;\n;; Read-only functions\n;;\n\n\n;; What's the reward cycle number of the burnchain block height?\n;; Will runtime-abort if height is less than the first burnchain block (this is intentional)\n(define-read-only (burn-height-to-reward-cycle (height uint))\n    (/ (- height (get first-burnchain-block-height pox-info)) (get reward-cycle-length pox-info)))\n\n;; What's the block height at the start of a given reward cycle?\n(define-read-only (reward-cycle-to-burn-height (cycle uint))\n    (+ (get first-burnchain-block-height pox-info) (* cycle (get reward-cycle-length pox-info))))\n\n;; What's the current PoX reward cycle?\n(define-read-only (current-pox-reward-cycle)\n    (burn-height-to-reward-cycle burn-block-height))\n\n\n;; Returns the user's stacking details from pox contract,\n;; the user's delegation details from \"user-data\" and the\n;; total locked stacks for the given pool and cycle-id.\n(define-read-only (get-status (pool principal) (user principal) (cycle-id uint))\n  (let ((stacker-info (unwrap! (pox-get-stacker-info user) err-no-stacker-info)))\n    (ok {stacker-info: stacker-info,\n         user-info: (unwrap! (map-get? user-data user) err-no-user-info),\n         total: (get-total pool cycle-id)})))\n\n;; Returns the number of lists of stackers that have locked their stx for the given pool and cycle.\n(define-read-only (get-status-lists-last-index (pool principal) (reward-cycle uint))\n  (default-to u0 (map-get? grouped-stackers-len {pool: pool, reward-cycle: reward-cycle})))\n\n;; Returns a list of stackers that have locked their stx for the given pool and cycle.\n;; index: must be smaller than get-status-lists-last-index\n(define-read-only (get-status-list (pool principal) (reward-cycle uint) (index uint))\n  {total: (get-total pool reward-cycle),\n   status-list: (map-get? grouped-stackers {pool: pool, reward-cycle: reward-cycle, index: index})})\n\n;; Returns currently delegated amount for a given user\n(define-read-only (get-delegated-amount (user principal))\n  (default-to u0 (get amount-ustx (contract-call? 'SP000000000000000000002Q6VF78.pox-4 get-delegation-info user))))\n\n;; Returns information about last delegation call for a given user\n;; This information can be obsolete due to a normal revoke call\n(define-read-only (get-user-data (user principal))\n  (map-get? user-data user))\n\n;; Returns locked and unlocked amount for given user\n(define-read-only (get-stx-account (user principal))\n  (stx-account user))\n\n;; Returns total stacks locked by given pool, reward-cycle.\n;; The total for a given reward cycle needs to be calculated off-chain\n;; depending on the pool's policy.\n(define-read-only (get-total (pool principal) (reward-cycle uint))\n  (default-to u0 (map-get? grouped-totals {pool: pool, reward-cycle: reward-cycle})))\n\n;; Returns true if the given burn chain height is smaller\n;; than the start of the given reward cycle id.\n(define-read-only (not-locked-for-cycle (unlock-burn-height uint) (cycle uint))\n  (<= unlock-burn-height (reward-cycle-to-burn-height cycle)))\n\n;;\n;; Functions to handle metadata\n;;\n\n(define-read-only (get-metadata (key {stacker: principal, key: (string-ascii 8)}))\n  (map-get? metadata key))\n\n(define-read-only (get-metadata-many (keys (list 30 {stacker: principal, key: (string-ascii 8)})))\n  (map get-metadata keys))\n\n(define-public (set-metadata (key (string-ascii 8)) (value (string-ascii 80)))\n  (begin\n    (asserts! (check-caller-allowed) err-stacking-permission-denied)\n    (ok (set-metadata-internal key value))))\n\n(define-public (set-metadata-many (keys (list 30 (string-ascii 8))) (values (list 30 (string-ascii 80))))\n  (begin\n    (asserts! (check-caller-allowed) err-stacking-permission-denied)\n    (ok (map set-metadata-internal keys values))))\n\n(define-private (set-metadata-internal (key (string-ascii 8)) (value (string-ascii 80)))\n  (map-set metadata {stacker: tx-sender, key: key} value))\n\n;; Returns minimum\n(define-private (min (amount-1 uint) (amount-2 uint))\n  (if (< amount-1 amount-2)\n    amount-1\n    amount-2))\n\n;; Returns maximum\n(define-private (max (amount-1 uint) (amount-2 uint))\n  (if (> amount-1 amount-2)\n    amount-1\n    amount-2))\n\n;;\n;; Functions about allowance of delegation/stacking contract calls\n;;\n\n;; Give a contract-caller authorization to call stacking methods\n;;  normally, stacking methods may only be invoked by _direct_ transactions\n;;   (i.e., the tx-sender issues a direct contract-call to the stacking methods)\n;;  by issuing an allowance, the tx-sender may call through the allowed contract\n(define-public (allow-contract-caller (caller principal) (until-burn-ht (optional uint)))\n  (begin\n    (asserts! (is-eq tx-sender contract-caller) err-stacking-permission-denied)\n    (ok (map-set allowance-contract-callers\n          { sender: tx-sender, contract-caller: caller}\n          { until-burn-ht: until-burn-ht}))))\n\n;; Revokes contract-caller authorization to call stacking methods\n(define-public (disallow-contract-caller (caller principal))\n  (begin\n    (asserts! (is-eq tx-sender contract-caller) err-stacking-permission-denied)\n    (ok (map-delete allowance-contract-callers { sender: tx-sender, contract-caller: caller}))))\n\n;; Verifies that the contract caller has allowance to handle the tx-sender's stacking\n(define-read-only (check-caller-allowed)\n  (or (is-eq tx-sender contract-caller)\n    (let ((caller-allowed\n                 ;; if not in the caller map, return false\n            (unwrap! (map-get? allowance-contract-callers\n                       { sender: tx-sender, contract-caller: contract-caller})\n              false))\n          (expires-at\n               ;; if until-burn-ht not set, then return true (because no expiry)\n            (unwrap! (get until-burn-ht caller-allowed) true)))\n          ;; is the caller allowance still valid\n      (< burn-block-height expires-at))))\n\n;; Returns the burn height at which a particular contract is allowed to stack for a particular principal.\n;; The result is (some (some X)) if X is the burn height at which the allowance terminates.\n;; The result is (some none) if the caller is allowed indefinitely.\n;; The result is none if there is no allowance record.\n(define-read-only (get-allowance-contract-callers (sender principal) (calling-contract principal))\n  (map-get? allowance-contract-callers { sender: sender, contract-caller: calling-contract}))\n",
    "analysis": {
      "summary": "This contract enables users to delegate their STX tokens for Stacking in pools, allowing pool operators to lock these tokens to participate in Stacking on behalf of users.",
      "explanation": "The contract serves as a wrapper for Stacking pools, facilitating the delegation of STX tokens from users to pool operators for Stacking in the PoX (Proof of Transfer) protocol. It includes mechanisms for handling delegation, tracking user and pool data, and interfacing with the PoX contract for Stacking operations.\n\n1. Constants and Data Storage:\n- Error codes <L14-22> define various failure states such as non-positive amounts or forbidden actions.\n- The `pox-info` constant <L24> retrieves global PoX information from the PoX contract.\n- Maps like `allowance-contract-callers` <L27-29> and `user-data` <L34> store permissions and user delegation details, respectively.\n\n2. Functions Analysis:\n- `delegate-stx` <L204-224> allows users to delegate STX for Stacking, specifying amounts, delegatees, and optional parameters for reward addresses and metadata.\n- `delegate-stack-stx` and `delegate-stack-stx-simple` <L226-249> are for pool operators to lock delegated STX in batches, with the former allowing specific amounts and the latter determining amounts based on user balances and delegated amounts.\n- Helper functions like `merge-details` <L53-58> and `map-set-details` <L65-75> facilitate the manipulation and storage of user and Stacking details.\n- Read-only functions <L255-310> provide utilities for converting between burn heights and reward cycles, fetching user Stacking statuses, and querying total locked STX for pools.\n\n3. Notable Qualities:\n- The contract integrates closely with the PoX protocol, extending its functionality to support pooled Stacking.\n- It employs a detailed permission system for contract calls, allowing users to control which contracts can act on their behalf.\n- The contract handles both direct delegation and batch operations for pool operators, accommodating various Stacking strategies.\n- Extensive error handling and data validation ensure robust operation and user protection.",
      "tags": ["DeFi", "staking", "utility", "protocol"]
    }
  },
  {
    "rank": 16,
    "contract": "SP1NAZ59R1ED0V6NH9N0EQBEB3MKT48CQCMKC5Q41.swap-router-v23",
    "calls": 3512,
    "source": "(use-trait et 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.extension-trait.extension-trait) (impl-trait 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.extension-trait.extension-trait) (define-constant E8 u100000000) (define-read-only (s2e (n uint)) (* n u100))(define-public (i1 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5k0yl5ot8l (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u1)) (ok u0)))(define-public (o1 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5k0yl5ot8l in u1)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0)))(define-public (i2 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda u5000000 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0)))(define-public (o2 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda u5000000 (s2e (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (ok u0)))(define-public (i3 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender))) none)) (ok u0)))(define-public (o3 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e in) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)) u0)) (ok u0)))(define-public (i4 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnyc E8 (s2e in) none)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kielx1jn7 (unwrap-panic (contract-call? 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 get-balance tx-sender)) u1)) (ok u0)))(define-public (o4 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kielx1jn7 in u1)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnyc E8 (s2e (unwrap-panic (contract-call? 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 get-balance tx-sender))) none)) (ok u0)))(define-public (i5 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wdiko E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (ok u0)))(define-public (o5 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wdiko E8 (s2e (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0)))(define-public (i6 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0)))(define-public (o6 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda E8 (s2e (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0)))(define-public (i7 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token in u0)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kt9nmle8c (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u1)) (ok u0)))(define-public (o7 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kt9nmle8c in u1)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (ok u0)))(define-public (i8 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-stx-stsw in u1)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kbe3oqvac (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a get-balance tx-sender)) u1)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender))) none)) (ok u0)))(define-public (o8 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e in) none)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kbe3oqvac (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)) u1)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-stx-stsw (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a get-balance tx-sender)) u1)) (ok u0)))(define-public (i9 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u27 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender))) none)) (ok u0)))(define-public (o9 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e in) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u27 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)) u1 )) (ok u0)))(define-public (i10 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) none)) (ok u0)))(define-public (o10 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (s2e in) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0)))(define-public (i11 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (ok u0)))(define-public (o11 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token in u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0)))(define-public (i12 (in uint)) (begin (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-x-for-y 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc in u1)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u22 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u21 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token get-balance tx-sender)) u1 )) (ok u0)))(define-public (o12 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u21 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u22 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token get-balance tx-sender)) u1 )) (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-y-for-x 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1)) (ok u0)))(define-public (i13 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (unwrap-panic (contract-call? 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-usda-aeusdc-v-1-4 swap-y-for-x 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.usda-aeusdc-lp-token-v-1-4 (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (unwrap-panic (contract-call? 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-usda-aeusdc-v-1-2 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.usda-aeusdc-lp-token-v-1-2 (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0)))(define-public (o13 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (unwrap-panic (contract-call? 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-usda-aeusdc-v-1-2 swap-y-for-x 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.usda-aeusdc-lp-token-v-1-2 (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (unwrap-panic (contract-call? 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-usda-aeusdc-v-1-4 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.usda-aeusdc-lp-token-v-1-4 (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0)))(define-public (i14 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u11 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wpepe E8 (* u100000 (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0)))(define-public (o14 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wpepe E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u11 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz get-balance tx-sender)) u1 )) (ok u0)))(define-public (i15 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc u5000000 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) none)) (ok u0)))(define-public (o15 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc u5000000 (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc get-balance tx-sender)) none)) (ok u0)))(define-public (i16 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd u5000000 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt get-balance tx-sender)) none)) (ok u0)))(define-public (o16 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd u5000000 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (ok u0)))(define-public (i17 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wleo E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u28 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token get-balance tx-sender)) u1 )) (ok u0)))(define-public (o17 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u28 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wleo E8 (s2e (unwrap-panic (contract-call? 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0)))(define-public (i18 (in uint)) (begin (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-x-for-y 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc in u1)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-waeusdc E8 (s2e (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender))) none)) (ok u0)))(define-public (o18 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-waeusdc E8 (s2e in) none)) (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-y-for-x 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1)) (ok u0)))(define-public (i19 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-y-for-x 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1)) (ok u0)))(define-public (o19 (in uint)) (begin (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-x-for-y 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc in u1)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0)))(define-public (i20 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc 'SP1E0XBN9T4B10E9QMR7XMFJPMA19D77WY3KP2QKC.token-wsbtc u5000000 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP1E0XBN9T4B10E9QMR7XMFJPMA19D77WY3KP2QKC.token-wsbtc E8 (unwrap-panic (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token get-balance tx-sender)) none)) (ok u0)))(define-public (o20 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP1E0XBN9T4B10E9QMR7XMFJPMA19D77WY3KP2QKC.token-wsbtc E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc 'SP1E0XBN9T4B10E9QMR7XMFJPMA19D77WY3KP2QKC.token-wsbtc u5000000 (unwrap-panic (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc get-balance tx-sender)) none)) (ok u0)))(define-public (i21 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wgoat E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u36 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx get-balance tx-sender)) u1 )) (ok u0)))(define-public (o21 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u36 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wgoat E8 (s2e (unwrap-panic (contract-call? 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0)))(define-public (i22 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnot E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u16 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope 'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope get-balance tx-sender)) u1 )) (ok u0)))(define-public (o22 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u16 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnot E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnot get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0)))(define-public (i23 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-pool-v1_0_0-0003 swap 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3W69VDG9VTZNG7NTW1QNCC1W45SNY98W1JSZBJH.flat-earth-stxcity 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-fees-v1_0_0-0003 in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2SF8P7AKN8NYHD57T96C51RRV9M0GKRN02BNHD2.token-wflat E8 (s2e (unwrap-panic (contract-call? 'SP3W69VDG9VTZNG7NTW1QNCC1W45SNY98W1JSZBJH.flat-earth-stxcity get-balance tx-sender))) none)) (ok u0)))(define-public (o23 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2SF8P7AKN8NYHD57T96C51RRV9M0GKRN02BNHD2.token-wflat E8 (s2e in) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-pool-v1_0_0-0003 swap 'SP3W69VDG9VTZNG7NTW1QNCC1W45SNY98W1JSZBJH.flat-earth-stxcity 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-fees-v1_0_0-0003 (unwrap-panic (contract-call? 'SP3W69VDG9VTZNG7NTW1QNCC1W45SNY98W1JSZBJH.flat-earth-stxcity get-balance tx-sender)) u1 )) (ok u0)))(define-public (i24 (in uint)) (begin (try! (contract-call? 'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.univ2-pool-v1_0_0-0070 swap 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token 'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.univ2-fees-v1_0_0-0070 in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP1E0XBN9T4B10E9QMR7XMFJPMA19D77WY3KP2QKC.token-wsbtc E8 (unwrap-panic (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token get-balance tx-sender)) none)) (ok u0)))(define-public (o24 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP1E0XBN9T4B10E9QMR7XMFJPMA19D77WY3KP2QKC.token-wsbtc E8 (s2e in) none)) (try! (contract-call? 'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.univ2-pool-v1_0_0-0070 swap 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.univ2-fees-v1_0_0-0070 (unwrap-panic (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token get-balance tx-sender)) u1 )) (ok u0)))(define-public (i25 (in uint)) (begin (try! (contract-call? 'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.univ2-pool-v1_0_0-0070 swap 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token 'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.univ2-fees-v1_0_0-0070 in u1 )) (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-2 swap-x-for-y 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-sbtc-stx-v-1-1 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-2 (unwrap-panic (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token get-balance tx-sender)) u1)) (ok u0)))(define-public (o25 (in uint)) (begin (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-2 swap-y-for-x 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-sbtc-stx-v-1-1 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-2 in u1)) (try! (contract-call? 'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.univ2-pool-v1_0_0-0070 swap 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.univ2-fees-v1_0_0-0070 (unwrap-panic (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token get-balance tx-sender)) u1 )) (ok u0)))(define-public (callback (p principal) (bp (buff 2048))) (let ((enc (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? bp u0 u16)) u16)))) (bh (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? bp u16 u20)) u4)))) (addr (get hashbytes (unwrap-panic (element-at? (get addrs (unwrap-panic (get-burn-block-info? pox-addrs bh))) u0)))) (di (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? addr u0 u4)) u4)))) (do (mod enc (+ di u4280000000 b0))) (c (mod do u100)) (in (* do u100)) (ts (if (< c u30) (if (<= c u12) (list (if (is-eq c u1) (i1 in) (err u0)) (if (is-eq c u2) (i2 in) (err u0)) (if (is-eq c u3) (i3 in) (err u0)) (if (is-eq c u4) (i4 in) (err u0)) (if (is-eq c u5) (i5 in) (err u0)) (if (is-eq c u6) (i6 in) (err u0)) (if (is-eq c u7) (i7 in) (err u0)) (if (is-eq c u8) (i8 in) (err u0)) (if (is-eq c u9) (i9 in) (err u0)) (if (is-eq c u10) (i10 in) (err u0)) (if (is-eq c u11) (i11 in) (err u0)) (if (is-eq c u12) (i12 in) (err u0))) (list (if (is-eq c u13) (i13 in) (err u0)) (if (is-eq c u14) (i14 in) (err u0)) (if (is-eq c u15) (i15 in) (err u0)) (if (is-eq c u16) (i16 in) (err u0)) (if (is-eq c u17) (i17 in) (err u0)) (if (is-eq c u18) (i18 in) (err u0)) (if (is-eq c u19) (i19 in) (err u0)) (if (is-eq c u20) (i20 in) (err u0)) (if (is-eq c u21) (i21 in) (err u0)) (if (is-eq c u22) (i22 in) (err u0)) (if (is-eq c u23) (i23 in) (err u0)) (if (is-eq c u24) (i24 in) (err u0)) (if (is-eq c u25) (i25 in) (err u0)))) (if (<= c u42) (list (if (is-eq c u31) (o1 in) (err u0)) (if (is-eq c u32) (o2 in) (err u0)) (if (is-eq c u33) (o3 in) (err u0)) (if (is-eq c u34) (o4 in) (err u0)) (if (is-eq c u35) (o5 in) (err u0)) (if (is-eq c u36) (o6 in) (err u0)) (if (is-eq c u37) (o7 in) (err u0)) (if (is-eq c u38) (o8 in) (err u0)) (if (is-eq c u39) (o9 in) (err u0)) (if (is-eq c u40) (o10 in) (err u0)) (if (is-eq c u41) (o11 in) (err u0)) (if (is-eq c u42) (o12 in) (err u0))) (list (if (is-eq c u43) (o13 in) (err u0)) (if (is-eq c u44) (o14 in) (err u0)) (if (is-eq c u45) (o15 in) (err u0)) (if (is-eq c u46) (o16 in) (err u0)) (if (is-eq c u47) (o17 in) (err u0)) (if (is-eq c u48) (o18 in) (err u0)) (if (is-eq c u49) (o19 in) (err u0)) (if (is-eq c u50) (o20 in) (err u0)) (if (is-eq c u51) (o21 in) (err u0)) (if (is-eq c u52) (o22 in) (err u0)) (if (is-eq c u53) (o23 in) (err u0)) (if (is-eq c u54) (o24 in) (err u0)) (if (is-eq c u55) (o25 in) (err u0))))))) (ok true))) (define-private (ee (bp (buff 2048)) (t <et>)) (as-contract (begin (asserts! (is-eq tx-sender (contract-of t)) (err u0)) (try! (contract-call? 'SPB75ZW15C90ZNDPQF4GSVNGBEJJA6WACZKNFVFK.vault-v1 flash-loan-stx t (stx-get-balance 'SPB75ZW15C90ZNDPQF4GSVNGBEJJA6WACZKNFVFK.vault-v1) tx-sender bp)) (let ((ba (stx-get-balance tx-sender))) (and (> ba u0) (try! (stx-transfer? ba tx-sender 'SP1VSDGJ3RCR2K8V1SY5DGNR733YACKPXPHEMXTFD)))) (ok true)))) (define-constant b0 block-height)(define-public (r0 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (r1 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (r2 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (r3 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (r4 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (r5 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (r6 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (r7 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (r8 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (r9 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (ra (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rb (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rc (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rd (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (re (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rf (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rg (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rh (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (ri (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rj (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rk (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rl (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rm (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rn (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (ro (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rp (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rq (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rr (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rs (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rt (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (ru (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rv (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rw (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rx (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (ry (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (rz (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (w0 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (w1 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (w2 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (w3 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (w4 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (w5 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (w6 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (w7 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (w8 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (w9 (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wa (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wb (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wc (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wd (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (we (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wf (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wg (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wh (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wi (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wj (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wk (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wl (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wm (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wn (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wo (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wp (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wq (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wr (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (ws (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wt (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wu (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wv (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (ww (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wx (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wy (bp (buff 2048)) (t <et>)) (ee bp t))(define-public (wz (bp (buff 2048)) (t <et>)) (ee bp t))",
    "analysis": {
      "summary": "This contract facilitates complex token swaps and flash loans within the Stacks blockchain ecosystem.",
      "explanation": "The contract is designed to interact with various DeFi protocols on the Stacks blockchain to perform token swaps and flash loans. It utilizes the flexibility of Clarity to call different contracts based on dynamic inputs, enabling a wide range of DeFi operations within a single contract framework. Here's a detailed breakdown of its components and functionalities:\n\n1. Constants and Data Variables:\n- `E8` <L3> is a constant representing a factor of 10^8, used for precision in token amounts.\n- `b0` <L2292> stores the block height at the time of the contract's deployment.\n\n2. Functions:\n- The `s2e` function <L4> multiplies an input by 10^8, adjusting for the precision used in token amounts.\n- `i1` through `i25` and `o1` through `o25` <L5-L2289> are public functions designed to interact with various token swap contracts. Each function corresponds to a specific swap operation across different DeFi platforms on Stacks. The exact operation (swap-x-for-y or swap-y-for-x) and the tokens involved vary per function, but they all follow a similar structure where they call another contract's swap function with specified parameters.\n- The `callback` function <L2290> is a complex mechanism intended for processing the results of a flash loan operation. It decodes input data to determine the specific operation to execute, then performs a series of conditional checks to call the appropriate swap functions based on the decoded instructions.\n- The `ee` function <L2291> and the series of `r` functions (`r0` through `wz` <L2293-L2365>) are designed for executing flash loans. They ensure that the caller is authorized, perform the loan from a specified vault, and then attempt to execute a series of swaps or other operations before returning the loaned amount.\n\nNotable Qualities:\n- The contract demonstrates an advanced use of Clarity's capabilities for DeFi, showcasing how complex financial operations can be encoded and executed on the Stacks blockchain.\n- The use of a callback mechanism for processing flash loan operations is a sophisticated feature, allowing for dynamic execution of contract calls based on external inputs.\n- The contract interacts with a wide range of DeFi protocols on Stacks, indicating a high level of integration within the ecosystem.",
      "tags": ["DeFi", "swap", "flash-loan", "protocol"]
    }
  },
  {
    "rank": 17,
    "contract": "SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router",
    "calls": 3210,
    "source": ";;; UniswapV2Router02.sol\n\n(use-trait ft-trait 'SP2AKWJYC7BNY18W1XXKPGP0YVEK63QJG4793Z2D4.sip-010-trait-ft-standard.sip-010-trait)\n(use-trait ft-plus-trait .ft-plus-trait.ft-plus-trait)\n(use-trait share-fee-to-trait .univ2-share-fee-to-trait.share-fee-to-trait)\n\n(define-constant err-router-preconditions  (err u200))\n(define-constant err-router-postconditions (err u201))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; add-liquidity\n(define-read-only\n  (add-liquidity-calc\n    (id           uint)\n    (amt0-desired uint)\n    (amt1-desired uint)\n    (amt0-min     uint)\n    (amt1-min     uint))\n  (let ((pool (contract-call? .univ2-core do-get-pool id))\n        (r0   (get reserve0 pool))\n        (r1   (get reserve1 pool)))\n    (if (and (is-eq r0 u0) (is-eq r1 u0))\n        (ok {amt0: amt0-desired, amt1: amt1-desired})\n        (let ((amt1-optimal (try! (contract-call? .univ2-library quote amt0-desired r0 r1)))\n              (amt0-optimal (try! (contract-call? .univ2-library quote amt1-desired r1 r0))) )\n            ;; Note we do not use optimal if > desired.\n            (if (<= amt1-optimal amt1-desired)\n                (begin\n                  (asserts! (>= amt1-optimal amt1-min) err-router-preconditions)\n                  (ok {amt0: amt0-desired, amt1: amt1-optimal}))\n                (begin\n                  (asserts!\n                    (and\n                      (<= amt0-optimal amt0-desired)\n                      (>= amt0-optimal amt0-min))\n                    err-router-preconditions)\n                  (ok {amt0: amt0-optimal, amt1: amt1-desired})) )) )))\n\n(define-public\n  (add-liquidity\n    (id uint)\n    (token0       <ft-trait>)\n    (token1       <ft-trait>)\n    (lp-token     <ft-plus-trait>)\n    (amt0-desired uint)\n    (amt1-desired uint)\n    (amt0-min     uint)\n    (amt1-min     uint))\n\n  (let ((amts (try! (add-liquidity-calc\n                id amt0-desired amt1-desired amt0-min amt1-min))))\n\n    (asserts!\n     (and (<= amt0-min amt0-desired)\n          (<= amt1-min amt1-desired)\n          (>= amt0-min u0)\n          (>= amt1-min u0)\n          (>= amt0-desired u0)\n          (>= amt1-desired u0))\n     err-router-preconditions)\n\n    (contract-call? .univ2-core mint\n      id\n      token0\n      token1\n      lp-token\n      (get amt0 amts)\n      (get amt1 amts)) ))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; remove-liquidity\n(define-public\n  (remove-liquidity\n    (id        uint)\n    (token0    <ft-trait>)\n    (token1    <ft-trait>)\n    (lp-token  <ft-plus-trait>)\n    (liquidity uint)\n    (amt0-min  uint)\n    (amt1-min  uint))\n\n  (let ((event (try! (contract-call? .univ2-core burn\n                  id token0 token1 lp-token liquidity))))\n\n    (asserts!\n      (and (>= (get amt0 event) amt0-min)\n           (>= (get amt1 event) amt1-min))\n      err-router-postconditions)\n\n    (ok event) ))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; swap\n(define-public\n  (swap-exact-tokens-for-tokens\n    (id             uint)\n    (token0         <ft-trait>)\n    (token1         <ft-trait>)\n    (token-in       <ft-trait>)\n    (token-out      <ft-trait>)\n    (share-fee-to   <share-fee-to-trait>)\n    (amt-in      uint)\n    (amt-out-min uint))\n\n  (let ((pool      (contract-call? .univ2-core do-get-pool id))\n        (is-token0 (is-eq (contract-of token0) (contract-of token-in)))\n        (amt-out   (try! (contract-call? .univ2-library get-amount-out\n          amt-in\n          (if is-token0 (get reserve0 pool) (get reserve1 pool))\n          (if is-token0 (get reserve1 pool) (get reserve0 pool))\n          (get swap-fee pool) )))\n       (event      (try! (contract-call? .univ2-core swap\n          id\n          token-in\n          token-out\n          share-fee-to\n          amt-in\n          amt-out))) )\n\n    (asserts!\n     (and (is-eq (get token0 pool) (contract-of token0))\n          (is-eq (get token1 pool) (contract-of token1))\n          (> amt-in      u0)\n          (> amt-out-min u0) )\n     err-router-preconditions)\n\n    (asserts!\n      (and (>= (get amt-out event) amt-out-min))\n      err-router-postconditions)\n\n    (ok event) ))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(define-public\n  (swap-tokens-for-exact-tokens\n    (id           uint)\n    (token0       <ft-trait>)\n    (token1       <ft-trait>)\n    (token-in     <ft-trait>)\n    (token-out    <ft-trait>)\n    (share-fee-to <share-fee-to-trait>)\n    (amt-in-max   uint)\n    (amt-out      uint))\n\n  (let ((pool      (contract-call? .univ2-core do-get-pool id))\n        (is-token0 (is-eq (contract-of token0) (contract-of token-in)))\n        (amt-in    (try! (contract-call? .univ2-library get-amount-in\n          amt-out\n          (if is-token0 (get reserve0 pool) (get reserve1 pool))\n          (if is-token0 (get reserve1 pool) (get reserve0 pool))\n          (get swap-fee pool) )))\n        (event     (try! (contract-call? .univ2-core swap\n          id\n          token-in\n          token-out\n          share-fee-to\n          amt-in\n          amt-out))) )\n\n  (asserts!\n   (and (is-eq (get token0 pool) (contract-of token0))\n        (is-eq (get token1 pool) (contract-of token1))\n        (> amt-in-max u0)\n        (> amt-out    u0) )\n   err-router-preconditions)\n\n  (asserts!\n    (and (<= (get amt-in event) amt-in-max))\n    err-router-postconditions)\n\n  (ok event) ))\n\n;;; eof\n",
    "analysis": {
      "summary": "This contract acts as a router for adding liquidity, removing liquidity, and swapping tokens in a UniswapV2-like decentralized exchange on the Stacks blockchain.",
      "explanation": "The contract leverages Clarity's capabilities to interact with fungible token standards and custom traits to facilitate liquidity pool operations and token swaps. It ensures that operations adhere to specified conditions for security and correctness.\n\n1. Constants <L7-8> define error codes for precondition and postcondition failures, ensuring that functions revert transactions when conditions are not met.\n\n2. The 'add-liquidity-calc' function <L12-37> calculates the optimal amount of tokens to add to a liquidity pool given desired amounts. It checks if the pool is empty <L22> and calculates amounts based on pool reserves <L24-25>. It ensures amounts meet minimum requirements <L29, L32-35>.\n\n3. The 'add-liquidity' function <L39-68> adds liquidity to a pool. It calculates amounts with 'add-liquidity-calc' <L50>, checks minimum requirements <L53-59>, and calls the core contract to mint liquidity pool tokens <L62-68>.\n\n4. The 'remove-liquidity' function <L72-90> removes liquidity from a pool and returns the underlying tokens. It calls the core contract to burn liquidity tokens <L82> and checks that the returned amounts meet minimum requirements <L85-88>.\n\n5. The 'swap-exact-tokens-for-tokens' function <L94-131> and 'swap-tokens-for-exact-tokens' function <L134-171> facilitate token swaps with exact input or output amounts. They calculate required amounts <L105-111, L145-151>, perform the swap <L112-118, L152-158>, and ensure the swap meets specified conditions <L120-125, L127-129, L160-165, L167-169>.\n\nEach function includes safety checks to ensure operations do not proceed under unsafe conditions, such as insufficient input amounts or undesirable output amounts. The contract interacts with external contracts for core liquidity pool operations and utilizes the SIP-010 standard for fungible tokens and custom traits for extended functionalities.",
      "tags": ["DeFi", "DEX", "liquidity-pool", "token-swap"]
    }
  },
  {
    "rank": 18,
    "contract": "SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.alex-farming",
    "calls": 3164,
    "source": "(impl-trait .extension-trait.extension-trait)\n(impl-trait .proposal-trait.proposal-trait)\n(use-trait sft-trait .trait-semi-fungible.semi-fungible-trait)\n(define-constant ERR-NOT-AUTHORIZED (err u1000))\n(define-constant ERR-TRANSFER-FAILED (err u3000))\n(define-constant ERR-USER-ALREADY-REGISTERED (err u10001))\n(define-constant ERR-USER-ID-NOT-FOUND (err u10003))\n(define-constant ERR-CONTRACT-NOT-ACTIVATED (err u10005))\n(define-constant ERR-STAKING-NOT-AVAILABLE (err u10015))\n(define-constant ERR-CANNOT-STAKE (err u10016))\n(define-constant ERR-REWARD-CYCLE-NOT-COMPLETED (err u10017))\n(define-constant ERR-AMOUNT-EXCEED-RESERVE (err u2024))\n(define-constant ERR-INVALID-TOKEN (err u2026))\n(define-constant ONE_8 u100000000) ;; 8 decimal places\n(define-constant MAX_UINT u340282366920938463463374607431768211455)\n(define-constant MAX-REWARD-CYCLES u32)\n(define-constant REWARD-CYCLE-INDEXES (list u0 u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13 u14 u15 u16 u17 u18 u19 u20 u21 u22 u23 u24 u25 u26 u27 u28 u29 u30 u31))\n(define-map approved-tokens {token: principal, token-id: uint } bool)\n(define-data-var reward-cycle-length uint u525) ;; number of block-heights per cycle\n(define-data-var token-halving-cycle uint u100) ;; number of cycles it takes for token emission to transition to the next\n(define-map activation-block { token: principal, token-id: uint } uint)\n(define-map coinbase-amounts { token: principal, token-id: uint } { coinbase-amount-1: uint, coinbase-amount-2: uint, coinbase-amount-3: uint, coinbase-amount-4: uint, coinbase-amount-5: uint })\n(define-map staking-stats-at-cycle { token: principal, token-id: uint, reward-cycle: uint } uint)\n(define-map staker-at-cycle { token: principal, token-id: uint, reward-cycle: uint, user-id: uint } { amount-staked: uint, to-return: uint })\n(define-map apower-multiplier-in-fixed { token: principal, token-id: uint } uint)\n(define-map users-nonce { token: principal, token-id: uint } uint)\n(define-map users { token: principal, token-id: uint, user-id: uint } principal\n)\n(define-map user-ids { token: principal, token-id: uint, user: principal } uint)\n(define-data-var coinbase-threshold-1 uint (var-get token-halving-cycle))\n(define-data-var coinbase-threshold-2 uint (* u2 (var-get token-halving-cycle)))\n(define-data-var coinbase-threshold-3 uint (* u3 (var-get token-halving-cycle)))\n(define-data-var coinbase-threshold-4 uint (* u4 (var-get token-halving-cycle)))\n(define-data-var coinbase-threshold-5 uint (* u5 (var-get token-halving-cycle)))\n(define-read-only (is-dao-or-extension)\n    (ok (asserts! (or (is-eq tx-sender .executor-dao) (contract-call? .executor-dao is-extension contract-caller)) ERR-NOT-AUTHORIZED)))\n(define-read-only (check-is-approved-token (token principal) (token-id uint))\n  (ok (asserts! (default-to false (map-get? approved-tokens { token: token, token-id: token-id })) ERR-INVALID-TOKEN)))\n(define-read-only (get-reward-cycle-length)\n  (var-get reward-cycle-length))\n(define-read-only (get-apower-multiplier-in-fixed-or-default (token principal) (token-id uint))\n  (default-to u0 (map-get? apower-multiplier-in-fixed { token: token, token-id: token-id })))\n(define-read-only (get-activation-block-or-default (token principal) (token-id uint))\n  (default-to MAX_UINT (map-get? activation-block { token: token, token-id: token-id })))\n(define-read-only (get-staking-stats-at-cycle (token principal) (token-id uint) (reward-cycle uint))\n  (map-get? staking-stats-at-cycle {token: token, token-id: token-id, reward-cycle: reward-cycle}))\n(define-read-only (get-staking-stats-at-cycle-or-default (token principal) (token-id uint) (reward-cycle uint))\n  (default-to u0 (get-staking-stats-at-cycle token token-id reward-cycle)))\n(define-read-only (get-staking-stats-at-cycle-or-default-many (token principal) (token-id uint) (reward-cycle (list 200 uint)))\n  (map get-staking-stats-at-cycle-or-default\n      (list\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n      )\n      (list\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n      )\n      reward-cycle))\n(define-read-only (get-user-id (token principal) (token-id uint) (user principal))\n  (map-get? user-ids {token: token, token-id: token-id, user: user}))\n(define-read-only (get-user (token principal) (token-id uint) (user-id uint))\n  (map-get? users {token: token, token-id: token-id, user-id: user-id}))\n(define-read-only (get-registered-users-nonce (token principal) (token-id uint))\n  (map-get? users-nonce {token: token, token-id: token-id}))\n(define-read-only (get-registered-users-nonce-or-default (token principal) (token-id uint))\n  (default-to u0 (get-registered-users-nonce token token-id)))\n(define-read-only (get-staker-at-cycle (token principal) (token-id uint) (reward-cycle uint) (user-id uint))\n  (map-get? staker-at-cycle { token: token, token-id: token-id, reward-cycle: reward-cycle, user-id: user-id }))\n(define-read-only (get-staker-at-cycle-or-default (token principal) (token-id uint) (reward-cycle uint) (user-id uint))\n  (default-to { amount-staked: u0, to-return: u0 } (map-get? staker-at-cycle { token: token, token-id: token-id, reward-cycle: reward-cycle, user-id: user-id })))\n(define-read-only (get-reward-cycle (token principal) (token-id uint) (stacks-height uint))\n  (let (\n      (first-staking-block (get-activation-block-or-default token token-id))\n      (rcLen (var-get reward-cycle-length)))\n    (if (>= stacks-height first-staking-block) (some (/ (- stacks-height first-staking-block) rcLen)) none)))\n(define-read-only (staking-active-at-cycle (token principal) (token-id uint) (reward-cycle uint))\n  (is-some (map-get? staking-stats-at-cycle {token: token, token-id: token-id, reward-cycle: reward-cycle})))\n(define-read-only (get-first-stacks-block-in-reward-cycle (token principal) (token-id uint) (reward-cycle uint))\n  (+ (get-activation-block-or-default token token-id) (* (var-get reward-cycle-length) reward-cycle)))\n(define-read-only (get-staking-reward (token principal) (token-id uint) (user-id uint) (target-cycle uint))\n  (get-entitled-staking-reward token token-id user-id target-cycle block-height))\n(define-read-only (get-token-halving-cycle)\n  (var-get token-halving-cycle))\n(define-read-only (get-coinbase-thresholds)\n  (ok {\n      coinbase-threshold-1: (var-get coinbase-threshold-1),\n      coinbase-threshold-2: (var-get coinbase-threshold-2),\n      coinbase-threshold-3: (var-get coinbase-threshold-3),\n      coinbase-threshold-4: (var-get coinbase-threshold-4),\n      coinbase-threshold-5: (var-get coinbase-threshold-5) }))\n(define-read-only (get-coinbase-amount-or-default (token principal) (token-id uint) (reward-cycle uint))\n  (let (\n      (coinbase  (default-to { coinbase-amount-1: u0, coinbase-amount-2: u0, coinbase-amount-3: u0, coinbase-amount-4: u0, coinbase-amount-5: u0 }\n          (map-get? coinbase-amounts { token: token, token-id: token-id }))))\n    ;; computations based on each halving threshold\n    (asserts! (> reward-cycle (var-get coinbase-threshold-1)) (get coinbase-amount-1 coinbase))\n    (asserts! (> reward-cycle (var-get coinbase-threshold-2)) (get coinbase-amount-2 coinbase))\n    (asserts! (> reward-cycle (var-get coinbase-threshold-3)) (get coinbase-amount-3 coinbase))\n    (asserts! (> reward-cycle (var-get coinbase-threshold-4)) (get coinbase-amount-4 coinbase))\n    (asserts! (> reward-cycle (var-get coinbase-threshold-5)) (get coinbase-amount-5 coinbase))\n    ;; default value after 5th halving\n    u0))\n(define-read-only (get-coinbase-amounts-or-default (token principal) (token-id uint))\n    (default-to { coinbase-amount-1: u0, coinbase-amount-2: u0, coinbase-amount-3: u0, coinbase-amount-4: u0, coinbase-amount-5: u0 } (map-get? coinbase-amounts { token: token, token-id: token-id })))\n(define-public (stake-tokens (token-trait <sft-trait>) (token-id uint) (amount-token uint) (lock-period uint))\n  (begin\n    (try! (check-is-approved-token (contract-of token-trait) token-id))\n    (stake-tokens-at-cycle token-trait token-id tx-sender (get-or-create-user-id (contract-of token-trait) token-id tx-sender) amount-token block-height lock-period)))\n(define-public (claim-staking-reward (token-trait <sft-trait>) (token-id uint) (target-cycle uint))\n  (begin\n    (try! (check-is-approved-token (contract-of token-trait) token-id))\n    (claim-staking-reward-at-cycle token-trait token-id tx-sender block-height target-cycle)))\n(define-public (claim-staking-reward-many (token <sft-trait>) (token-id uint) (target-cycles (list 200 uint)))\n  (ok (map\n      claim-staking-reward\n      (list\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n        token token token token token token token token token token token token token token token token token token token token\n      )\n      (list\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n        token-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\ttoken-id\n      )\n      target-cycles)))\n(define-public (set-reward-cycle-length (new-reward-cycle-length uint))\n  (begin\n    (try! (is-dao-or-extension))\n    (ok (var-set reward-cycle-length new-reward-cycle-length))))\n(define-public (add-token (token principal) (token-id uint))\n  (begin\n    (try! (is-dao-or-extension))\n    (map-set approved-tokens { token: token, token-id: token-id } true)\n    (ok (map-set users-nonce { token: token, token-id: token-id } u0))))\n(define-public (set-apower-multiplier-in-fixed (token principal) (token-id uint) (new-apower-multiplier-in-fixed uint))\n  (begin\n    (try! (is-dao-or-extension))\n    (ok (map-set apower-multiplier-in-fixed { token: token, token-id: token-id } new-apower-multiplier-in-fixed))))\n(define-public (set-activation-block (token principal) (token-id uint) (new-activation-block uint))\n  (begin\n    (try! (is-dao-or-extension))\n    (ok (map-set activation-block { token: token, token-id: token-id } new-activation-block))))\n(define-public (set-token-halving-cycle (new-token-halving-cycle uint))\n  (begin\n    (try! (is-dao-or-extension))\n    (var-set token-halving-cycle new-token-halving-cycle)\n    (ok (set-coinbase-thresholds))))\n(define-public (set-coinbase-amount (token principal) (token-id uint) (coinbase-1 uint) (coinbase-2 uint) (coinbase-3 uint) (coinbase-4 uint) (coinbase-5 uint))\n  (begin\n    (try! (is-dao-or-extension))\n    (ok (map-set coinbase-amounts\n\t\t\t{ token: token, token-id: token-id }\n      { coinbase-amount-1: coinbase-1, coinbase-amount-2: coinbase-2, coinbase-amount-3: coinbase-3, coinbase-amount-4: coinbase-4, coinbase-amount-5: coinbase-5 }))))\n(define-public (callback (sender principal) (payload (buff 2048)))\n\t(ok true))\n(define-public (execute (sender principal))\n\t(begin\n\t\t(try! (contract-call? .executor-dao set-extensions (list { extension: .alex-farming, enabled: true } )))\t\t\n\t\t(ok true)))\n(define-private (get-or-create-user-id (token principal) (token-id uint) (user principal))\n  (match (map-get? user-ids {token: token, token-id: token-id, user: user})\n    value value\n    (let (\n        (new-id (+ u1 (get-registered-users-nonce-or-default token token-id))))\n      (map-insert users {token: token, token-id: token-id, user-id: new-id} user)\n      (map-insert user-ids {token: token, token-id: token-id, user: user} new-id)\n      (map-set users-nonce {token: token, token-id: token-id} new-id)\n      new-id)))\n(define-private (get-entitled-staking-reward (token principal) (token-id uint) (user-id uint) (target-cycle uint) (stacks-height uint))\n  (let (\n      (total-staked-this-cycle (get-staking-stats-at-cycle-or-default token token-id target-cycle))\n      (user-staked-this-cycle (get amount-staked (get-staker-at-cycle-or-default token token-id target-cycle user-id))))\n    (match (get-reward-cycle token token-id stacks-height)\n      current-cycle (div-down (mul-down (get-coinbase-amount-or-default token token-id target-cycle) user-staked-this-cycle) total-staked-this-cycle)\n      u0)))\n(define-private (stake-tokens-at-cycle (token-trait <sft-trait>) (token-id uint) (user principal) (user-id uint) (amount-token uint) (start-height uint) (lock-period uint))\n  (let (\n      (token (contract-of token-trait))\n      (current-cycle (unwrap! (get-reward-cycle token token-id start-height) ERR-STAKING-NOT-AVAILABLE))\n      (target-cycle (+ u1 current-cycle))\n      (commitment { token: token, token-id: token-id, staker-id: user-id, amount: amount-token, first: target-cycle, last: (+ target-cycle lock-period)}))\n    (try! (check-is-approved-token (contract-of token-trait) token-id))\n    (asserts! (>= block-height (get-activation-block-or-default token token-id)) ERR-CONTRACT-NOT-ACTIVATED)\n    (asserts! (and (> lock-period u0) (<= lock-period MAX-REWARD-CYCLES)) ERR-CANNOT-STAKE)\n    (asserts! (> amount-token u0) ERR-CANNOT-STAKE)\n    (unwrap! (contract-call? token-trait transfer-fixed token-id amount-token tx-sender .amm-vault-v2-01) ERR-TRANSFER-FAILED)\n    (try! (fold stake-tokens-closure REWARD-CYCLE-INDEXES (ok commitment)))\n    (ok true)))\n(define-private (stake-tokens-closure (reward-cycle-idx uint) (commitment-response (response { token: principal, token-id: uint, staker-id: uint, amount: uint, first: uint, last: uint } uint)))\n  (match commitment-response\n    commitment\n    (let (\n        (token (get token commitment))\n        (token-id (get token-id commitment))\n        (staker-id (get staker-id commitment))\n        (amount-token (get amount commitment))\n        (first-cycle (get first commitment))\n        (last-cycle (get last commitment))\n        (target-cycle (+ first-cycle reward-cycle-idx))\n        (this-staker-at-cycle (get-staker-at-cycle-or-default token token-id target-cycle staker-id))\n        (amount-staked (get amount-staked this-staker-at-cycle))\n        (to-return (get to-return this-staker-at-cycle)))\n      (if (and (>= target-cycle first-cycle) (< target-cycle last-cycle))\n        (begin\n          (if (is-eq target-cycle (- last-cycle u1))\n\t\t\t\t\t\t(set-tokens-staked token token-id staker-id target-cycle amount-token amount-token)\n            (set-tokens-staked token token-id staker-id target-cycle amount-token u0))\n          true)\n        false)\n      commitment-response)\n    err-value commitment-response))\n(define-private (set-tokens-staked (token principal) (token-id uint) (user-id uint) (target-cycle uint) (amount-staked uint) (to-return uint))\n  (let (\n      (this-staker-at-cycle (get-staker-at-cycle-or-default token token-id target-cycle user-id)))\n    (map-set staking-stats-at-cycle {token: token, token-id: token-id, reward-cycle: target-cycle} (+ amount-staked (get-staking-stats-at-cycle-or-default token token-id target-cycle)))\n    (map-set staker-at-cycle\n\t\t\t{ token: token, token-id: token-id, reward-cycle: target-cycle, user-id: user-id }\n      { amount-staked: (+ amount-staked (get amount-staked this-staker-at-cycle)), to-return: (+ to-return (get to-return this-staker-at-cycle)) })))\n(define-private (claim-staking-reward-at-cycle (token-trait <sft-trait>) (token-id uint) (user principal) (stacks-height uint) (target-cycle uint))\n  (let (\n      (token (contract-of token-trait))\n      (current-cycle (unwrap! (get-reward-cycle token token-id stacks-height) ERR-STAKING-NOT-AVAILABLE))\n      (user-id (unwrap! (get-user-id token token-id user) ERR-USER-ID-NOT-FOUND))\n      (entitled-token (get-entitled-staking-reward token token-id user-id target-cycle stacks-height))\n      (to-return (get to-return (get-staker-at-cycle-or-default token token-id target-cycle user-id))))\n    (asserts! (default-to false (map-get? approved-tokens {token: token, token-id: token-id})) ERR-INVALID-TOKEN)\n    (asserts! (> current-cycle target-cycle) ERR-REWARD-CYCLE-NOT-COMPLETED)\n    ;; disable ability to claim again\n    (map-set staker-at-cycle\n      { token: token, token-id: token-id, reward-cycle: target-cycle, user-id: user-id }\n      { amount-staked: u0, to-return: u0 })\n    ;; send back tokens if user was eligible\n    (and (> to-return u0) (as-contract (try! (contract-call? .amm-vault-v2-01 transfer-sft token-trait token-id to-return user))))\n    ;; send back rewards if user was eligible\n    (and (> entitled-token u0) (as-contract (try! (contract-call? .token-alex mint-fixed entitled-token user))))\n    (and\n      (> entitled-token u0)\n      (> (get-apower-multiplier-in-fixed-or-default token token-id) u0)\n      (as-contract (try! (contract-call? 'SP3K8BC0PPEVCV7NZ6QSRWPQ2JE9E5B6N3PA0KBR9.token-apower mint-fixed (mul-down entitled-token (get-apower-multiplier-in-fixed-or-default token token-id)) user))))\n    (ok { to-return: to-return, entitled-token: entitled-token })))\n(define-private (set-coinbase-thresholds)\n  (begin\n    (var-set coinbase-threshold-1 (var-get token-halving-cycle))\n    (var-set coinbase-threshold-2 (* u2 (var-get token-halving-cycle)))\n    (var-set coinbase-threshold-3 (* u3 (var-get token-halving-cycle)))\n    (var-set coinbase-threshold-4 (* u4 (var-get token-halving-cycle)))\n    (var-set coinbase-threshold-5 (* u5 (var-get token-halving-cycle)))))\n(define-private (mul-down (a uint) (b uint))\n    (/ (* a b) ONE_8))\n(define-private (div-down (a uint) (b uint))\n  (if (is-eq a u0) u0 (/ (* a ONE_8) b)))",
    "analysis": {
      "summary": "This contract manages a staking mechanism for semi-fungible tokens (SFTs), including reward calculation and distribution based on staking periods and user contributions.",
      "explanation": "The contract introduces a complex staking mechanism for SFTs, incorporating reward cycles, token halving, and user registration. It utilizes various data structures and constants to manage the staking process, calculate rewards, and ensure only authorized tokens are staked. Here's a breakdown of its components and functionalities:\n\n1. Constants like `ERR-NOT-AUTHORIZED` <L4> and `ONE_8` <L14> define error codes and the precision for calculations.\n2. Data variables and maps, such as `reward-cycle-length` <L19> and `approved-tokens` <L18>, track global settings and the status of tokens and users.\n3. The `stake-tokens` function <L122-125> allows users to stake approved tokens, checking for token approval <L124> and then delegating to `stake-tokens-at-cycle` for the actual staking logic.\n4. `claim-staking-reward` <L126-129> and its variant for multiple cycles <L130-157> let users claim rewards for a specific cycle or multiple cycles, respectively, after verifying token approval and calculating the reward.\n5. Administrative functions like `set-reward-cycle-length` <L158-161> and `add-token` <L162-166> enable contract governance to adjust parameters and approve new tokens for staking.\n6. Internal functions, such as `get-or-create-user-id` <L192-200> and `get-entitled-staking-reward` <L201-207>, handle user registration and reward calculation, utilizing various checks and balances to ensure integrity.\n\nEach function meticulously checks conditions, such as token approval, activation status, and staking eligibility, to maintain contract security and fairness. The contract also interfaces with external contracts for token transfers and minting rewards, ensuring a seamless staking experience.",
      "tags": ["staking", "semi-fungible-token", "rewards", "governance"]
    }
  },
  {
    "rank": 19,
    "contract": "SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.wrapper-velar-multihop-v-1-1",
    "calls": 3037,
    "source": ";; wrapper-velar-multihop-v-1-1\n\n(use-trait ft-trait 'SP2AKWJYC7BNY18W1XXKPGP0YVEK63QJG4793Z2D4.sip-010-trait-ft-standard.sip-010-trait)\n(use-trait share-fee-to-trait 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to-trait.share-fee-to-trait)\n\n(define-public (swap-3\n    (amt-in uint) (amt-out-min uint)\n    (token-a <ft-trait>) (token-b <ft-trait>)\n    (token-c <ft-trait>)\n    (share-fee-to <share-fee-to-trait>)\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-path2 swap-3\n                  amt-in amt-out-min\n                  token-a token-b\n                  token-c\n                  share-fee-to)))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-public (swap-4\n    (amt-in uint) (amt-out-min uint)\n    (token-a <ft-trait>) (token-b <ft-trait>)\n    (token-c <ft-trait>) (token-d <ft-trait>)\n    (share-fee-to <share-fee-to-trait>)\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-path2 swap-4\n                  amt-in amt-out-min\n                  token-a token-b\n                  token-c token-d\n                  share-fee-to)))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-public (swap-5\n    (amt-in uint) (amt-out-min uint)\n    (token-a <ft-trait>) (token-b <ft-trait>)\n    (token-c <ft-trait>) (token-d <ft-trait>)\n    (token-e <ft-trait>)\n    (share-fee-to <share-fee-to-trait>)\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-path2 swap-5\n                  amt-in amt-out-min\n                  token-a token-b\n                  token-c token-d\n                  token-e\n                  share-fee-to)))\n  )\n    (ok swap-a)\n  )\n)",
    "analysis": {
      "summary": "This contract facilitates multi-hop swaps between tokens on the Stacks blockchain, supporting up to five different tokens in a single transaction.",
      "explanation": "The contract serves as a wrapper for executing complex token swaps involving up to five different tokens through a decentralized exchange (DEX) interface. It integrates with a DEX's swap functions and allows users to specify a minimum amount for the output token to protect against price slippage. Here's a detailed breakdown:\n\n1. **Constants and Traits**:\n- Uses the `ft-trait` from another contract to ensure compatibility with the SIP-010 Fungible Token Standard <L3>.\n- Uses the `share-fee-to-trait` for potentially distributing a portion of transaction fees <L4>.\n\n2. **Functions**:\n- `swap-3` <L6-21>: Enables swapping between three different tokens. Parameters include the input amount (`amt-in`), the minimum output amount (`amt-out-min`), the tokens involved (`token-a`, `token-b`, `token-c`), and a fee-sharing contract (`share-fee-to`). It calls an external contract's `swap-3` function to execute the swap <L13-18>.\n- `swap-4` <L24-39>: Similar to `swap-3`, but for four tokens. It extends the functionality to an additional token (`token-d`) and calls an external contract's `swap-4` function <L31-36>.\n- `swap-5` <L42-59>: The most extensive swap function, allowing for five tokens to be involved in the swap. It follows the same pattern as the previous functions but includes an additional token (`token-e`) and calls an external contract's `swap-5` function <L50-55>.\n\nEach function uses the `try!` macro to attempt the external contract call, reverting the transaction if the call fails. This ensures that swaps only proceed if all parts of the transaction can be successfully completed.\n\n3. **Safety Checks**:\n- The contract relies on external contracts to perform the actual swaps and does not directly handle token transfers or enforce the minimum output amount. It assumes the called contract complies with the specified interfaces and correctly implements the necessary logic and safety checks.\n\n4. **Interactions**:\n- This contract acts as a facade, simplifying the user interface for complex swap operations. It does not manage state or perform calculations but delegates these tasks to the underlying DEX contracts.\n",
      "tags": ["DEX", "utility", "swap", "fungible-token"],
      "notable_qualities": [
        "Simplifies complex token swap operations for users.",
        "Leverages existing DEX functionality, showing composability within DeFi.",
        "Supports up to five tokens in a single transaction, demonstrating flexibility in trading strategies.",
        "Depends on external contracts' compliance with SIP-010 and custom traits for security and functionality."
      ]
    }
  },
  {
    "rank": 20,
    "contract": "SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.earn-stx-ststx-v-1-2",
    "calls": 2972,
    "source": ";; Bitflow Staking & Rewards - v1.2\n;; This contract handles the core logic for staking & rewards, it's where fees are collected and distributed\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;; Cons, Vars, & Maps ;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(use-trait sip-010-trait .sip-010-trait-ft-standard.sip-010-trait)\n(use-trait lp-trait .lp-trait.lp-trait)\n\n;;;;;;;;;;;;;;;\n;; Constants ;;\n;;;;;;;;;;;;;;;\n\n;; Reward cycle index for looping when claiming rewards\n(define-constant reward-cycle-index (list u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13 u14 u15 u16 u17 u18 u19 u20 u21 u22 u23 u24 u25 u26 u27 u28 u29 u30 u31 u32 u33 u34 u35 u36 u37 u38 u39 u40 u41 u42 u43 u44 u45 u46 u47 u48 u49 u50 u51 u52 u53 u54 u55 u56 u57 u58 u59 u60 u61 u62 u63 u64 u65 u66 u67 u68 u69 u70 u71 u72 u73 u74 u75 u76 u77 u78 u79 u80 u81 u82 u83 u84 u85 u86 u87 u88 u89 u90 u91 u92 u93 u94 u95 u96 u97 u98 u99 u100 u101 u102 u103 u104 u105 u106 u107 u108 u109 u110 u111 u112 u113 u114 u115 u116 u117 u118 u119 u120))\n\n;;;;;;;;;;;;;;;\n;; Variables ;;\n;;;;;;;;;;;;;;;\n\n\n;; Helper uint for filtering out null values & mapping from index to next cycle\n(define-data-var helper-uint uint u0)\n\n;; Helper uint list for filtering out existing cycles in cycles-staked list\n(define-data-var helper-uint-list (list 12000 uint) (list ))\n\n\n;;;;;;;;;;\n;; Maps ;;\n;;;;;;;;;;\n\n;; Map that tracks all staking data for a given principal\n(define-map StakerDataMap {y-token: principal, lp-token: principal, user: principal} {\n    cycles-staked: (list 12000 uint),\n    cycles-to-unstake: (list 12000 uint),\n    total-currently-staked: uint\n})\n\n;; Map that tracks staking data per cycle for a given principal\n(define-map StakerDataPerCycleMap {y-token: principal, lp-token: principal, user: principal, cycle: uint} {\n    lp-token-staked: uint,\n    reward-claimed: bool,\n    lp-token-to-unstake: uint\n})\n\n;; Map that tracks staking data per cycle for all stakers\n(define-map DataPerCycleMap {y-token: principal, lp-token: principal, cycle: uint} uint)\n\n;; Map that tracks the total LP tokens currently staked by everyone for a given pair\n(define-map TotalStakedPerPairMap {y-token: principal, lp-token: principal} {total-staked: uint})\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Read-Only Functions ;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Get user data\n(define-read-only (get-user-data (y-token <sip-010-trait>) (lp-token <lp-trait>) (user principal)) \n    (map-get? StakerDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), user: user})\n)\n\n;; Get user data at cycle\n(define-read-only (get-user-data-at-cycle (y-token <sip-010-trait>) (lp-token <lp-trait>) (user principal) (cycle uint)) \n    (map-get? StakerDataPerCycleMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), user: user, cycle: cycle})\n)\n\n;; Get user data at cycle\n(define-read-only (get-data-at-cycle (y-token <sip-010-trait>) (lp-token <lp-trait>) (cycle uint)) \n    (map-get? DataPerCycleMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle: cycle})\n)\n\n;; Get total LP tokens staked for a given pair\n(define-read-only (get-total-staked (y-token <sip-010-trait>) (lp-token <lp-trait>)) \n    (map-get? TotalStakedPerPairMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)})\n)\n\n;; Claim staking rewards per cycle\n(define-read-only (get-staking-rewards-at-cycle (y-token principal) (lp-token principal) (cycle uint))\n    (let \n        (\n            (param-cycle-user-data (unwrap! (map-get? StakerDataPerCycleMap {y-token: y-token, lp-token: lp-token, user: tx-sender, cycle: cycle}) (err u4)))\n            (param-cycle-reward-claimed (get reward-claimed param-cycle-user-data))\n            (param-cycle-user-lp-staked (get lp-token-staked param-cycle-user-data))\n            (param-cycle-total-lp-staked (unwrap! (map-get? DataPerCycleMap {y-token: y-token, lp-token: lp-token, cycle: cycle}) (err u5)))\n            (param-cycle-fees (unwrap! (contract-call? .stableswap-stx-ststx-v-1-2 get-cycle-data y-token lp-token cycle) (err u0)))\n            (param-cycle-balance-x-fee (get cycle-fee-balance-x param-cycle-fees))\n            (param-cycle-x-rewards (/ (* param-cycle-balance-x-fee param-cycle-user-lp-staked) param-cycle-total-lp-staked))\n            (claimer tx-sender)\n        )\n\n        ;; Assert that param-cycle-x rewards are greater than 0\n        (asserts! (> param-cycle-x-rewards u0) (err u1))\n\n        ;; Assert that param-cycle-reward-claimed is false\n        (asserts! (not param-cycle-reward-claimed) (err u2))\n\n        (ok {x-token-reward: param-cycle-x-rewards})\n    )\n)\n\n\n\n;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;\n;;; Stake Function ;;;\n;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;\n\n;; Stake LP Tokens\n;; @desc: This function allows users to stake LP tokens for X cycles to earn rewards\n;; @param: y-token - The Y token contract, lp-token - The LP token contract, cycles - The number of cycles to stake for, lp-token-amount - The amount of LP tokens to stake\n(define-public (stake-lp-tokens (y-token <sip-010-trait>) (lp-token <sip-010-trait>) (cycles uint) (amount uint))\n    (let \n        (\n            (current-staker-data (map-get? StakerDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), user: tx-sender}))\n            (current-cycles-staked (default-to (list ) (get cycles-staked current-staker-data)))\n            (current-cycles-to-unstake (default-to (list ) (get cycles-to-unstake current-staker-data)))\n            (updated-helper-uint-to-filter (var-set helper-uint cycles))\n            (filtered-null-list (filter filter-null-value reward-cycle-index))\n            (current-cycle (contract-call? .stableswap-stx-ststx-v-1-2 get-current-cycle))\n            (updated-helper-uint-to-map (var-set helper-uint current-cycle))\n            (next-cycles (map map-filtered-null-list filtered-null-list))\n            (updated-helper-uint-list-current-cycles (var-set helper-uint-list current-cycles-staked))\n            (next-cycles-not-in-current-cycles (filter filter-list next-cycles))\n            (unstake-cycle (+ u1 (+ current-cycle cycles)))\n            (is-unstakeable-block-in-unstakeable-cycles (is-some (index-of current-cycles-to-unstake unstake-cycle)))\n            (current-all-staker-data (map-get? DataPerCycleMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle: current-cycle}))\n            (pair-data (unwrap! (contract-call? .stableswap-stx-ststx-v-1-2 get-pair-data y-token lp-token) (err \"err-no-pair-data\")))\n            (total-currently-staked-data (default-to {total-staked: u0} (map-get? TotalStakedPerPairMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)})))\n            (total-currently-staked-in-contract (get total-staked total-currently-staked-data))\n            (approved-pair (get approval pair-data))\n        )\n\n        ;; Assert that pair is approved\n        (asserts! approved-pair (err \"err-pair-not-approved\"))\n\n        ;; Assert that cycles is less than 121\n        (asserts! (< cycles u121) (err \"err-cycles-too-high\"))\n\n        ;; Assert that cycles is greater than 0\n        (asserts! (> cycles u0) (err \"err-cycles-too-low\"))\n\n        ;; Assert that amount is greater than 0\n        (asserts! (> amount u0) (err \"err-amount-too-low\"))\n\n        ;; Transfer LP tokens from user to contract\n        (unwrap! (contract-call? lp-token transfer amount tx-sender (as-contract tx-sender) none) (err \"err-lp-token-transfer-failed\"))\n\n        ;; Update lp-tokens-staked in the appropriate cycles\n        (fold update-staker-data-per-cycle-fold next-cycles {y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycles-staked: current-cycles-staked, amount: amount})\n\n        ;; Updating the total balance of LP tokens staked in this contract\n        (map-set TotalStakedPerPairMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)} {total-staked: (+ total-currently-staked-in-contract amount)})\n\n        ;; Update StakerDataMap\n        (if (is-some current-staker-data)\n            ;; Staker already exists, update cycles-staked list\n            (map-set StakerDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), user: tx-sender} {\n                cycles-staked: (unwrap! (as-max-len? (concat current-cycles-staked next-cycles-not-in-current-cycles) u12000) (err \"err-cycles-staked-overflow\")),\n                cycles-to-unstake: (if is-unstakeable-block-in-unstakeable-cycles \n                    ;; Unstakeable cycle already exists, don't update cycles-to-unstake list\n                    current-cycles-to-unstake\n                    ;; Unstakeable cycle doesn't exist, update cycles-to-unstake list\n                    (unwrap! (as-max-len? (concat current-cycles-to-unstake (list unstake-cycle)) u12000) (err \"err-cycles-to-unstake-overflow\"))\n                ),\n                total-currently-staked: (+ amount (default-to u0 (get total-currently-staked current-staker-data)))\n            })\n            ;; Staker doesn't exist, create new staker\n            (map-set StakerDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), user: tx-sender} {\n                cycles-staked: next-cycles,\n                cycles-to-unstake: (list unstake-cycle),\n                total-currently-staked: amount\n            })\n        )\n\n        ;; Update unstakeable lp-token StakerDataMap\n        (ok (if (is-some (map-get? StakerDataPerCycleMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), user: tx-sender, cycle: unstake-cycle}))\n            ;; Staker already exists, only update lp-token-to-unstake\n            (map-set StakerDataPerCycleMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), user: tx-sender, cycle: unstake-cycle} (merge \n                (default-to { lp-token-staked: u0, reward-claimed: false, lp-token-to-unstake: u0} (map-get? StakerDataPerCycleMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), user: tx-sender, cycle: unstake-cycle}))\n                {lp-token-to-unstake: (+ amount (default-to u0 (get lp-token-to-unstake (map-get? StakerDataPerCycleMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), user: tx-sender, cycle: unstake-cycle}))))}\n            ))\n            ;; Staker doesn't exist, create new entry\n            (map-set StakerDataPerCycleMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), user: tx-sender, cycle: unstake-cycle} { \n                lp-token-staked: u0, \n                reward-claimed: false, \n                lp-token-to-unstake: amount\n            })\n        ))\n\n    )\n)\n\n;; Helper filter function to filter out null values lower than helper-uint var\n(define-private (filter-null-value (value uint)) \n    (if (<= value (var-get helper-uint)) \n        true\n        false\n    )\n)\n\n;; Helper map function to map from a filtered index list to a map of next cycles\n(define-private (map-filtered-null-list (index uint)) \n    (+ (var-get helper-uint) index)\n)\n\n;; Helper filter function to filter out cycles already in cycles-staked list\n(define-private (filter-list (value uint)) \n    (if (is-some (index-of (var-get helper-uint-list) value))\n        false\n        true\n    )\n)\n\n;; Helper filter function to filter out cycles where lp-tokens have already been unstaked\n(define-private (filter-unstaked-cycle (value uint)) \n    (if (is-eq value (var-get helper-uint)) \n        false\n        true\n    )\n)\n\n;; Helper function to update StakerDataPerCycleMap\n(define-private (update-staker-data-per-cycle-fold (next-cycle uint) (static-user-and-cycle-data {y-token: principal, lp-token: principal, cycles-staked: (list 12000 uint), amount: uint}))\n    (let \n        (\n            (y-token-static (get y-token static-user-and-cycle-data))\n            (lp-token-static (get lp-token static-user-and-cycle-data))\n            (cycles-staked-static (get cycles-staked static-user-and-cycle-data))\n            (amount-static (get amount static-user-and-cycle-data))\n            (current-cycle-user-data (default-to {lp-token-staked: u0, reward-claimed: false, lp-token-to-unstake: u0} (map-get? StakerDataPerCycleMap {y-token: y-token-static, lp-token: lp-token-static, user: tx-sender, cycle: next-cycle})))\n            (current-cycle-lp-token-staked (get lp-token-staked current-cycle-user-data))\n            (current-cycle-lp-token-to-unstake (get lp-token-to-unstake current-cycle-user-data))\n            (current-cycle-reward-claimed (get reward-claimed current-cycle-user-data))\n            (current-all-staker-data (map-get? DataPerCycleMap {y-token: y-token-static, lp-token: lp-token-static, cycle: next-cycle}))\n        )\n        ;; Check if staker is already staked in this cycle\n        (if (is-some (index-of cycles-staked-static next-cycle))\n            ;; Staker is already staked in this cycle, update StakerDataPerCycleMap\n            (map-set StakerDataPerCycleMap {y-token: y-token-static, lp-token: lp-token-static, user: tx-sender, cycle: next-cycle} (merge \n                    current-cycle-user-data\n                    {lp-token-staked: (+ amount-static current-cycle-lp-token-staked)}\n            ))\n            ;; Staker is not already staked in this cycle, create new StakerDataPerCycleMap\n            (map-set StakerDataPerCycleMap {y-token: y-token-static, lp-token: lp-token-static, user: tx-sender, cycle: next-cycle} (merge \n                    current-cycle-user-data\n            {\n                lp-token-staked: amount-static,\n                reward-claimed: false,\n            }))\n        )\n        ;; Update DataPerCycleMap\n        (if (is-some current-all-staker-data)\n            ;; Cycle data already exists, update total-lp-token-staked\n            (map-set DataPerCycleMap {y-token: y-token-static, lp-token: lp-token-static, cycle: next-cycle} (+ amount-static (default-to u0 current-all-staker-data)))\n            ;; Staker doesn't exist, create new entry\n            (map-set DataPerCycleMap {y-token: y-token-static, lp-token: lp-token-static, cycle: next-cycle} amount-static)\n        )\n\n        static-user-and-cycle-data\n    )\n)\n\n\n\n;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;\n;;; Claim Functions ;;;\n;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Claim staking rewards per cycle\n;; @desc: This function allows users to claim staking rewards for a given cycle\n;; @param: y-token - The Y token contract, lp-token - The LP token contract, cycle - The cycle to claim rewards for\n(define-public (claim-cycle-staking-rewards (y-token principal) (lp-token principal) (y-token-trait <sip-010-trait>) (lp-token-trait <sip-010-trait>) (cycle uint))\n    (let \n        (\n            (current-cycle (contract-call? .stableswap-stx-ststx-v-1-2 get-current-cycle))\n            (param-cycle-user-data (unwrap! (map-get? StakerDataPerCycleMap {y-token: y-token, lp-token: lp-token, user: tx-sender, cycle: cycle}) (err \"err-no-cycle-data\")))\n            (param-cycle-reward-claimed (get reward-claimed param-cycle-user-data))\n            (param-cycle-user-lp-staked (get lp-token-staked param-cycle-user-data))\n            (param-cycle-total-lp-staked (unwrap! (map-get? DataPerCycleMap {y-token: y-token, lp-token: lp-token, cycle: cycle}) (err \"err-no-cycle-data\")))\n            (param-cycle-fees (unwrap! (contract-call? .stableswap-stx-ststx-v-1-2 get-cycle-data y-token lp-token cycle) (err \"err-no-cycle-data\")))\n            (param-cycle-balance-x-fee (get cycle-fee-balance-x param-cycle-fees))\n            (param-cycle-x-rewards (/ (* param-cycle-balance-x-fee param-cycle-user-lp-staked) param-cycle-total-lp-staked))\n            (claimer tx-sender)\n        )\n\n        ;; Assert that param-cycle-x rewards are greater than 0\n        (asserts! (> param-cycle-x-rewards u0) (err \"err-no-x-rewards-to-claim\"))\n\n        ;; Assert that param-cycle-reward-claimed is false\n        (asserts! (not param-cycle-reward-claimed) (err \"err-rewards-already-claimed\"))\n\n        ;; Assert that claiming from a previous cycle\n        (asserts! (< cycle current-cycle) (err \"err-cycle-too-high\"))\n\n        ;; Transfer the rewards from the contract to the claimer\n        (unwrap! (as-contract (stx-transfer? param-cycle-x-rewards tx-sender claimer)) (err \"err-x-token-transfer-failed\"))\n\n        ;; Update StakerDataPerCycleMap with reward-claimed = true\n        (map-set StakerDataPerCycleMap {y-token: y-token, lp-token: lp-token, user: claimer, cycle: cycle} (merge \n            param-cycle-user-data\n            {reward-claimed: true}\n        ))\n\n        ;; Return the number X tokens received after claiming staking rewards from a particular cycle\n        (ok {x-token-reward: param-cycle-x-rewards})\n    )\n)\n\n;; Claim all staking rewards\n;; @desc: This function allows users to claim all staking rewards\n;; @param: y-token - The Y token contract, lp-token - The LP token contract\n(define-public (claim-all-staking-rewards (y-token <sip-010-trait>) (lp-token <sip-010-trait>))\n    (let \n        (\n            (current-cycle (contract-call? .stableswap-stx-ststx-v-1-2 get-current-cycle))\n            (current-cycle-helper (var-set helper-uint current-cycle))\n            (current-staker-data (unwrap! (map-get? StakerDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), user: tx-sender}) (err \"err-no-staker-data\")))\n            (current-cycles-staked (get cycles-staked current-staker-data))\n            (rewards-to-claim (fold fold-from-all-cycles-to-cycles-unclaimed current-cycles-staked {y-token: (contract-of y-token), lp-token: (contract-of lp-token), total-rewards-x: u0, current-cycle: current-cycle}))\n            (rewards-to-claim-x (get total-rewards-x rewards-to-claim))\n            (claimer tx-sender)\n        )\n\n        ;; Transfer rewards from the contract to the claimer\n        (if (> rewards-to-claim-x u0)\n            (unwrap! (as-contract (stx-transfer? rewards-to-claim-x tx-sender claimer)) (err \"err-x-token-transfer-failed\"))\n            false\n        )\n\n        ;; Return the number X tokens received after claiming all staking rewards\n        (ok {x-token-reward: rewards-to-claim-x})\n\n    )\n)\n\n;; Helper function to map from all cycles staked to all cycles unclaimed\n;; The below needs to be a fold, not a map, so that we don't have to transfer every iteration for rather at the end\n(define-private (fold-from-all-cycles-to-cycles-unclaimed (cycle uint) (fold-data {y-token: principal, lp-token: principal, total-rewards-x: uint, current-cycle: uint})) \n    (let \n        (\n            (static-current-cycle (get current-cycle fold-data))\n            (static-y-token (get y-token fold-data))\n            (static-lp-token (get lp-token fold-data))\n            (current-total-rewards-x (get total-rewards-x fold-data))\n            (param-cycle-staking-rewards (get-staking-rewards-at-cycle static-y-token static-lp-token cycle))\n            (param-cycle-rewards-x (match param-cycle-staking-rewards \n                ok-branch\n                    (get x-token-reward ok-branch)\n                err-branch\n                    u0\n            ))\n            ;; If the param-cycle is not in the past, then the rewards have to be zero.\n            (param-cycle-x-rewards (if (>= cycle static-current-cycle) u0 param-cycle-rewards-x))\n\n            (param-cycle-user-data (default-to {lp-token-staked: u0,reward-claimed: false, lp-token-to-unstake: u0} (map-get? StakerDataPerCycleMap {y-token: static-y-token, lp-token: static-lp-token, user: tx-sender, cycle: cycle})))\n        )\n\n        (if (> param-cycle-x-rewards u0)\n            ;; There are rewards to claim\n            (begin \n                ;; Update StakerDataPerCycleMap with reward-claimed = true\n                (map-set StakerDataPerCycleMap {y-token: static-y-token, lp-token: static-lp-token, user: tx-sender, cycle: cycle} (merge \n                    param-cycle-user-data\n                    {reward-claimed: true}\n                ))\n                {y-token: static-y-token, lp-token: static-lp-token, total-rewards-x: (+ current-total-rewards-x param-cycle-x-rewards), current-cycle: static-current-cycle}\n            )\n            ;; There are no rewards to claim\n            fold-data\n        )\n\n    )\n)\n\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Unstake Functions ;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(define-public (unstake-all-lp-tokens (y-token <sip-010-trait>) (lp-token <sip-010-trait>))\n    (let \n        (\n            (liquidity-provider tx-sender)\n            (current-cycle (contract-call? .stableswap-stx-ststx-v-1-2 get-current-cycle))\n            (current-cycle-helper (var-set helper-uint current-cycle))\n            (current-staker-data (unwrap! (map-get? StakerDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), user: tx-sender}) (err \"err-no-staker-data\")))\n            (current-cycles-to-unstake (get cycles-to-unstake current-staker-data))\n            (current-staked-by-unstaker (get total-currently-staked current-staker-data))\n            (total-currently-staked-data (unwrap! (map-get? TotalStakedPerPairMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-total-staked-per-pair\")))\n            (total-currently-staked-in-contract (get total-staked total-currently-staked-data))\n            (unstake-data (fold fold-from-all-cycles-to-unstakeable-cycles current-cycles-to-unstake {y-token: (contract-of y-token), lp-token: (contract-of lp-token), total-lps-to-unstake: u0, current-cycles-to-unstake: current-cycles-to-unstake}))\n            (lp-tokens-to-unstake (get total-lps-to-unstake unstake-data))\n            (updated-total-currently-staked (- total-currently-staked-in-contract lp-tokens-to-unstake))\n            (updated-total-currently-staked-by-unstaker (- current-staked-by-unstaker lp-tokens-to-unstake))\n            (updated-current-cycles-to-unstake (get current-cycles-to-unstake unstake-data))\n        )\n\n        (asserts! (> lp-tokens-to-unstake u0) (err \"err-no-lp-tokens-to-unstake\"))\n        \n        ;; Transfer LP tokens to unstake from the contract to the user\n        (unwrap! (as-contract (contract-call? lp-token transfer lp-tokens-to-unstake tx-sender liquidity-provider none)) (err \"err-failed-to-transfer-lp-tokens\"))\n        \n        (map-set StakerDataMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token), user: tx-sender} (merge \n            current-staker-data\n            {total-currently-staked: updated-total-currently-staked-by-unstaker, cycles-to-unstake: updated-current-cycles-to-unstake}\n        ))\n        ;; Updating the total balance of LP tokens staked in this contract\n        (map-set TotalStakedPerPairMap {y-token: (contract-of y-token), lp-token: (contract-of lp-token)} {total-staked: updated-total-currently-staked})\n\n        ;; Return the number of LP tokens user receives that were no longer staked in any current or upcoming cycles\n        (ok lp-tokens-to-unstake)\n\n    )\n)\n\n(define-private (fold-from-all-cycles-to-unstakeable-cycles (cycle uint) (fold-data {y-token: principal, lp-token: principal, total-lps-to-unstake: uint, current-cycles-to-unstake: (list 12000 uint)})) \n    (let \n        (\n            (current-cycle (contract-call? .stableswap-stx-ststx-v-1-2 get-current-cycle))\n            (current-total-lp-tokens-to-unstake (get total-lps-to-unstake fold-data))\n            (static-y-token (get y-token fold-data))\n            (static-lp-token (get lp-token fold-data))\n            (current-cycles-to-unstake (get current-cycles-to-unstake fold-data))\n            (param-cycle-user-data (match (map-get? StakerDataPerCycleMap {y-token: static-y-token, lp-token: static-lp-token, user: tx-sender, cycle: cycle}) \n                ;; StakerDataPerCycleMap entry exists, save it to param-cycle-user-data\n                unwrapped-value\n                    unwrapped-value\n                ;; StakerDataPerCycleMap entry doesn't exist (this should never happen)\n                {lp-token-staked: u0,\n                reward-claimed: false,\n                lp-token-to-unstake: u0}\n            ))\n            \n            (param-cycle-user-lp-tokens-to-unstake (get lp-token-to-unstake param-cycle-user-data))\n            (updated-helper-uint-to-filter (var-set helper-uint cycle))\n            (updated-cycles-to-unstake (filter filter-unstaked-cycle current-cycles-to-unstake))\n\n        )\n\n        (if (and (> param-cycle-user-lp-tokens-to-unstake u0) (<= cycle current-cycle))\n            ;; There are lp-tokens to unstake\n            (begin \n                ;; Update StakerDataPerCycleMap with lp-token-to-unstake = u0\n                (map-set StakerDataPerCycleMap {y-token: static-y-token, lp-token: static-lp-token, user: tx-sender, cycle: cycle} (merge \n                    param-cycle-user-data\n                    {lp-token-to-unstake: u0}\n                ))\n                {y-token: static-y-token, lp-token: static-lp-token, total-lps-to-unstake: (+ param-cycle-user-lp-tokens-to-unstake current-total-lp-tokens-to-unstake), current-cycles-to-unstake: updated-cycles-to-unstake}\n            )\n            ;; There are no rewards to claim\n            fold-data\n        )\n\n    )\n)\n",
    "analysis": {
      "summary": "This contract manages staking and unstaking of LP tokens, tracking staked amounts per cycle, and distributing rewards.",
      "explanation": "The contract provides a comprehensive solution for staking LP tokens, tracking the staked amounts over different cycles, and handling the distribution of rewards based on the staked amounts. It integrates with a liquidity pool and a rewards mechanism, ensuring users can stake their tokens, claim rewards, and unstake their tokens efficiently.\n\n1. Constants and Variables:\n- The contract uses a constant 'reward-cycle-index' <L18> to manage reward cycles, facilitating looping through cycles when claiming rewards.\n- Two helper variables, 'helper-uint' <L26> and 'helper-uint-list' <L29>, assist in filtering and mapping operations across cycles.\n- Maps like 'StakerDataMap' <L37> and 'StakerDataPerCycleMap' <L44> track staking data for users across different tokens and cycles.\n\n2. Functions:\n- 'get-user-data' <L64-66> and similar read-only functions provide data retrieval mechanisms for staking information.\n- 'stake-lp-tokens' <L118-198> allows users to stake LP tokens for specified cycles, handling token transfer and data tracking.\n- 'claim-cycle-staking-rewards' <L281-316> and 'claim-all-staking-rewards' <L321-343> enable users to claim their staking rewards for specific cycles or all cycles, respectively.\n- 'unstake-all-lp-tokens' <L392-426> permits users to unstake their LP tokens, adjusting the staked amounts accordingly.\n\nEach function incorporates safety checks (e.g., ensuring valid cycles and amounts) and interacts with external contracts for data (e.g., current cycle information) and token transfers.\n\nNotable Qualities:\n- The contract's design supports staking across multiple cycles, allowing for flexible staking strategies.\n- It includes detailed error handling and validation to ensure operations only proceed under valid conditions.\n- The use of helper variables and functions for filtering and mapping operations demonstrates advanced Clarity patterns for managing complex data structures.",
      "tags": ["staking", "rewards", "utility", "DeFi"]
    }
  },
  {
    "rank": 21,
    "contract": "SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-2",
    "calls": 2414,
    "source": "\n;; xyk-core-v-1-2\n\n;; Use XYK pool trait and SIP 010 trait\n(use-trait xyk-pool-trait .xyk-pool-trait-v-1-2.xyk-pool-trait)\n(use-trait sip-010-trait .sip-010-trait-ft-standard-v-1-1.sip-010-trait)\n\n;; Error constants\n(define-constant ERR_NOT_AUTHORIZED (err u1001))\n(define-constant ERR_INVALID_AMOUNT (err u1002))\n(define-constant ERR_INVALID_PRINCIPAL (err u1003))\n(define-constant ERR_ALREADY_ADMIN (err u1004))\n(define-constant ERR_ADMIN_LIMIT_REACHED (err u1005))\n(define-constant ERR_ADMIN_NOT_IN_LIST (err u1006))\n(define-constant ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER (err u1007))\n(define-constant ERR_NO_POOL_DATA (err u1008))\n(define-constant ERR_POOL_NOT_CREATED (err u1009))\n(define-constant ERR_POOL_DISABLED (err u1010))\n(define-constant ERR_POOL_ALREADY_CREATED (err u1011))\n(define-constant ERR_INVALID_POOL (err u1012))\n(define-constant ERR_INVALID_POOL_URI (err u1013))\n(define-constant ERR_INVALID_POOL_SYMBOL (err u1014))\n(define-constant ERR_INVALID_POOL_NAME (err u1015))\n(define-constant ERR_MATCHING_TOKEN_CONTRACTS (err u1016))\n(define-constant ERR_INVALID_X_TOKEN (err u1017))\n(define-constant ERR_INVALID_Y_TOKEN (err u1018))\n(define-constant ERR_MINIMUM_X_AMOUNT (err u1019))\n(define-constant ERR_MINIMUM_Y_AMOUNT (err u1020))\n(define-constant ERR_MINIMUM_LP_AMOUNT (err u1021))\n(define-constant ERR_INVALID_FEE (err u1022))\n(define-constant ERR_MINIMUM_BURN_AMOUNT (err u1023))\n(define-constant ERR_INVALID_MIN_BURNT_SHARES (err u1024))\n\n;; Contract deployer address\n(define-constant CONTRACT_DEPLOYER tx-sender)\n\n;; Maximum BPS\n(define-constant BPS u10000)\n\n;; Admins list and helper var used to remove admins\n(define-data-var admins (list 5 principal) (list tx-sender))\n(define-data-var admin-helper principal tx-sender)\n\n;; ID of last created pool\n(define-data-var last-pool-id uint u0)\n\n;; Minimum shares required to mint when creating a pool\n(define-data-var minimum-total-shares uint u10000)\n\n;; Minimum shares required to burn when creating a pool\n(define-data-var minimum-burnt-shares uint u1000)\n\n;; Data var used to enable or disable pool creation by anyone\n(define-data-var public-pool-creation bool false)\n\n;; Define pools map\n(define-map pools uint {\n    id: uint,\n    name: (string-ascii 32),\n    symbol: (string-ascii 32),\n    pool-contract: principal\n})\n\n;; Get admins list\n(define-read-only (get-admins)\n    (ok (var-get admins))\n)\n\n;; Get admin helper var\n(define-read-only (get-admin-helper)\n    (ok (var-get admin-helper))\n)\n\n;; Get ID of last created pool\n(define-read-only (get-last-pool-id)\n    (ok (var-get last-pool-id))\n)\n\n;; Get a pool by pool ID\n(define-read-only (get-pool-by-id (id uint))\n    (ok (map-get? pools id))\n)\n\n;; Get minimum shares required to mint when creating a pool\n(define-read-only (get-minimum-total-shares)\n    (ok (var-get minimum-total-shares))\n)\n\n;; Get minimum shares required to burn when creating a pool\n(define-read-only (get-minimum-burnt-shares)\n    (ok (var-get minimum-burnt-shares))\n)\n\n;; Get public pool creation status\n(define-read-only (get-public-pool-creation)\n    (ok (var-get public-pool-creation))\n)\n\n;; Get DY\n(define-public (get-dy\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (x-amount uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (protocol-fee (get x-protocol-fee pool-data))\n    (provider-fee (get x-provider-fee pool-data))\n    \n    ;; Calculate fees and perform AMM calculations\n    (x-amount-fees-protocol (/ (* x-amount protocol-fee) BPS))\n    (x-amount-fees-provider (/ (* x-amount provider-fee) BPS))\n    (x-amount-fees-total (+ x-amount-fees-protocol x-amount-fees-provider))\n    (dx (- x-amount x-amount-fees-total))\n    (updated-x-balance (+ x-balance dx))\n    (dy (/ (* y-balance dx) updated-x-balance))\n    )\n    (begin\n        ;; Assert that pool-status is true and correct token traits are used\n        (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n        (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n        (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n        \n        ;; Assert that x-amount is greater than 0\n        (asserts! (> x-amount u0) ERR_INVALID_AMOUNT)\n\n        ;; Return number of y tokens the caller would receive\n        (ok dy)\n    )\n    )\n)\n\n;; Get DX\n(define-public (get-dx\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (y-amount uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (protocol-fee (get x-protocol-fee pool-data))\n    (provider-fee (get x-provider-fee pool-data))\n\n    ;; Calculate fees and perform AMM calculations\n    (y-amount-fees-protocol (/ (* y-amount protocol-fee) BPS))\n    (y-amount-fees-provider (/ (* y-amount provider-fee) BPS))\n    (y-amount-fees-total (+ y-amount-fees-protocol y-amount-fees-provider))\n    (dy (- y-amount y-amount-fees-total))\n    (updated-y-balance (+ y-balance dy))\n    (dx (/ (* x-balance dy) updated-y-balance))\n    )\n    (begin\n        ;; Assert that pool-status is true and correct token traits are used\n        (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n        (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n        (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n\n        ;; Assert that y-amount is greater than 0\n        (asserts! (> y-amount u0) ERR_INVALID_AMOUNT)\n\n        ;; Return number of x tokens the caller would receive\n        (ok dx)\n    )\n    )\n)\n\n;; Get DLP\n(define-public (get-dlp\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (x-amount uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (pool-contract (contract-of pool-trait))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (total-shares (get total-shares pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n\n    ;; Calculate y-amount, pool balances, and dlp\n    (y-amount (/ (* x-amount y-balance) x-balance))\n    (updated-x-balance (+ x-balance x-amount))\n    (updated-y-balance (+ y-balance y-amount))\n    (dlp (/ (* x-amount total-shares) x-balance))\n    )\n    (begin\n        ;; Assert that pool-status is true and correct token traits are used\n        (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n        (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n        (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n\n        ;; Assert that x-amount and y-amount are greater than 0\n        (asserts! (> x-amount u0) ERR_INVALID_AMOUNT)\n        (asserts! (> y-amount u0) ERR_MINIMUM_Y_AMOUNT)\n\n        ;; Return number of LP tokens caller would receive and y-amount they would transfer\n        (ok {dlp: dlp, y-amount: y-amount})\n    )\n    )\n)\n\n;; Set minimum shares required to mint and burn when creating a pool\n(define-public (set-minimum-shares (min-total uint) (min-burnt uint))\n    (let (\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and amounts are greater than 0\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (and (> min-total u0) (> min-burnt u0)) ERR_INVALID_AMOUNT)\n        \n        ;; Assert that min-total is greater than min-burnt\n        (asserts! (> min-total min-burnt) ERR_INVALID_MIN_BURNT_SHARES)\n\n        ;; Update minimum-total-shares and minimum-burnt-shares\n        (var-set minimum-total-shares min-total)\n        (var-set minimum-burnt-shares min-burnt)\n\n        ;; Print function data and return true\n        (print {\n        action: \"set-minimum-shares\",\n        caller: caller,\n        data: {\n            min-total: min-total,\n            min-burnt: min-burnt\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Enable or disable public pool creation\n(define-public (set-public-pool-creation (status bool))\n    (let (\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n\n        ;; Set public-pool-creation to status\n        (var-set public-pool-creation status)\n        \n        ;; Print function data and return true\n        (print {action: \"set-public-pool-creation\", caller: caller, data: {status: status}})\n        (ok true)\n    )\n    )\n)\n\n;; Set pool uri for a pool\n(define-public (set-pool-uri (pool-trait <xyk-pool-trait>) (uri (string-utf8 256)))\n    (let (\n    ;; Gather all pool data\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and pool is created and valid\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n        (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n        \n        ;; Assert that uri length is greater than 0\n        (asserts! (> (len uri) u0) ERR_INVALID_POOL_URI)\n        \n        ;; Set pool uri for pool\n        (try! (contract-call? pool-trait set-pool-uri uri))\n        \n        ;; Print function data and return true\n        (print {\n        action: \"set-pool-uri\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            uri: uri\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Set pool status for a pool\n(define-public (set-pool-status (pool-trait <xyk-pool-trait>) (status bool))\n    (let (\n    ;; Gather all pool data\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and pool is created and valid\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n        (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n        \n        ;; Set pool status for pool\n        (try! (contract-call? pool-trait set-pool-status status))\n        \n        ;; Print function data and return true\n        (print {\n        action: \"set-pool-status\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            status: status\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Set fee address for a pool\n(define-public (set-fee-address (pool-trait <xyk-pool-trait>) (address principal))\n    (let (\n    ;; Gather all pool data\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and pool is created and valid\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n        (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n        \n        ;; Assert that address is standard principal\n        (asserts! (is-standard address) ERR_INVALID_PRINCIPAL)\n        \n        ;; Set fee address for pool\n        (try! (contract-call? pool-trait set-fee-address address))\n        \n        ;; Print function data and return true\n        (print {\n        action: \"set-fee-address\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            address: address\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Set x fees for a pool\n(define-public (set-x-fees (pool-trait <xyk-pool-trait>) (protocol-fee uint) (provider-fee uint))\n    (let (\n    ;; Gather all pool data\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and pool is created and valid\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n        (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n        \n        ;; Assert protocol-fee and provider-fee is less than maximum BPS\n        (asserts! (< (+ protocol-fee provider-fee) BPS) ERR_INVALID_FEE)\n        \n        ;; Set x fees for pool\n        (try! (contract-call? pool-trait set-x-fees protocol-fee provider-fee))\n        \n        ;; Print function data and return true\n        (print {\n        action: \"set-x-fees\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            protocol-fee: protocol-fee,\n            provider-fee: provider-fee\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Set y fees for a pool\n(define-public (set-y-fees (pool-trait <xyk-pool-trait>) (protocol-fee uint) (provider-fee uint))\n    (let (\n    ;; Gather all pool data\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and pool is created and valid\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n        (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n        \n        ;; Assert protocol-fee and provider-fee is less than maximum BPS\n        (asserts! (< (+ protocol-fee provider-fee) BPS) ERR_INVALID_FEE)\n        \n        ;; Set y fees for pool\n        (try! (contract-call? pool-trait set-y-fees protocol-fee provider-fee))\n        \n        ;; Print function data and return true\n        (print {\n        action: \"set-y-fees\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            protocol-fee: protocol-fee,\n            provider-fee: provider-fee\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Create a new pool\n(define-public (create-pool \n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (x-amount uint) (y-amount uint)\n    (burn-amount uint)\n    (x-protocol-fee uint) (x-provider-fee uint)\n    (y-protocol-fee uint) (y-provider-fee uint)\n    (fee-address principal) (uri (string-utf8 256)) (status bool)\n    )\n    (let (\n    ;; Gather all pool data and pool contract\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-contract (contract-of pool-trait))\n    \n    ;; Get pool ID and create pool symbol and name \n    (new-pool-id (+ (var-get last-pool-id) u1))\n    (symbol (unwrap! (create-symbol x-token-trait y-token-trait) ERR_INVALID_POOL_SYMBOL))\n    (name (concat symbol \"-LP\"))\n    (x-token-contract (contract-of x-token-trait))\n    (y-token-contract (contract-of y-token-trait))\n\n    ;; Calculate total shares\n    (total-shares (sqrti (* x-amount y-amount)))\n    (min-burnt-shares (var-get minimum-burnt-shares))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert that caller is an admin or public-pool-creation is true\n        (asserts! (or (is-some (index-of (var-get admins) caller)) (var-get public-pool-creation)) ERR_NOT_AUTHORIZED)\n        \n        ;; Assert that pool is not created\n        (asserts! (is-eq (get pool-created pool-data) false) ERR_POOL_ALREADY_CREATED)\n\n        ;; Assert that x-token-contract and y-token-contract are not matching\n        (asserts! (not (is-eq x-token-contract y-token-contract)) ERR_MATCHING_TOKEN_CONTRACTS)\n\n        ;; Assert that addresses are standard principals\n        (asserts! (is-standard x-token-contract) ERR_INVALID_PRINCIPAL)\n        (asserts! (is-standard y-token-contract) ERR_INVALID_PRINCIPAL)\n        (asserts! (is-standard fee-address) ERR_INVALID_PRINCIPAL)\n\n        ;; Assert that x and y amount is greater than 0\n        (asserts! (and (> x-amount u0) (> y-amount u0)) ERR_INVALID_AMOUNT)\n\n        ;; Assert that total shares minted meets minimum total shares required\n        (asserts! (>= total-shares (var-get minimum-total-shares)) ERR_MINIMUM_LP_AMOUNT)\n\n        ;; Assert that burn amount meets minimum shares required to burn\n        (asserts! (>= burn-amount min-burnt-shares) ERR_MINIMUM_BURN_AMOUNT)\n\n        ;; Assert that total shares is greater than or equal to 0 after subtracting burn amount\n        (asserts! (>= (- total-shares burn-amount) u0) ERR_MINIMUM_LP_AMOUNT)\n\n        ;; Assert that length of pool uri, symbol, and name is greater than 0\n        (asserts! (> (len uri) u0) ERR_INVALID_POOL_URI)\n        (asserts! (> (len symbol) u0) ERR_INVALID_POOL_SYMBOL)\n        (asserts! (> (len name) u0) ERR_INVALID_POOL_NAME)\n\n        ;; Assert that fees are less than maximum BPS\n        (asserts! (< (+ x-protocol-fee x-provider-fee) BPS) ERR_INVALID_FEE)\n        (asserts! (< (+ y-protocol-fee y-provider-fee) BPS) ERR_INVALID_FEE)\n\n        ;; Create pool and set fees\n        (try! (contract-call? pool-trait create-pool x-token-contract y-token-contract fee-address caller new-pool-id name symbol uri status))\n        (try! (contract-call? pool-trait set-x-fees x-protocol-fee x-provider-fee))\n        (try! (contract-call? pool-trait set-y-fees y-protocol-fee y-provider-fee))\n\n        ;; Update ID of last created pool and add pool to pools map\n        (var-set last-pool-id new-pool-id)\n        (map-set pools new-pool-id {id: new-pool-id, name: name, symbol: symbol, pool-contract: pool-contract})\n        \n        ;; Transfer x-amount x tokens and y-amount y tokens from caller to pool-contract\n        (try! (contract-call? x-token-trait transfer x-amount caller pool-contract none))\n        (try! (contract-call? y-token-trait transfer y-amount caller pool-contract none))\n\n        ;; Update pool balances\n        (try! (contract-call? pool-trait update-pool-balances x-amount y-amount))\n\n        ;; Mint LP tokens to caller \n        (try! (contract-call? pool-trait pool-mint (- total-shares burn-amount) caller))\n\n        ;; Mint burn amount LP tokens to pool-contract\n        (try! (contract-call? pool-trait pool-mint burn-amount pool-contract))\n\n        ;; Print create pool data and return true\n        (print {\n        action: \"create-pool\",\n        caller: caller,\n        data: {\n            pool-id: new-pool-id,\n            pool-name: name,\n            pool-contract: pool-contract,\n            x-token: x-token-contract,\n            y-token: y-token-contract,\n            x-protocol-fee: x-protocol-fee,\n            x-provider-fee: x-provider-fee,\n            y-protocol-fee: y-protocol-fee,\n            y-provider-fee: y-provider-fee,\n            x-amount: x-amount,\n            y-amount: y-amount,\n            burn-amount: burn-amount,\n            total-shares: total-shares,\n            pool-symbol: symbol,\n            pool-uri: uri,\n            pool-status: status,\n            creation-height: burn-block-height,\n            fee-address: fee-address\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Swap x token for y token via a pool\n(define-public (swap-x-for-y\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (x-amount uint) (min-dy uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (pool-contract (contract-of pool-trait))\n    (fee-address (get fee-address pool-data))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (protocol-fee (get x-protocol-fee pool-data))\n    (provider-fee (get x-provider-fee pool-data))\n    \n    ;; Calculate fees and perform AMM calculations\n    (x-amount-fees-protocol (/ (* x-amount protocol-fee) BPS))\n    (x-amount-fees-provider (/ (* x-amount provider-fee) BPS))\n    (x-amount-fees-total (+ x-amount-fees-protocol x-amount-fees-provider))\n    (dx (- x-amount x-amount-fees-total))\n    (updated-x-balance (+ x-balance dx))\n    (dy (/ (* y-balance dx) updated-x-balance))\n    (updated-y-balance (- y-balance dy))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert that pool-status is true and correct token traits are used\n        (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n        (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n        (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n        \n        ;; Assert that x-amount is greater than 0\n        (asserts! (> x-amount u0) ERR_INVALID_AMOUNT)\n\n        ;; Assert that min-dy is greater than 0 and dy is greater than or equal to min-dy\n        (asserts! (> min-dy u0) ERR_INVALID_AMOUNT)\n        (asserts! (>= dy min-dy) ERR_MINIMUM_Y_AMOUNT)\n        \n        ;; Transfer dx + x-amount-fees-provider x tokens from caller to pool-contract\n        (try! (contract-call? x-token-trait transfer (+ dx x-amount-fees-provider) caller pool-contract none))\n        \n        ;; Transfer dy y tokens from pool-contract to caller\n        (try! (contract-call? pool-trait pool-transfer y-token-trait dy caller))\n        \n        ;; Transfer x-amount-fees-protocol x tokens from caller to fee-address\n        (if (> x-amount-fees-protocol u0)\n        (try! (contract-call? x-token-trait transfer x-amount-fees-protocol caller fee-address none))\n        false\n        )\n\n        ;; Update pool balances\n        (try! (contract-call? pool-trait update-pool-balances (+ updated-x-balance x-amount-fees-provider) updated-y-balance))\n        \n        ;; Print swap data and return number of y tokens the caller received\n        (print {\n        action: \"swap-x-for-y\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: pool-contract,\n            x-token: x-token,\n            y-token: y-token,\n            x-amount: x-amount,\n            x-amount-fees-protocol: x-amount-fees-protocol,\n            x-amount-fees-provider: x-amount-fees-provider,\n            dy: dy,\n            min-dy: min-dy\n        }\n        })\n        (ok dy)\n    )\n    )\n)\n\n;; Swap y token for x token via a pool\n(define-public (swap-y-for-x\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (y-amount uint) (min-dx uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (pool-contract (contract-of pool-trait))\n    (fee-address (get fee-address pool-data))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (protocol-fee (get y-protocol-fee pool-data))\n    (provider-fee (get y-provider-fee pool-data))\n\n    ;; Calculate fees and perform AMM calculations\n    (y-amount-fees-protocol (/ (* y-amount protocol-fee) BPS))\n    (y-amount-fees-provider (/ (* y-amount provider-fee) BPS))\n    (y-amount-fees-total (+ y-amount-fees-protocol y-amount-fees-provider))\n    (dy (- y-amount y-amount-fees-total))\n    (updated-y-balance (+ y-balance dy))\n    (dx (/ (* x-balance dy) updated-y-balance))\n    (updated-x-balance (- x-balance dx))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert that pool-status is true and correct token traits are used\n        (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n        (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n        (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n\n        ;; Assert that y-amount is greater than 0\n        (asserts! (> y-amount u0) ERR_INVALID_AMOUNT)\n\n        ;; Assert that min-dx is greater than 0 and dx is greater than or equal to min-dx\n        (asserts! (> min-dx u0) ERR_INVALID_AMOUNT)\n        (asserts! (>= dx min-dx) ERR_MINIMUM_X_AMOUNT)\n\n        ;; Transfer dy + y-amount-fees-provider y tokens from caller to pool-contract\n        (try! (contract-call? y-token-trait transfer (+ dy y-amount-fees-provider) caller pool-contract none))\n        \n        ;; Transfer dx x tokens from pool-contract to caller \n        (try! (contract-call? pool-trait pool-transfer x-token-trait dx caller))\n        \n        ;; Transfer y-amount-fees-protocol y tokens from caller to fee-address\n        (if (> y-amount-fees-protocol u0)\n        (try! (contract-call? y-token-trait transfer y-amount-fees-protocol caller fee-address none))\n        false\n        )\n\n        ;; Update pool balances\n        (try! (contract-call? pool-trait update-pool-balances updated-x-balance (+ updated-y-balance y-amount-fees-provider)))\n        \n        ;; Print swap data and return number of x tokens the caller received\n        (print {\n        action: \"swap-y-for-x\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: pool-contract,\n            x-token: x-token,\n            y-token: y-token,\n            y-amount: y-amount,\n            y-amount-fees-protocol: y-amount-fees-protocol,\n            y-amount-fees-provider: y-amount-fees-provider,\n            dx: dx,\n            min-dx: min-dx\n        }\n        })\n        (ok dx)\n    )\n    )\n)\n\n;; Add liquidity to a pool\n(define-public (add-liquidity\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (x-amount uint) (min-dlp uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (pool-contract (contract-of pool-trait))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (total-shares (get total-shares pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n\n    ;; Calculate y-amount, pool balances, and dlp\n    (y-amount (/ (* x-amount y-balance) x-balance))\n    (updated-x-balance (+ x-balance x-amount))\n    (updated-y-balance (+ y-balance y-amount))\n    (dlp (/ (* x-amount total-shares) x-balance))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert that pool-status is true and correct token traits are used\n        (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n        (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n        (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n\n        ;; Assert that x-amount and y-amount are greater than 0\n        (asserts! (> x-amount u0) ERR_INVALID_AMOUNT)\n        (asserts! (> y-amount u0) ERR_MINIMUM_Y_AMOUNT)\n\n        ;; Assert that min-dlp is greater than 0 and dlp is greater than or equal to min-dlp\n        (asserts! (> min-dlp u0) ERR_INVALID_AMOUNT)\n        (asserts! (>= dlp min-dlp) ERR_MINIMUM_LP_AMOUNT)\n\n        ;; Transfer x-amount x tokens from caller to pool-contract\n        (try! (contract-call? x-token-trait transfer x-amount caller pool-contract none))\n        \n        ;; Transfer y-amount y tokens from caller to pool-contract\n        (try! (contract-call? y-token-trait transfer y-amount caller pool-contract none))\n        \n        ;; Update pool balances\n        (try! (contract-call? pool-trait update-pool-balances updated-x-balance updated-y-balance))\n        \n        ;; Mint LP tokens to caller\n        (try! (contract-call? pool-trait pool-mint dlp caller))\n\n        ;; Print add liquidity data and return number of LP tokens caller received\n        (print {\n        action: \"add-liquidity\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: pool-contract,\n            x-token: x-token,\n            y-token: y-token,\n            x-amount: x-amount,\n            y-amount: y-amount,\n            dlp: dlp,\n            min-dlp: min-dlp\n        }\n        })\n        (ok dlp)\n    )\n    )\n)\n\n;; Withdraw liquidity from a pool\n(define-public (withdraw-liquidity\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (amount uint) (min-x-amount uint) (min-y-amount uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (total-shares (get total-shares pool-data))\n\n    ;; Calculate x-amount and y-amount to transfer and updated balances\n    (x-amount (/ (* amount x-balance) total-shares))\n    (y-amount (/ (* amount y-balance) total-shares))\n    (updated-x-balance (- x-balance x-amount))\n    (updated-y-balance (- y-balance y-amount))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert that correct token traits are used\n        (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n        (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n\n        ;; Assert that amount is greater than 0\n        (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n\n        ;; Assert that x-amount + y-amount is greater than 0\n        (asserts! (> (+ x-amount y-amount) u0) ERR_INVALID_AMOUNT)\n\n        ;; Assert that x-amount is greater than or equal to min-x-amount\n        (asserts! (>= x-amount min-x-amount) ERR_MINIMUM_X_AMOUNT)\n\n        ;; Assert that y-amount is greater than or equal to min-y-amount\n        (asserts! (>= y-amount min-y-amount) ERR_MINIMUM_Y_AMOUNT)\n\n        ;; Transfer x-amount x tokens from pool-contract to caller\n        (if (> x-amount u0)\n        (try! (contract-call? pool-trait pool-transfer x-token-trait x-amount caller))\n        false\n        )\n\n        ;; Transfer y-amount y tokens from pool-contract to caller\n        (if (> y-amount u0)\n        (try! (contract-call? pool-trait pool-transfer y-token-trait y-amount caller))\n        false\n        )\n\n        ;; Update pool balances\n        (try! (contract-call? pool-trait update-pool-balances updated-x-balance updated-y-balance))\n\n        ;; Burn LP tokens from caller\n        (try! (contract-call? pool-trait pool-burn amount caller))\n\n        ;; Print withdraw liquidity data and return number of x and y tokens caller received\n        (print {\n        action: \"withdraw-liquidity\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            x-token: x-token,\n            y-token: y-token,\n            amount: amount,\n            x-amount: x-amount,\n            y-amount: y-amount,\n            min-x-amount: min-x-amount,\n            min-y-amount: min-y-amount\n        }\n        })\n        (ok {x-amount: x-amount, y-amount: y-amount})\n    )\n    )\n)\n\n;; Add an admin to the admins list\n(define-public (add-admin (admin principal))\n    (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n    )\n    ;; Assert caller is an existing admin and new admin is not in admins-list\n    (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n    (asserts! (is-none (index-of admins-list admin)) ERR_ALREADY_ADMIN)\n    \n    ;; Add admin to list with max length of 5\n    (var-set admins (unwrap! (as-max-len? (append admins-list admin) u5) ERR_ADMIN_LIMIT_REACHED))\n    \n    ;; Print add admin data and return true\n    (print {action: \"add-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n    )\n)\n\n;; Remove an admin from the admins list\n(define-public (remove-admin (admin principal))\n    (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n    )\n    ;; Assert caller is an existing admin and admin to remove is in admins-list\n    (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n    (asserts! (is-some (index-of admins-list admin)) ERR_ADMIN_NOT_IN_LIST)\n\n    ;; Assert contract deployer cannot be removed\n    (asserts! (not (is-eq admin CONTRACT_DEPLOYER)) ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER)\n\n    ;; Set admin-helper to admin to remove and filter admins-list to remove admin\n    (var-set admin-helper admin)\n    (var-set admins (filter admin-not-removable admins-list))\n\n    ;; Print remove admin data and return true\n    (print {action: \"remove-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n    )\n)\n\n;; Set pool uri for multiple pools\n(define-public (set-pool-uri-multi\n    (pool-traits (list 120 <xyk-pool-trait>))\n    (uris (list 120 (string-utf8 256)))\n    )\n    (ok (map set-pool-uri pool-traits uris))\n)\n\n;; Set pool status for multiple pools\n(define-public (set-pool-status-multi\n    (pool-traits (list 120 <xyk-pool-trait>))\n    (statuses (list 120 bool))\n    )\n    (ok (map set-pool-status pool-traits statuses))\n)\n\n;; Set fee address for multiple pools\n(define-public (set-fee-address-multi\n    (pool-traits (list 120 <xyk-pool-trait>))\n    (addresses (list 120 principal))\n    )\n    (ok (map set-fee-address pool-traits addresses))\n)\n\n;; Set x fees for multiple pools\n(define-public (set-x-fees-multi\n    (pool-traits (list 120 <xyk-pool-trait>))\n    (protocol-fees (list 120 uint)) (provider-fees (list 120 uint))\n    )\n    (ok (map set-x-fees pool-traits protocol-fees provider-fees))\n)\n\n;; Set y fees for multiple pools\n(define-public (set-y-fees-multi\n    (pool-traits (list 120 <xyk-pool-trait>))\n    (protocol-fees (list 120 uint)) (provider-fees (list 120 uint))\n    )\n    (ok (map set-y-fees pool-traits protocol-fees provider-fees))\n)\n\n;; Helper function for removing an admin\n(define-private (admin-not-removable (admin principal))\n    (not (is-eq admin (var-get admin-helper)))\n)\n\n;; Create pool symbol using x token and y token symbols\n(define-private (create-symbol (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>))\n    (let (\n    ;; Get x token and y token symbols\n    (x-symbol (unwrap-panic (contract-call? x-token-trait get-symbol)))\n    (y-symbol (unwrap-panic (contract-call? y-token-trait get-symbol)))\n    \n    ;; Truncate symbols if length exceeds 14\n    (x-truncated \n        (if (> (len x-symbol) u14)\n        (unwrap-panic (slice? x-symbol u0 u14))\n        x-symbol\n        )\n    )\n    (y-truncated\n        (if (> (len y-symbol) u14)\n        (unwrap-panic (slice? y-symbol u0 u14))\n        y-symbol\n        )\n    )\n    )\n    ;; Return pool symbol with max length of 29\n    (as-max-len? (concat x-truncated (concat \"-\" y-truncated)) u29)\n    )\n)\n\n;; Check if a pool is valid\n(define-private (is-valid-pool (id uint) (contract principal))\n    (let (\n    (pool-data (unwrap! (map-get? pools id) false))\n    )\n    (is-eq contract (get pool-contract pool-data))\n    )\n)",
    "analysis": {
      "summary": "This contract manages liquidity pools for an XYK Automated Market Maker (AMM), allowing users to create pools, add liquidity, swap tokens, and manage pool parameters.",
      "explanation": "The contract starts by importing necessary traits for XYK pools and SIP-010 fungible tokens <L5-6>. It defines a series of error constants for various failure modes <L8-33>. The contract deployer is set as a constant, alongside other constants like BPS (basis points) for fee calculations <L34-38>. It maintains a list of administrators, pool IDs, and minimum share requirements for pool operations <L40-54>. The contract allows querying of various state variables <L64-97>, and defines core functionalities such as calculating swap amounts <L99-137>, creating pools <L442-555>, swapping tokens <L557-634>, adding and withdrawing liquidity <L715-864>, and administrative functions to manage pool parameters and administrators <L866-906>. Each function includes checks for authorization, input validation, and state consistency to ensure secure operations. Notably, the contract supports multi-operation updates for efficiency <L908-946>. It utilizes private helper functions for internal logic, like symbol creation and admin management <L949-986>.",
      "tags": ["DeFi", "DEX", "liquidity-pool", "AMM"],
      "notable_qualities": [
        "Supports creation and management of multiple liquidity pools.",
        "Implements XYK AMM model for token swaps with fee collection.",
        "Allows dynamic addition/removal of administrators.",
        "Enables public or admin-only pool creation based on contract state.",
        "Includes multi-operation functions for batch updates.",
        "Utilizes SIP-010 standard for fungible token interactions.",
        "Performs comprehensive input and state validation for security."
      ]
    }
  },
  {
    "rank": 22,
    "contract": "SP3SF2T474DXYEJ540GB27CZP3FG7FJ83X9RY4WF6.amm-pool-v2-02",
    "calls": 2128,
    "source": "(use-trait nma 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.trait-sip-010.sip-010-trait)\n(use-trait nmb 'SP2AKWJYC7BNY18W1XXKPGP0YVEK63QJG4793Z2D4.sip-010-trait-ft-standard.sip-010-trait)\n(use-trait nmc 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.dao-traits-v4.sip010-ft-trait)\n(use-trait share-fee-to-trait 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to-trait.share-fee-to-trait)\n(use-trait share-fee-to-trait-c 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.dao-traits-v4.share-fee-to-trait)\n(define-public (swap-helper-a (i <nma>) (iii <nma>) (ii uint) (l uint) (ll uint) (id uint) (ill <nmb>) (j <nmb>) (jj <nmb>) (jlj <nmb>) (lil uint) (share-fee-to <share-fee-to-trait>) (nn uint)) (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens id ill j jj jlj share-fee-to (/ (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper i iii ll ii (some l)) ) nn) lil) )\n(define-public (swap-helper-b (i <nma>)  (iii <nma>)  (l uint)  (ll uint) (id uint) (ill <nmb>) (j <nmb>) (jj <nmb>) (jlj <nmb>) (li uint) (lil uint) (share-fee-to <share-fee-to-trait>) (nn uint)) (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper i iii ll (* (get amt-out (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens id ill j jj jlj share-fee-to li lil))) nn) (some l)) )\n(define-public (swap-helper-c (i <nma>) (iii <nma>) (ii uint) (l uint) (ll uint) (mm <nmc>) (mmm <nmc>) (m <nmc>) (lil uint) (share-fee-to <share-fee-to-trait-c>) (nn uint)) (contract-call? 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.univ2-path2 swap-3 (/ (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper i iii ll ii (some l)) ) nn) lil mm mmm m share-fee-to ))\n(define-public (swap-helper-d (i <nma>)  (iii <nma>)  (l uint)  (ll uint) (mm <nmc>) (mmm <nmc>) (m <nmc>) (li uint) (lil uint) (share-fee-to <share-fee-to-trait-c>) (nn uint)) (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper i iii ll (* (get amt-out (get c (try! (contract-call? 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.univ2-path2 swap-3 li lil mm mmm m share-fee-to) ))) nn) (some l)) )\n(define-public (swap-helper-e (mm <nmc>) (mmm <nmc>) (m <nmc>) (il uint) (nnn uint) (share-fee-to-c <share-fee-to-trait-c>) (id uint) (ill <nmb>) (j <nmb>) (jj <nmb>) (jlj <nmb>) (lil uint) (share-fee-to <share-fee-to-trait>) (nn uint)) (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens id ill j jj jlj share-fee-to (* (get amt-out (get c (try! (contract-call? 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.univ2-path2 swap-3 il nnn mm mmm m share-fee-to-c ))) ) nn) lil ))\n(define-public (swap-helper-f (mm <nmc>) (mmm <nmc>) (m <nmc>) (nnn uint) (share-fee-to-c <share-fee-to-trait-c>) (id uint) (ill <nmb>) (j <nmb>) (jj <nmb>) (jlj <nmb>) (li uint) (lil uint) (share-fee-to <share-fee-to-trait>) (nn uint)) (contract-call? 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.univ2-path2 swap-3 (* (get amt-out (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens id ill j jj jlj share-fee-to li lil))) nn) nnn mm mmm m share-fee-to-c ))\n(define-public (swap-helper-g (t <nma>) (tt <nma>) (ttt <nma>) (ii uint) (l uint) (ll uint) (n uint) (id uint) (ill <nmb>) (j <nmb>) (jj <nmb>) (jlj <nmb>) (lil uint) (share-fee-to <share-fee-to-trait>) (nn uint)) (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens id ill j jj jlj share-fee-to (/ (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper-a t tt ttt ll n ii (some l)) ) nn) lil) )\n(define-public (swap-helper-h (t <nma>) (tt <nma>) (ttt <nma>) (l uint) (ll uint) (n uint) (id uint) (ill <nmb>) (j <nmb>) (jj <nmb>) (jlj <nmb>) (li uint) (lil uint) (share-fee-to <share-fee-to-trait>) (nn uint)) (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper-a t tt ttt ll n (* (get amt-out (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens id ill j jj jlj share-fee-to li lil))) nn) (some l)) )\n(define-public (joker (mm <nma>) (mmm <nma>) (ll uint) (ii uint) (min-dy uint) (id uint) (ill <nmb>) (j <nmb>) (jj <nmb>) (jlj <nmb>) (li uint) (lil uint) (share-fee-to <share-fee-to-trait>) ) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper mm mmm ll ii (some min-dy))) (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens id ill j jj jlj share-fee-to li lil) ))",
    "analysis": {
      "summary": "This contract facilitates complex swap operations across different tokens and liquidity pools on the Stacks blockchain.",
      "explanation": "This Clarity smart contract integrates with multiple decentralized finance (DeFi) protocols to perform token swaps. It leverages external contracts and traits for interoperability with different token standards and liquidity pool mechanisms. The contract's primary functionality is to enable users to swap tokens by interacting with automated market maker (AMM) pools and routing through optimal swap paths for efficiency and reduced slippage. Here's a breakdown of its components and functionalities:\n\n1. **Trait Imports (<L1-5>)**: The contract uses multiple traits from external contracts to ensure compatibility with SIP-010 fungible token standards and specific functionalities like sharing fees. These traits allow the contract to interact with various token types and DeFi protocols securely.\n\n2. **Swap Helper Functions (<L6-13>)**: Each 'swap-helper' function is designed to interact with different configurations of tokens and pools. They facilitate the actual swap operations by calling external contracts (like AMM pools and routers) with specific parameters to execute the swaps. The parameters include token identifiers, amounts, and addresses for the tokens and pools involved in the swap. These functions handle the logic of calculating amounts, applying fees, and routing the swaps through the appropriate paths.\n\n   - The 'swap-helper-a' function <L6>, for example, calls an external router to swap exact amounts of tokens for another token set, adjusting the operation based on a calculated value from another contract call.\n\n   - 'swap-helper-b' through 'swap-helper-g' <L7-13> follow similar patterns but are tailored for different swap scenarios, such as swapping with different input and output parameters or using different liquidity pools.\n\n3. **Joker Function (<L14>)**: This function seems to be a utility or fallback mechanism for performing a swap operation with a safety check on the minimum desired output. It first attempts a swap operation and then proceeds to another swap through the router, ensuring that the operation only goes through if the initial conditions are met.\n\nEach function includes safety checks primarily through the use of the 'try!' macro, which ensures that if any called contract operation fails, the entire transaction is aborted. This is crucial for DeFi operations where atomicity (either all operations succeed or none do) is necessary to prevent loss of funds or manipulation.\n\nNotable qualities of this contract include its integration with multiple DeFi protocols and standards, the flexibility to handle various swap scenarios, and the emphasis on safety and atomicity of swap operations.",
      "tags": ["DeFi", "DEX", "swap", "utility"]
    }
  },
  {
    "rank": 23,
    "contract": "SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token",
    "calls": 2003,
    "source": "(define-constant ERR-UNAUTHORIZED u1)\n(define-constant ERR-YOU-POOR u2)\n(define-fungible-token welshcorgicoin)\n(define-data-var token-uri (optional (string-utf8 256)) none)\n(define-constant contract-creator tx-sender)\n(impl-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)\n\n;; SIP-010 Standard\n\n(define-public (transfer (amount uint) (from principal) (to principal) (memo (optional (buff 34))))\n    (begin\n        (asserts! (is-eq from tx-sender)\n            (err ERR-UNAUTHORIZED))\n\n        (ft-transfer? welshcorgicoin amount from to)\n    )\n)\n\n(define-read-only (get-name)\n    (ok \"Welshcorgicoin\")\n)\n\n(define-read-only (get-symbol)\n    (ok \"WELSH\")\n)\n\n(define-read-only (get-decimals)\n    (ok u6)\n)\n\n(define-read-only (get-balance (user principal))\n    (ok (ft-get-balance welshcorgicoin user)\n    )\n)\n\n(define-read-only (get-total-supply)\n    (ok (ft-get-supply welshcorgicoin)\n    )\n)\n\n(define-public (set-token-uri (value (string-utf8 256)))\n    (if \n        (is-eq tx-sender contract-creator) \n            (ok (var-set token-uri (some value))) \n        (err ERR-UNAUTHORIZED)\n    )\n)\n\n(define-read-only (get-token-uri)\n    (ok (var-get token-uri)\n    )\n)\n\n;; send-many\n\n(define-public (send-many (recipients (list 200 { to: principal, amount: uint, memo: (optional (buff 34)) })))\n  (fold check-err\n    (map send-token recipients)\n    (ok true)\n  )\n)\n\n(define-private (check-err (result (response bool uint)) (prior (response bool uint)))\n  (match prior ok-value result\n               err-value (err err-value)\n  )\n)\n\n(define-private (send-token (recipient { to: principal, amount: uint, memo: (optional (buff 34)) }))\n  (send-token-with-memo (get amount recipient) (get to recipient) (get memo recipient))\n)\n\n(define-private (send-token-with-memo (amount uint) (to principal) (memo (optional (buff 34))))\n  (let\n    ((transferOk (try! (transfer amount tx-sender to memo))))\n    (ok transferOk)\n  )\n)\n\n;; The Great $WELSH TGE / Total 10B\n\n(begin\n  (try! (ft-mint? welshcorgicoin u10000000000000000 contract-creator)) \n)                   ",
    "analysis": {
      "summary": "This contract introduces 'Welshcorgicoin', a fungible token with SIP-010 standard compliance, featuring basic token functionalities such as transfer, balance queries, and a unique token URI setter for the contract creator.",
      "explanation": "The contract is structured to implement a fungible token named Welshcorgicoin, following the SIP-010 standard for fungible tokens on the Stacks blockchain. It includes functionalities for transferring tokens, querying balances, total supply, token name, symbol, decimals, and setting a token URI by the contract creator. The contract also introduces a batch transfer feature, allowing multiple transfers in a single transaction.\n\n1. Constants and Data Variables:\n- `ERR-UNAUTHORIZED` <L1> and `ERR-YOU-POOR` <L2> are error codes for unauthorized actions and insufficient balance, respectively.\n- `welshcorgicoin` <L3> is the fungible token defined by this contract.\n- `token-uri` <L4> is a data variable that stores an optional URI for the token, settable only by the contract creator.\n- `contract-creator` <L5> stores the principal of the contract creator for reference in authorization checks.\n\n2. Functions:\n- `transfer` <L10-17> allows the transfer of tokens from one account to another, ensuring the sender is the transaction initiator.\n- `get-name`, `get-symbol`, `get-decimals` <L19-29> provide basic token information in compliance with the SIP-010 standard.\n- `get-balance` <L31-34> and `get-total-supply` <L36-39> allow querying the balance of a given account and the total token supply, respectively.\n- `set-token-uri` <L41-47> enables the contract creator to set a URI for the token, with an authorization check.\n- `get-token-uri` <L49-52> allows querying the set token URI.\n- `send-many` <L56-61> introduces a batch transfer feature, enabling multiple token transfers in a single call.\n- `check-err`, `send-token`, and `send-token-with-memo` <L63-78> are helper functions facilitating the batch transfer logic, with `send-token-with-memo` leveraging the `transfer` function for each transfer.\n\n3. Initial Token Generation Event (TGE) <L82-84> mints a total of 10 billion Welshcorgicoin tokens to the contract creator at contract deployment.\n\nNotable Qualities:\n- Implements SIP-010 standard, ensuring compatibility with the broader Stacks ecosystem.\n- Includes a unique feature for setting a token URI, typically seen in NFT contracts, applied here to a fungible token.\n- The `send-many` function introduces efficiency in transactions by allowing batch transfers.",
      "tags": ["fungible-token", "SIP-010", "utility", "protocol"]
    }
  },
  {
    "rank": 24,
    "contract": "SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.wrapper-velar-v-1-1",
    "calls": 1970,
    "source": "(use-trait ft-trait 'SP2AKWJYC7BNY18W1XXKPGP0YVEK63QJG4793Z2D4.sip-010-trait-ft-standard.sip-010-trait)\n(use-trait share-fee-to-trait 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to-trait.share-fee-to-trait)\n\n(define-public (swap-helper-a (id uint) (token0 <ft-trait>) (token1 <ft-trait>) (token-in <ft-trait>) (token-out <ft-trait>) (share-fee-to <share-fee-to-trait>) (amt-in uint) (amt-out-min uint))\n  (let (\n    (call (try! (contract-call?\n          'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens\n          id\n          token0 token1\n          token-in token-out\n          share-fee-to\n          amt-in amt-out-min)))\n  )\n    (ok call)\n  )\n)\n\n(define-public (swap-helper-b (id uint) (token0 <ft-trait>) (token1 <ft-trait>) (token-in <ft-trait>) (token-out <ft-trait>) (share-fee-to <share-fee-to-trait>) (amt-in-max uint) (amt-out uint))\n  (let (\n    (call (try! (contract-call?\n          'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-tokens-for-exact-tokens\n          id\n          token0 token1\n          token-in token-out\n          share-fee-to\n          amt-in-max amt-out)))\n  )\n    (ok call)\n  )\n)",
    "analysis": {
      "summary": "This contract provides helper functions for swapping tokens on a decentralized exchange (DEX) platform, facilitating exact amount swaps and swaps with minimum output.",
      "explanation": "This Clarity smart contract is designed to interact with a decentralized exchange's router, specifically to conduct token swaps. It does not define any data variables or constants within the contract itself but relies on external contracts and traits for its functionality. The contract's primary purpose is to serve as an intermediary, simplifying the interaction with the DEX's swap functions by providing two helper functions tailored for different swap requirements. Each function calls an external contract's function to perform the swap, handling the complexities of token exchange within the DEX ecosystem. Let's break down the contract's functions in detail: 1. The contract does not declare any data variables or constants. It is entirely focused on functionality rather than state management. 2. 'swap-helper-a' function <L4-15>: - Purpose: To facilitate a token swap where the amount of input tokens is specified, and the minimum amount of output tokens is expected. It's used when the user knows how much they want to swap and the least amount they are willing to receive. - Parameters: -- 'id' <L4>: A unique identifier for the swap transaction. -- 'token0' and 'token1' <L4>: The token pair involved in the swap. -- 'token-in' and 'token-out' <L4>: Specifies which token is being swapped and which token is expected in return. -- 'share-fee-to' <L4>: An external contract that might receive a share of the swap fees. -- 'amt-in' <L4>: The exact amount of 'token-in' that the user wants to swap. -- 'amt-out-min' <L4>: The minimum amount of 'token-out' the user expects to receive. - Logic: Calls an external contract's 'swap-exact-tokens-for-tokens' function, passing all parameters through. It uses 'try!' to attempt the call, which will abort the transaction if the call fails. 3. 'swap-helper-b' function <L18-29>: - Purpose: To facilitate a token swap where the exact amount of output tokens is specified, and the maximum amount of input tokens is provided. This is useful when the user needs a specific amount of output tokens and is flexible on the amount of input tokens used. - Parameters: Similar to 'swap-helper-a', but with 'amt-in-max' and 'amt-out' to specify the maximum input and exact output amounts, respectively. - Logic: Similar to 'swap-helper-a', but calls the 'swap-tokens-for-exact-tokens' function of the external contract to achieve the desired swap dynamics. Both functions perform important safety checks implicitly by relying on the external contract's swap functions to validate the swap conditions, including the availability of liquidity, adherence to the specified minimum or maximum amounts, and the correctness of token addresses. They also ensure that any errors in the swap process are caught and handled gracefully, aborting the transaction to prevent loss of funds or unexpected outcomes. Notable Qualities: - Simplifies interactions with a complex DEX protocol by abstracting swap details. - Offers flexibility in swap types, catering to different user needs and market conditions. - Relies heavily on external contracts and traits, demonstrating Clarity's composability and inter-contract communication capabilities.",
      "tags": ["DEX", "utility", "protocol", "DeFi"]
    }
  },
  {
    "rank": 25,
    "contract": "SP1NAZ59R1ED0V6NH9N0EQBEB3MKT48CQCMKC5Q41.swap-router-v16",
    "calls": 1729,
    "source": "(use-trait et 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.extension-trait.extension-trait) (impl-trait 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.extension-trait.extension-trait) (define-constant E8 u100000000) (define-read-only (s2e (n uint)) (* n u100)) (define-public (i1 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5k0yl5ot8l (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u1)) (ok u0))) (define-public (o1 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5k0yl5ot8l in u1)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i2 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda u5000000 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o2 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda u5000000 (s2e (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (ok u0))) (define-public (i3 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender))) none)) (ok u0))) (define-public (o3 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e in) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i4 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnyc E8 (s2e in) none)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kielx1jn7 (unwrap-panic (contract-call? 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 get-balance tx-sender)) u1)) (ok u0))) (define-public (o4 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kielx1jn7 in u1)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnyc E8 (s2e (unwrap-panic (contract-call? 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 get-balance tx-sender))) none)) (ok u0))) (define-public (i5 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wdiko E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o5 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wdiko E8 (s2e (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (i6 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o6 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda E8 (s2e (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (i7 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token in u0)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kt9nmle8c (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u1)) (ok u0))) (define-public (o7 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kt9nmle8c in u1)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i8 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-stx-stsw in u1)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kbe3oqvac (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a get-balance tx-sender)) u1)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender))) none)) (ok u0))) (define-public (o8 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e in) none)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kbe3oqvac (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)) u1)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-stx-stsw (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a get-balance tx-sender)) u1)) (ok u0))) (define-public (i9 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u27 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender))) none)) (ok u0))) (define-public (o9 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e in) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u27 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)) u1 )) (ok u0))) (define-public (i10 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) none)) (ok u0))) (define-public (o10 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (s2e in) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i11 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o11 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token in u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i12 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u22 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u21 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token get-balance tx-sender)) u1 )) (ok u0))) (define-public (o12 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u21 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u22 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token get-balance tx-sender)) u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0))) (define-public (i13 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (unwrap-panic (contract-call? 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-usda-aeusdc-v-1-4 swap-y-for-x 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.usda-aeusdc-lp-token-v-1-4 (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o13 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (unwrap-panic (contract-call? 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-usda-aeusdc-v-1-2 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.usda-aeusdc-lp-token-v-1-2 (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0))) (define-public (i14 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u11 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wpepe E8 (* u100000 (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (o14 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wpepe E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u11 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz get-balance tx-sender)) u1 )) (ok u0))) (define-public (i15 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc u5000000 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) none)) (ok u0))) (define-public (o15 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc u5000000 (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc get-balance tx-sender)) none)) (ok u0))) (define-public (i16 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd u5000000 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt get-balance tx-sender)) none)) (ok u0))) (define-public (o16 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd u5000000 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (ok u0))) (define-public (i17 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wleo E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u28 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token get-balance tx-sender)) u1 )) (ok u0))) (define-public (o17 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u28 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wleo E8 (s2e (unwrap-panic (contract-call? 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (i18 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-waeusdc E8 (s2e (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender))) none)) (ok u0))) (define-public (o18 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-waeusdc E8 (s2e in) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0))) (define-public (i19 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-y-for-x 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1)) (ok u0))) (define-public (o19 (in uint)) (begin (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-x-for-y 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc in u1)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0))) (define-public (i20 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (s2e in) none)) (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.migrate-wrapped migrate)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt get-balance tx-sender)) none)) (ok u0))) (define-public (o20 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (s2e in) none)) (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.migrate-wrapped migrate)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc get-balance tx-sender)) none)) (ok u0))) (define-public (i21 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wgoat E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u36 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx get-balance tx-sender)) u1 )) (ok u0))) (define-public (o21 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u36 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wgoat E8 (s2e (unwrap-panic (contract-call? 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (callback (p principal) (bp (buff 2048))) (let ((enc (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? bp u0 u16)) u16)))) (bh (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? bp u16 u20)) u4)))) (addr (get hashbytes (unwrap-panic (element-at? (get addrs (unwrap-panic (get-burn-block-info? pox-addrs bh))) (mod enc u2))))) (di (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? addr u0 u4)) u4)))) (do (mod enc (+ di u4294967295))) (c (mod do u100)) (in (* do u100)) (ts (if (< c u30) (if (<= c u11) (list (if (is-eq c u1) (i1 in) (err u0)) (if (is-eq c u2) (i2 in) (err u0)) (if (is-eq c u3) (i3 in) (err u0)) (if (is-eq c u4) (i4 in) (err u0)) (if (is-eq c u5) (i5 in) (err u0)) (if (is-eq c u6) (i6 in) (err u0)) (if (is-eq c u7) (i7 in) (err u0)) (if (is-eq c u8) (i8 in) (err u0)) (if (is-eq c u9) (i9 in) (err u0)) (if (is-eq c u10) (i10 in) (err u0)) (if (is-eq c u11) (i11 in) (err u0))) (list (if (is-eq c u12) (i12 in) (err u0)) (if (is-eq c u13) (i13 in) (err u0)) (if (is-eq c u14) (i14 in) (err u0)) (if (is-eq c u15) (i15 in) (err u0)) (if (is-eq c u16) (i16 in) (err u0)) (if (is-eq c u17) (i17 in) (err u0)) (if (is-eq c u18) (i18 in) (err u0)) (if (is-eq c u19) (i19 in) (err u0)) (if (is-eq c u20) (i20 in) (err u0)) (if (is-eq c u21) (i21 in) (err u0)))) (if (<= c u41) (list (if (is-eq c u31) (o1 in) (err u0)) (if (is-eq c u32) (o2 in) (err u0)) (if (is-eq c u33) (o3 in) (err u0)) (if (is-eq c u34) (o4 in) (err u0)) (if (is-eq c u35) (o5 in) (err u0)) (if (is-eq c u36) (o6 in) (err u0)) (if (is-eq c u37) (o7 in) (err u0)) (if (is-eq c u38) (o8 in) (err u0)) (if (is-eq c u39) (o9 in) (err u0)) (if (is-eq c u40) (o10 in) (err u0)) (if (is-eq c u41) (o11 in) (err u0))) (list (if (is-eq c u42) (o12 in) (err u0)) (if (is-eq c u43) (o13 in) (err u0)) (if (is-eq c u44) (o14 in) (err u0)) (if (is-eq c u45) (o15 in) (err u0)) (if (is-eq c u46) (o16 in) (err u0)) (if (is-eq c u47) (o17 in) (err u0)) (if (is-eq c u48) (o18 in) (err u0)) (if (is-eq c u49) (o19 in) (err u0)) (if (is-eq c u50) (o20 in) (err u0)) (if (is-eq c u51) (o21 in) (err u0))))))) (ok true))) (define-private (ee (bp (buff 2048)) (t <et>)) (as-contract (begin (asserts! (is-eq tx-sender (contract-of t)) (err u0)) (try! (contract-call? 'SPB75ZW15C90ZNDPQF4GSVNGBEJJA6WACZKNFVFK.vault-v1 flash-loan-stx t (stx-get-balance 'SPB75ZW15C90ZNDPQF4GSVNGBEJJA6WACZKNFVFK.vault-v1) tx-sender bp)) (let ((ba (stx-get-balance tx-sender))) (and (> ba u0) (try! (stx-transfer? ba tx-sender 'SP1VSDGJ3RCR2K8V1SY5DGNR733YACKPXPHEMXTFD)))) (ok true)))) (define-public (r0 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r1 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r2 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r3 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r4 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r5 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r6 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r7 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r8 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r9 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ra (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rb (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rc (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rd (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (re (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rf (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rg (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rh (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ri (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rj (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rk (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rl (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rm (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rn (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ro (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rp (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rq (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rr (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rs (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rt (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ru (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rv (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rw (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rx (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ry (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rz (bp (buff 2048)) (t <et>)) (ee bp t))",
    "analysis": {
      "summary": "This contract performs complex token swaps across multiple protocols and includes a callback mechanism for flash loans.",
      "explanation": "This Clarity smart contract is designed to interact with various decentralized finance (DeFi) protocols on the Stacks blockchain to perform token swaps and leverage flash loans. It utilizes traits to ensure compatibility with external contracts and defines a series of public functions to execute swaps and loans based on encoded instructions. The contract's architecture allows for dynamic interaction with a predefined set of tokens and protocols, making it a versatile tool for arbitrage, liquidity provision, and other DeFi strategies. Here's a detailed breakdown of its components and functionalities: \n\n1. Constants and Traits: \n- The contract declares a constant `E8` <L3> to represent a multiplier for token amounts, ensuring precision in transactions. \n- It uses the `use-trait` and `impl-trait` declarations <L1> to interact with external contracts, adhering to the specified trait interfaces. This design enables the contract to call functions on other contracts dynamically, facilitating token swaps across different protocols.\n\n2. Functions: \n- The `s2e` function <L4> is a utility function that multiplies an input by 100, likely used to adjust token amounts for precision in calculations. \n- The `i1` to `i21` and `o1` to `o21` functions <L5-26> are designed to execute token swaps on various DeFi platforms. Each function corresponds to a specific swap operation, such as swapping token X for token Y or vice versa. These functions use the `contract-call?` statement to interact with external DeFi protocols, passing in parameters like token addresses and amounts. The exact logic within each function depends on the external contract being called, but generally, they follow a pattern of checking balances, executing swaps, and handling errors or unexpected results. \n- The `callback` function <L27> is particularly interesting as it appears to be designed for handling callbacks from flash loan operations. It decodes instructions from a buffer passed as a parameter, determining which swap functions to call based on the encoded data. This mechanism allows for complex, multi-step transactions to be executed in response to conditions met after receiving a flash loan. \n- The `ee` function and its variants `r0` to `rz` <L28-57> seem to facilitate the execution of flash loans, calling an external contract to borrow STX tokens and then executing encoded swap instructions via the `callback` function. The use of `as-contract` and `asserts!` ensures that these operations are securely performed, verifying the caller and ensuring the contract has enough balance to proceed.\n\nNotable Qualities: \n- The contract's design for interoperability with multiple DeFi protocols showcases the flexibility of Clarity smart contracts in creating complex DeFi strategies. \n- The use of encoded instructions and a callback mechanism for flash loans is a sophisticated approach to automating DeFi transactions, allowing for dynamic responses to market conditions. \n- The extensive use of `contract-call?` to interact with a wide range of external contracts highlights the contract's role as a bridge between different protocols, facilitating liquidity movement across the Stacks ecosystem.",
      "tags": ["DeFi", "swap", "flash-loan", "protocol"]
    }
  },
  {
    "rank": 26,
    "contract": "SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1",
    "calls": 1660,
    "source": "\n;; xyk-core-v-1-1\n\n(use-trait xyk-pool-trait .xyk-pool-trait-v-1-1.xyk-pool-trait)\n(use-trait sip-010-trait .sip-010-trait-ft-standard-v-1-1.sip-010-trait)\n\n(define-constant ERR_NOT_AUTHORIZED (err u1001))\n(define-constant ERR_INVALID_AMOUNT (err u1002))\n(define-constant ERR_INVALID_PRINCIPAL (err u1003))\n(define-constant ERR_ALREADY_ADMIN (err u2001))\n(define-constant ERR_ADMIN_LIMIT_REACHED (err u2002))\n(define-constant ERR_ADMIN_NOT_IN_LIST (err u2003))\n(define-constant ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER (err u2004))\n(define-constant ERR_NO_POOL_DATA (err u3001))\n(define-constant ERR_POOL_NOT_CREATED (err u3002))\n(define-constant ERR_POOL_DISABLED (err u3003))\n(define-constant ERR_POOL_ALREADY_CREATED (err u3004))\n(define-constant ERR_INVALID_POOL (err u3005))\n(define-constant ERR_INVALID_POOL_URI (err u3006))\n(define-constant ERR_INVALID_POOL_SYMBOL (err u3007))\n(define-constant ERR_INVALID_TOKEN_SYMBOL (err u3009))\n(define-constant ERR_MATCHING_TOKEN_CONTRACTS (err u3010))\n(define-constant ERR_INVALID_X_TOKEN (err u3011))\n(define-constant ERR_INVALID_Y_TOKEN (err u3012))\n(define-constant ERR_MINIMUM_X_AMOUNT (err u3013))\n(define-constant ERR_MINIMUM_Y_AMOUNT (err u3014))\n(define-constant ERR_MINIMUM_LP_AMOUNT (err u3015))\n\n(define-constant CONTRACT_DEPLOYER tx-sender)\n\n(define-constant BPS u10000)\n(define-constant MINIMUM_SHARES u1000000)\n\n(define-data-var admins (list 5 principal) (list tx-sender))\n(define-data-var admin-helper principal tx-sender)\n\n(define-data-var last-pool-id uint u0)\n\n(define-data-var public-pool-creation bool false)\n\n(define-map pools uint {\n  id: uint,\n  name: (string-ascii 256),\n  symbol: (string-ascii 256),\n  pool-contract: principal\n})\n\n(define-read-only (get-admins)\n  (ok (var-get admins))\n)\n\n(define-read-only (get-admin-helper)\n  (ok (var-get admin-helper))\n)\n\n(define-read-only (get-last-pool-id)\n  (ok (var-get last-pool-id))\n)\n\n(define-read-only (get-public-pool-creation)\n  (ok (var-get public-pool-creation))\n)\n\n(define-read-only (get-pool-by-id (id uint))\n  (ok (map-get? pools id))\n)\n\n(define-public (set-public-pool-creation (status bool))\n  (let (\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n      (var-set public-pool-creation status)\n      (print {action: \"set-public-pool-creation\", caller: caller, data: {status: status}})\n      (ok true)\n    )\n  )\n)\n\n(define-public (set-pool-uri (pool-trait <xyk-pool-trait>) (uri (string-utf8 256)))\n  (let (\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n      (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n      (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n      (asserts! (> (len uri) u0) ERR_INVALID_POOL_URI)\n      (try! (as-contract (contract-call? pool-trait set-pool-uri uri)))\n      (print {\n        action: \"set-pool-uri\",\n        caller: caller,\n        data: {\n          pool-id: (get pool-id pool-data),\n          pool-name: (get pool-name pool-data),\n          pool-contract: (contract-of pool-trait),\n          uri: uri\n        }\n      })\n      (ok true)\n    )\n  )\n)\n\n(define-public (set-pool-status (pool-trait <xyk-pool-trait>) (status bool))\n  (let (\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n      (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n      (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n      (try! (as-contract (contract-call? pool-trait set-pool-status status)))\n      (print {\n        action: \"set-pool-status\",\n        caller: caller,\n        data: {\n          pool-id: (get pool-id pool-data),\n          pool-name: (get pool-name pool-data),\n          pool-contract: (contract-of pool-trait),\n          status: status\n        }\n      })\n      (ok true)\n    )\n  )\n)\n\n(define-public (set-fee-address (pool-trait <xyk-pool-trait>) (address principal))\n  (let (\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n      (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n      (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n      (asserts! (is-standard address) ERR_INVALID_PRINCIPAL)\n      (try! (as-contract (contract-call? pool-trait set-fee-address address)))\n      (print {\n        action: \"set-fee-address\",\n        caller: caller,\n        data: {\n          pool-id: (get pool-id pool-data),\n          pool-name: (get pool-name pool-data),\n          pool-contract: (contract-of pool-trait),\n          address: address\n        }\n      })\n      (ok true)\n    )\n  )\n)\n\n(define-public (set-x-fees (pool-trait <xyk-pool-trait>) (protocol-fee uint) (provider-fee uint))\n  (let (\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n      (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n      (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n      (try! (as-contract (contract-call? pool-trait set-x-fees protocol-fee provider-fee)))\n      (print {\n        action: \"set-x-fees\",\n        caller: caller,\n        data: {\n          pool-id: (get pool-id pool-data),\n          pool-name: (get pool-name pool-data),\n          pool-contract: (contract-of pool-trait),\n          protocol-fee: protocol-fee,\n          provider-fee: provider-fee\n        }\n      })\n      (ok true)\n    )\n  )\n)\n\n(define-public (set-y-fees (pool-trait <xyk-pool-trait>) (protocol-fee uint) (provider-fee uint))\n  (let (\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n      (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n      (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n      (try! (as-contract (contract-call? pool-trait set-y-fees protocol-fee provider-fee)))\n      (print {\n        action: \"set-y-fees\",\n        caller: caller,\n        data: {\n          pool-id: (get pool-id pool-data),\n          pool-name: (get pool-name pool-data),\n          pool-contract: (contract-of pool-trait),\n          protocol-fee: protocol-fee,\n          provider-fee: provider-fee\n        }\n      })\n      (ok true)\n    )\n  )\n)\n\n(define-public (create-pool \n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (x-amount uint) (y-amount uint)\n    (x-protocol-fee uint) (x-provider-fee uint)\n    (y-protocol-fee uint) (y-provider-fee uint)\n    (fee-address principal) (uri (string-utf8 256)) (status bool)\n  )\n  (let (\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-contract (contract-of pool-trait))\n    (new-pool-id (+ (var-get last-pool-id) u1))\n    (symbol (unwrap! (create-symbol x-token-trait y-token-trait) ERR_INVALID_POOL_SYMBOL))\n    (name (concat symbol \"-LP\"))\n    (x-token-contract (contract-of x-token-trait))\n    (y-token-contract (contract-of y-token-trait))\n    (total-shares (sqrti (* x-amount y-amount)))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (or (is-some (index-of (var-get admins) caller)) (var-get public-pool-creation)) ERR_NOT_AUTHORIZED)\n      (asserts! (is-eq (get pool-created pool-data) false) ERR_POOL_ALREADY_CREATED)\n      (asserts! (not (is-eq x-token-contract y-token-contract)) ERR_MATCHING_TOKEN_CONTRACTS)\n      (asserts! (is-standard x-token-contract) ERR_INVALID_PRINCIPAL)\n      (asserts! (is-standard y-token-contract) ERR_INVALID_PRINCIPAL)\n      (asserts! (is-standard fee-address) ERR_INVALID_PRINCIPAL)\n      (asserts! (> x-amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (> y-amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (> total-shares MINIMUM_SHARES) ERR_MINIMUM_LP_AMOUNT)\n      (asserts! (> (len uri) u0) ERR_INVALID_POOL_URI)\n      (try! (as-contract (contract-call? pool-trait create-pool x-token-contract y-token-contract fee-address new-pool-id name symbol uri status)))\n      (try! (as-contract (contract-call? pool-trait set-x-fees x-protocol-fee x-provider-fee)))\n      (try! (as-contract (contract-call? pool-trait set-y-fees y-protocol-fee y-provider-fee)))\n      (var-set last-pool-id new-pool-id)\n      (map-set pools new-pool-id {id: new-pool-id, name: name, symbol: symbol, pool-contract: pool-contract})\n      (try! (contract-call? x-token-trait transfer x-amount caller pool-contract none))\n      (try! (contract-call? y-token-trait transfer y-amount caller pool-contract none))\n      (try! (as-contract (contract-call? pool-trait update-pool-balances x-amount y-amount)))\n      (try! (as-contract (contract-call? pool-trait pool-mint (- total-shares MINIMUM_SHARES) caller)))\n      (try! (as-contract (contract-call? pool-trait pool-mint MINIMUM_SHARES pool-contract)))\n      (print {\n        action: \"create-pool\",\n        caller: caller,\n        data: {\n          pool-id: new-pool-id,\n          pool-name: name,\n          pool-contract: pool-contract,\n          x-token: x-token-contract,\n          y-token: y-token-contract,\n          x-protocol-fee: x-protocol-fee,\n          x-provider-fee: x-provider-fee,\n          y-protocol-fee: y-protocol-fee,\n          y-provider-fee: y-provider-fee,\n          x-amount: x-amount,\n          y-amount: y-amount,\n          total-shares: total-shares,\n          pool-symbol: symbol,\n          pool-uri: uri,\n          pool-status: status,\n          creation-height: burn-block-height,\n          fee-address: fee-address\n        }\n      })\n      (ok true)\n    )\n  )\n)\n\n(define-public (swap-x-for-y\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (x-amount uint) (min-dy uint)\n  )\n  (let (\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-contract (contract-of pool-trait))\n    (fee-address (get fee-address pool-data))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (protocol-fee (get x-protocol-fee pool-data))\n    (provider-fee (get x-provider-fee pool-data))\n    (x-amount-fees-protocol (/ (* x-amount protocol-fee) BPS))\n    (x-amount-fees-provider (/ (* x-amount provider-fee) BPS))\n    (x-amount-fees-total (+ x-amount-fees-protocol x-amount-fees-provider))\n    (dx (- x-amount x-amount-fees-total))\n    (updated-x-balance (+ x-balance dx))\n    (dy (/ ( * y-balance dx) (+ updated-x-balance)))\n    (updated-y-balance ( - y-balance dy))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n      (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n      (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n      (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n      (asserts! (> x-amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (> min-dy u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= dy min-dy) ERR_MINIMUM_Y_AMOUNT)\n      (try! (contract-call? x-token-trait transfer (+ dx x-amount-fees-provider) caller pool-contract none))\n      (try! (as-contract (contract-call? pool-trait pool-transfer y-token-trait dy caller)))\n      (if (> x-amount-fees-protocol u0)\n        (try! (contract-call? x-token-trait transfer x-amount-fees-protocol caller fee-address none))\n        false\n      )\n      (try! (as-contract (contract-call? pool-trait update-pool-balances (+ updated-x-balance x-amount-fees-provider) updated-y-balance)))\n      (print {\n        action: \"swap-x-for-y\",\n        caller: caller,\n        data: {\n          pool-id: (get pool-id pool-data),\n          pool-name: (get pool-name pool-data),\n          pool-contract: pool-contract,\n          x-token: x-token,\n          y-token: y-token,\n          x-amount: x-amount,\n          x-amount-fees-protocol: x-amount-fees-protocol,\n          x-amount-fees-provider: x-amount-fees-provider,\n          dy: dy,\n          min-dy: min-dy\n        }\n      })\n      (ok dy)\n    )\n  )\n)\n\n(define-public (swap-y-for-x\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (y-amount uint) (min-dx uint)\n  )\n  (let (\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-contract (contract-of pool-trait))\n    (fee-address (get fee-address pool-data))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (protocol-fee (get y-protocol-fee pool-data))\n    (provider-fee (get y-provider-fee pool-data))\n    (y-amount-fees-protocol (/ (* y-amount protocol-fee) BPS))\n    (y-amount-fees-provider (/ (* y-amount provider-fee) BPS))\n    (y-amount-fees-total (+ y-amount-fees-protocol y-amount-fees-provider))\n    (dy (- y-amount y-amount-fees-total))\n    (updated-y-balance (+ y-balance dy))\n    (dx (/ ( * x-balance dy) (+ updated-y-balance)))\n    (updated-x-balance ( - x-balance dx))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n      (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n      (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n      (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n      (asserts! (> y-amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (> min-dx u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= dx min-dx) ERR_MINIMUM_X_AMOUNT)\n      (try! (contract-call? y-token-trait transfer (+ dy y-amount-fees-provider) caller pool-contract none))\n      (try! (as-contract (contract-call? pool-trait pool-transfer x-token-trait dx caller)))\n      (if (> y-amount-fees-protocol u0)\n        (try! (contract-call? y-token-trait transfer y-amount-fees-protocol caller fee-address none))\n        false\n      )\n      (try! (as-contract (contract-call? pool-trait update-pool-balances updated-x-balance (+ updated-y-balance y-amount-fees-provider))))\n      (print {\n        action: \"swap-y-for-x\",\n        caller: caller,\n        data: {\n          pool-id: (get pool-id pool-data),\n          pool-name: (get pool-name pool-data),\n          pool-contract: pool-contract,\n          x-token: x-token,\n          y-token: y-token,\n          y-amount: y-amount,\n          y-amount-fees-protocol: y-amount-fees-protocol,\n          y-amount-fees-provider: y-amount-fees-provider,\n          dx: dx,\n          min-dx: min-dx\n        }\n      })\n      (ok dx)\n    )\n  )\n)\n\n(define-public (add-liquidity\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (x-amount uint) (min-dlp uint)\n  )\n  (let (\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-contract (contract-of pool-trait))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (total-shares (get total-shares pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (y-amount (/ (* x-amount y-balance) x-balance))\n    (updated-x-balance (+ x-balance x-amount))\n    (updated-y-balance (+ y-balance y-amount))\n    (dlp (/ (* x-amount total-shares) x-balance))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n      (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n      (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n      (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n      (asserts! (> x-amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (> min-dlp u0) ERR_INVALID_AMOUNT)\n      (asserts! (> y-amount u0) ERR_MINIMUM_Y_AMOUNT)\n      (asserts! (>= dlp min-dlp) ERR_MINIMUM_LP_AMOUNT)\n      (try! (contract-call? x-token-trait transfer x-amount caller pool-contract none))\n      (try! (contract-call? y-token-trait transfer y-amount caller pool-contract none))\n      (try! (as-contract (contract-call? pool-trait update-pool-balances updated-x-balance updated-y-balance)))\n      (try! (as-contract (contract-call? pool-trait pool-mint dlp caller)))\n      (print {\n        action: \"add-liquidity\",\n        caller: caller,\n        data: {\n          pool-id: (get pool-id pool-data),\n          pool-name: (get pool-name pool-data),\n          pool-contract: pool-contract,\n          x-token: x-token,\n          y-token: y-token,\n          x-amount: x-amount,\n          y-amount: y-amount,\n          dlp: dlp,\n          min-dlp: min-dlp\n        }\n      })\n      (ok dlp)\n    )\n  )\n)\n\n(define-public (withdraw-liquidity\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (amount uint) (min-x-amount uint) (min-y-amount uint)\n  )\n  (let (\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (total-shares (get total-shares pool-data))\n    (x-amount (/ (* amount x-balance) total-shares))\n    (y-amount (/ (* amount y-balance) total-shares))\n    (updated-x-balance (- x-balance x-amount))\n    (updated-y-balance (- y-balance y-amount))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n      (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n      (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (> (+ x-amount y-amount) u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= x-amount min-x-amount) ERR_MINIMUM_X_AMOUNT)\n      (asserts! (>= y-amount min-y-amount) ERR_MINIMUM_Y_AMOUNT)\n      (if (> x-amount u0)\n        (try! (as-contract (contract-call? pool-trait pool-transfer x-token-trait x-amount caller)))\n        false\n      )\n      (if (> y-amount u0)\n        (try! (as-contract (contract-call? pool-trait pool-transfer y-token-trait y-amount caller)))\n        false\n      )\n      (try! (as-contract (contract-call? pool-trait update-pool-balances updated-x-balance updated-y-balance)))\n      (try! (as-contract (contract-call? pool-trait pool-burn amount caller)))\n      (print {\n        action: \"withdraw-liquidity\",\n        caller: caller,\n        data: {\n          pool-id: (get pool-id pool-data),\n          pool-name: (get pool-name pool-data),\n          pool-contract: (contract-of pool-trait),\n          x-token: x-token,\n          y-token: y-token,\n          amount: amount,\n          x-amount: x-amount,\n          y-amount: y-amount,\n          min-x-amount: min-x-amount,\n          min-y-amount: min-y-amount\n        }\n      })\n      (ok {x-amount: x-amount, y-amount: y-amount})\n    )\n  )\n)\n\n(define-public (add-admin (admin principal))\n  (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n  )\n    (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n    (asserts! (is-none (index-of admins-list admin)) ERR_ALREADY_ADMIN)\n    (var-set admins (unwrap! (as-max-len? (append admins-list admin) u5) ERR_ADMIN_LIMIT_REACHED))\n    (print {action: \"add-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n  )\n)\n\n(define-public (remove-admin (admin principal))\n  (let (\n    (admins-list (var-get admins))\n    (caller-in-list (index-of admins-list tx-sender))\n    (admin-to-remove-in-list (index-of admins-list admin))\n    (caller tx-sender)\n  )\n    (asserts! (is-some caller-in-list) ERR_NOT_AUTHORIZED)\n    (asserts! (is-some admin-to-remove-in-list) ERR_ADMIN_NOT_IN_LIST)\n    (asserts! (not (is-eq admin CONTRACT_DEPLOYER)) ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER)\n    (var-set admin-helper admin)\n    (var-set admins (filter admin-not-removeable admins-list))\n    (print {action: \"remove-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n  )\n)\n\n(define-public (set-pool-uri-multi\n    (pool-traits (list 120 <xyk-pool-trait>))\n    (uris (list 120 (string-utf8 256)))\n  )\n  (ok (map set-pool-uri pool-traits uris))\n)\n\n(define-public (set-pool-status-multi\n    (pool-traits (list 120 <xyk-pool-trait>))\n    (statuses (list 120 bool))\n  )\n  (ok (map set-pool-status pool-traits statuses))\n)\n\n(define-public (set-fee-address-multi\n    (pool-traits (list 120 <xyk-pool-trait>))\n    (addresses (list 120 principal))\n  )\n  (ok (map set-fee-address pool-traits addresses))\n)\n\n(define-public (set-x-fees-multi\n    (pool-traits (list 120 <xyk-pool-trait>))\n    (protocol-fees (list 120 uint)) (provider-fees (list 120 uint))\n  )\n  (ok (map set-x-fees pool-traits protocol-fees provider-fees))\n)\n\n(define-public (set-y-fees-multi\n    (pool-traits (list 120 <xyk-pool-trait>))\n    (protocol-fees (list 120 uint)) (provider-fees (list 120 uint))\n  )\n  (ok (map set-y-fees pool-traits protocol-fees provider-fees))\n)\n\n(define-private (admin-not-removeable (admin principal))\n  (not (is-eq admin (var-get admin-helper)))\n)\n\n(define-private (create-symbol (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>))\n  (let (\n    (x-symbol (unwrap! (contract-call? x-token-trait get-symbol) ERR_INVALID_TOKEN_SYMBOL))\n    (y-symbol (unwrap! (contract-call? y-token-trait get-symbol) ERR_INVALID_TOKEN_SYMBOL))\n  )\n    (ok (concat x-symbol (concat \"-\" y-symbol)))\n  )\n)\n\n(define-private (is-valid-pool (id uint) (contract principal))\n  (let (\n    (pool-data (unwrap! (map-get? pools id) false))\n  )\n    (is-eq contract (get pool-contract pool-data))\n  )\n)\n",
    "analysis": {
      "summary": "This contract manages liquidity pools for a decentralized exchange (DEX) on the Stacks blockchain, allowing for pool creation, liquidity provision, and token swaps.",
      "explanation": "**Architectural Overview**\n\nThe contract leverages Clarity traits to interact with external token contracts and pool contracts, ensuring flexibility and composability within the Stacks ecosystem. It introduces a governance layer through admin management, enabling controlled execution of critical functions like pool creation and fee adjustments.\n\n**Data Variables and Constants**\n\nError Handling <L7-27>: defines ERR_NOT_AUTHORIZED, ERR_INVALID_AMOUNT and other standardized error codes.\n\nGovernance Constants <L29-32>:\n- CONTRACT_DEPLOYER: stores deployer address for admin purposes\n- BPS: base points for fee calculations\n- MINIMUM_SHARES: prevents dust attacks by setting minimum LP shares\n\nState Variables <L34-46>:\n- admins & admin-helper: track governance privileges\n- last-pool-id: keeps count of created pools\n- public-pool-creation: controls who can create pools\n- pools map: stores all pool metadata\n\n**Core Functions**\n\nGetter Functions <L48-66>: read-only access to contract state (get-admins, get-last-pool-id, get-pool-by-id)\n\nPool Creation Control <L68-79>: set-public-pool-creation lets admins toggle public pool creation\n\nPool Configuration <L81-208>: admin functions for managing pools:\n- set-pool-uri\n- set-pool-status\n- set-fee-address\n- set-x-fees and set-y-fees\n\nPool Creation <L210-276>: create-pool handles new pool initialization with initial liquidity and fees\n\nSwap Functions <L278-395>:\n- swap-x-for-y\n- swap-y-for-x\nBoth handle token swaps with fee processing\n\nLiquidity Management <L398-504>:\n- add-liquidity: lets LPs contribute tokens\n- withdraw-liquidity: handles LP share redemption\n\nAdmin Controls <L507-535>: add-admin and remove-admin manage governance access\n\n**Safety Features**\n\n- Robust authorization checks on admin functions\n- Input validation against common attack vectors\n- Standardized error handling for better debugging\n\n**External Interactions**\n\nIntegrates with other contracts via SIP-010 token traits and pool traits, maintaining ecosystem compatibility",
      "tags": ["DEX", "liquidity-pool", "governance", "DeFi"],
      "notable_qualities": [
        "The contract introduces a governance layer for DEX operations, a critical feature for decentralized financial platforms.",
        "It demonstrates a comprehensive approach to error handling, enhancing contract reliability and user experience.",
        "The use of Clarity traits for external interactions showcases the composability and extensibility of smart contracts on the Stacks blockchain."
      ]
    }
  },
  {
    "rank": 27,
    "contract": "SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1",
    "calls": 1575,
    "source": ";; @contract Swap - Decentralised exchange\n;; @version 2\n\n(use-trait ft-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)\n(use-trait swap-token .arkadiko-swap-trait-v1.swap-trait)\n\n(define-constant ERR-NOT-AUTHORIZED u20401)\n(define-constant INVALID-PAIR-ERR (err u201))\n(define-constant ERR-INVALID-LIQUIDITY u202)\n(define-constant ERR-NO-FEE-TO-ADDRESS u203)\n(define-constant ERR-WRONG-SWAP-TOKEN u204)\n(define-constant ERR-EMERGENCY-SHUTDOWN-ACTIVATED u205)\n(define-constant ERR-PAIR-DISABLED u206)\n\n(define-constant no-liquidity-err (err u61))\n(define-constant not-owner-err (err u63))\n(define-constant no-such-position-err (err u66))\n(define-constant balance-too-low-err (err u67))\n(define-constant too-many-pairs-err (err u68))\n(define-constant pair-already-exists-err (err u69))\n(define-constant wrong-token-err (err u70))\n(define-constant too-much-slippage-err (err u71))\n(define-constant transfer-x-failed-err (err u72))\n(define-constant transfer-y-failed-err (err u73))\n(define-constant value-out-of-range-err (err u74))\n(define-constant no-fee-x-err (err u75))\n(define-constant no-fee-y-err (err u76))\n\n(define-data-var swap-shutdown-activated bool false)\n\n(define-public (toggle-swap-shutdown)\n  (begin\n    (asserts! (is-eq contract-caller (contract-call? .arkadiko-dao get-guardian-address)) (err ERR-NOT-AUTHORIZED))\n\n    (ok (var-set swap-shutdown-activated (not (var-get swap-shutdown-activated))))\n  )\n)\n\n(define-map pairs-map\n  { pair-id: uint }\n  {\n    token-x: principal,\n    token-y: principal,\n  }\n)\n\n(define-map pairs-data-map\n  {\n    token-x: principal,\n    token-y: principal,\n  }\n  {\n    enabled: bool,\n    shares-total: uint,\n    balance-x: uint,\n    balance-y: uint,\n    fee-balance-x: uint,\n    fee-balance-y: uint,\n    fee-to-address: (optional principal),\n    swap-token: principal,\n    name: (string-ascii 32),\n  }\n)\n\n(define-map registered-swap-tokens\n  { swap-token: principal }\n  { registered: bool }\n)\n\n(define-data-var pair-count uint u0)\n\n(define-read-only (shutdown-not-activated)\n  (and\n     (not (unwrap-panic (contract-call? .arkadiko-dao get-emergency-shutdown-activated)))\n     (not (var-get swap-shutdown-activated))\n  )\n)\n\n(define-read-only (get-name (token-x-trait <ft-trait>) (token-y-trait <ft-trait>))\n  (let\n    (\n      (token-x (contract-of token-x-trait))\n      (token-y (contract-of token-y-trait))\n      (pair (unwrap! (map-get? pairs-data-map { token-x: token-x, token-y: token-y }) (err INVALID-PAIR-ERR)))\n    )\n    (ok (get name pair))\n  )\n)\n\n(define-read-only (get-total-supply (token-x-trait <ft-trait>) (token-y-trait <ft-trait>))\n  (let\n    (\n      (token-x (contract-of token-x-trait))\n      (token-y (contract-of token-y-trait))\n      (pair (unwrap! (map-get? pairs-data-map { token-x: token-x, token-y: token-y }) (err INVALID-PAIR-ERR)))\n    )\n    (ok (get shares-total pair))\n  )\n)\n\n;; @desc get the total number of shares in the pool\n;; @param token-x; address of token X in the pool\n;; @param token-y; address of token Y in the pool\n;; @post uint; returns total number of shares\n(define-read-only (get-shares (token-x principal) (token-y principal))\n  (ok (get shares-total (unwrap! (map-get? pairs-data-map { token-x: token-x, token-y: token-y }) (err INVALID-PAIR-ERR))))\n)\n\n;; @desc get token balances for the pair\n;; @param token-x-trait; first token of pair\n;; @param token-y-trait; second token of pair\n;; @post list; returns balance for first and second token in a list\n(define-public (get-balances (token-x-trait <ft-trait>) (token-y-trait <ft-trait>))\n  (let\n    (\n      (token-x (contract-of token-x-trait))\n      (token-y (contract-of token-y-trait))\n      (pair (unwrap! (map-get? pairs-data-map { token-x: token-x, token-y: token-y }) (err INVALID-PAIR-ERR)))\n    )\n    (ok (list (get balance-x pair) (get balance-y pair)))\n  )\n)\n\n;; @desc get all data for the LP token\n;; @param token-x-trait; first token of pair\n;; @param token-y-trait; second token of pair\n;; @param swap-token-trait; LP token\n;; @param owner; data returned will contain balance for this user\n;; @post tuple; all LP token information\n(define-public (get-data (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (swap-token-trait <swap-token>) (owner principal))\n  (let\n    (\n      (token-data (unwrap-panic (contract-call? swap-token-trait get-data owner)))\n      (balances (unwrap-panic (get-balances token-x-trait token-y-trait)))\n    )\n    (ok (merge token-data { balances: balances }))\n  )\n)\n\n(define-read-only (is-registered-swap-token (swap-token principal))\n  (is-some (map-get? registered-swap-tokens { swap-token: swap-token }))\n)\n\n(define-private (register-swap-token (swap-token principal))\n  (begin\n    (asserts! (not (is-registered-swap-token swap-token)) (err ERR-WRONG-SWAP-TOKEN))\n    (ok (map-set registered-swap-tokens { swap-token: swap-token } { registered: true }))\n  )\n)\n\n;; @desc add liquidity to a pair\n;; @param token-x-trait; first token of pair\n;; @param token-y-trait; second token of pair\n;; @param swap-token-trait; LP token\n;; @param x; amount to add to first token of pair\n;; @param y; amount to add to second token of pair, only used when pair is created\n;; @post boolean; returns true if liquidity added\n(define-public (add-to-position (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (swap-token-trait <swap-token>) (x uint) (y uint))\n  (let\n    (\n      (token-x (contract-of token-x-trait))\n      (token-y (contract-of token-y-trait))\n      (pair (unwrap-panic (map-get? pairs-data-map { token-x: token-x, token-y: token-y })))\n      (contract-address (as-contract tx-sender))\n      (recipient-address tx-sender)\n      (balance-x (get balance-x pair))\n      (balance-y (get balance-y pair))\n      (swap-token (get swap-token pair))\n      (new-shares\n        (if (is-eq (get shares-total pair) u0)\n          (sqrti (* x y))\n          (/ (* x (get shares-total pair)) balance-x)\n        )\n      )\n      (new-y\n        (if (is-eq (get shares-total pair) u0)\n          y\n          (/ (* x balance-y) balance-x)\n        )\n      )\n      (pair-updated (merge pair {\n        shares-total: (+ new-shares (get shares-total pair)),\n        balance-x: (+ balance-x x),\n        balance-y: (+ balance-y new-y)\n      }))\n    )\n    (asserts! (and (> x u0) (> new-y u0)) (err ERR-INVALID-LIQUIDITY))\n    (asserts! (is-eq swap-token (contract-of swap-token-trait)) (err ERR-WRONG-SWAP-TOKEN))\n    (asserts! (shutdown-not-activated) (err ERR-EMERGENCY-SHUTDOWN-ACTIVATED))\n\n    (if (is-eq token-x .wrapped-stx-token)\n      (begin\n        (try! (contract-call? .arkadiko-dao mint-token .wrapped-stx-token x tx-sender))\n        (try! (stx-transfer? x tx-sender contract-address))\n      )\n      false\n    )\n    (if (is-eq token-y .wrapped-stx-token)\n      (begin\n        (try! (contract-call? .arkadiko-dao mint-token .wrapped-stx-token y tx-sender))\n        (try! (stx-transfer? y tx-sender contract-address))\n      )\n      false\n    )\n\n    (asserts! (is-ok (contract-call? token-x-trait transfer x tx-sender contract-address none)) transfer-x-failed-err)\n    (asserts! (is-ok (contract-call? token-y-trait transfer new-y tx-sender contract-address none)) transfer-y-failed-err)\n\n    (map-set pairs-data-map { token-x: token-x, token-y: token-y } pair-updated)\n    (try! (contract-call? swap-token-trait mint recipient-address new-shares))\n    (print { object: \"pair\", action: \"liquidity-added\", data: pair-updated })\n    (ok true)\n  )\n)\n\n(define-read-only (get-pair-details (token-x principal) (token-y principal))\n  (let (\n    (pair (map-get? pairs-data-map { token-x: token-x, token-y: token-y }))\n  )\n    (if (is-some pair)\n      (ok pair)\n      (err INVALID-PAIR-ERR)\n    )\n  )\n)\n\n(define-read-only (get-pair-contracts (pair-id uint))\n  (unwrap-panic (map-get? pairs-map { pair-id: pair-id }))\n)\n\n(define-read-only (get-pair-count)\n  (ok (var-get pair-count))\n)\n\n(define-public (migrate-create-pair (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (swap-token-trait <swap-token>) (pair-name (string-ascii 32)) (shares-total uint))\n\n  (let (\n    (pair-id (+ (var-get pair-count) u1))\n    (token-x (contract-of token-x-trait))\n    (token-y (contract-of token-y-trait))\n    (token-swap (contract-of swap-token-trait))\n\n    (pair-data {\n      enabled: false,\n      shares-total: shares-total,\n      balance-x: u0,\n      balance-y: u0,\n      fee-balance-x: u0,\n      fee-balance-y: u0,\n      fee-to-address: (some (contract-call? .arkadiko-dao get-payout-address)),\n      swap-token: token-swap,\n      name: pair-name,\n    })\n  )\n    (asserts! (is-eq contract-caller (contract-call? .arkadiko-dao get-dao-owner)) (err ERR-NOT-AUTHORIZED))\n    (asserts!\n      (and\n        (is-none (map-get? pairs-data-map { token-x: token-x, token-y: token-y }))\n        (is-none (map-get? pairs-data-map { token-x: token-y, token-y: token-x }))\n      )\n      pair-already-exists-err\n    )\n\n    ;; Register swap token\n    (try! (register-swap-token token-swap))\n\n    ;; Update maps\n    (map-set pairs-data-map { token-x: token-x, token-y: token-y } pair-data)\n    (map-set pairs-map { pair-id: pair-id } { token-x: token-x, token-y: token-y })\n\n    ;; Increase pair count\n    (var-set pair-count pair-id)\n\n    (ok true)\n  )\n\n)\n\n(define-public (migrate-add-liquidity (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (x uint) (y uint))\n\n  (let (\n    (contract-address (as-contract tx-sender))\n    (token-x (contract-of token-x-trait))\n    (token-y (contract-of token-y-trait))\n    (pair-data (unwrap-panic (map-get? pairs-data-map { token-x: token-x, token-y: token-y })))\n    (new-balance-x (+ (get balance-x pair-data) x))\n    (new-balance-y (+ (get balance-y pair-data) y))\n  )\n    (asserts! (is-eq contract-caller (contract-call? .arkadiko-dao get-dao-owner)) (err ERR-NOT-AUTHORIZED))\n\n    ;; Transfer tokens from tx-sender to this contract\n    (if (is-eq token-x .wrapped-stx-token)\n      (begin\n        (try! (contract-call? .arkadiko-dao mint-token .wrapped-stx-token x tx-sender))\n        (try! (stx-transfer? x tx-sender contract-address))\n      )\n      false\n    )\n    (if (is-eq token-y .wrapped-stx-token)\n      (begin\n        (try! (contract-call? .arkadiko-dao mint-token .wrapped-stx-token y tx-sender))\n        (try! (stx-transfer? y tx-sender contract-address))\n      )\n      false\n    )\n    (asserts! (is-ok (contract-call? token-x-trait transfer x tx-sender contract-address none)) transfer-x-failed-err)\n    (asserts! (is-ok (contract-call? token-y-trait transfer y tx-sender contract-address none)) transfer-y-failed-err)\n\n    (map-set pairs-data-map\n      { token-x: token-x, token-y: token-y }\n      (merge pair-data { balance-x: new-balance-x, balance-y: new-balance-y })\n    )\n\n    (ok true)\n  )\n\n)\n\n;; @desc create a new pair\n;; @param token-x-trait; first token of pair\n;; @param token-y-trait; second token of pair\n;; @param swap-token-trait; LP token\n;; @param pair-name; name for the new pair\n;; @param x; amount to add to first token of pair\n;; @param y; amount to add to second token of pair\n;; @post boolean; returns true if pair created\n(define-public (create-pair\n  (token-x-trait <ft-trait>)\n  (token-y-trait <ft-trait>)\n  (swap-token-trait <swap-token>)\n  (pair-name (string-ascii 32))\n  (x uint)\n  (y uint)\n)\n  (let\n    (\n      (name-x (unwrap-panic (contract-call? token-x-trait get-name)))\n      (name-y (unwrap-panic (contract-call? token-y-trait get-name)))\n      (token-x (contract-of token-x-trait))\n      (token-y (contract-of token-y-trait))\n      (pair-id (+ (var-get pair-count) u1))\n      (pair-data {\n        enabled: true,\n        shares-total: u0,\n        balance-x: u0,\n        balance-y: u0,\n        fee-balance-x: u0,\n        fee-balance-y: u0,\n        fee-to-address: (some (contract-call? .arkadiko-dao get-payout-address)),\n        swap-token: (contract-of swap-token-trait),\n        name: pair-name,\n      })\n    )\n    (asserts! (is-eq contract-caller (contract-call? .arkadiko-dao get-dao-owner)) (err ERR-NOT-AUTHORIZED))\n    (asserts!\n      (and\n        (is-none (map-get? pairs-data-map { token-x: token-x, token-y: token-y }))\n        (is-none (map-get? pairs-data-map { token-x: token-y, token-y: token-x }))\n      )\n      pair-already-exists-err\n    )\n    (asserts! (shutdown-not-activated) (err ERR-EMERGENCY-SHUTDOWN-ACTIVATED))\n    (try! (register-swap-token (contract-of swap-token-trait)))\n\n    (map-set pairs-data-map { token-x: token-x, token-y: token-y } pair-data)\n    (map-set pairs-map { pair-id: pair-id } { token-x: token-x, token-y: token-y })\n    (var-set pair-count pair-id)\n    (try! (add-to-position token-x-trait token-y-trait swap-token-trait x y))\n    (print { object: \"pair\", action: \"created\", data: pair-data })\n    (ok true)\n  )\n)\n\n(define-public (get-position (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (swap-token-trait <swap-token>))\n  (let\n    (\n      (token-x (contract-of token-x-trait))\n      (token-y (contract-of token-y-trait))\n      (pair (unwrap-panic (map-get? pairs-data-map { token-x: token-x, token-y: token-y })))\n      (balance-x (get balance-x pair))\n      (balance-y (get balance-y pair))\n      (shares (unwrap-panic (contract-call? swap-token-trait get-balance tx-sender)))\n      (shares-total (get shares-total pair))\n      (withdrawal-x (/ (* shares balance-x) shares-total))\n      (withdrawal-y (/ (* shares balance-y) shares-total))\n    )\n    (ok (list withdrawal-x withdrawal-y))\n  )\n)\n\n(define-public (toggle-pair-enabled (token-x-trait <ft-trait>) (token-y-trait <ft-trait>))\n  (let (\n    (token-x (contract-of token-x-trait))\n    (token-y (contract-of token-y-trait))\n    (pair (unwrap-panic (map-get? pairs-data-map { token-x: token-x, token-y: token-y })))\n    (pair-data { enabled: (not (get enabled pair)) })\n  )\n    (asserts! (is-eq contract-caller (contract-call? .arkadiko-dao get-guardian-address)) (err ERR-NOT-AUTHORIZED))\n\n    (map-set pairs-data-map { token-x: token-x, token-y: token-y } (merge pair pair-data))\n    (ok true)\n  )\n)\n\n;; @desc reduce the amount of liquidity the sender provides to the pool\n;; @param token-x-trait; first token of pair\n;; @param token-y-trait; second token of pair\n;; @param swap-token-trait; LP token\n;; @param percent; percentage to reduce liquidity, use 100 to close\n;; @post list; returns amount of tokens withdrawn from the pair\n(define-public (reduce-position (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (swap-token-trait <swap-token>) (percent uint))\n  (let\n    (\n      (token-x (contract-of token-x-trait))\n      (token-y (contract-of token-y-trait))\n      (pair (unwrap-panic (map-get? pairs-data-map { token-x: token-x, token-y: token-y })))\n      (balance-x (get balance-x pair))\n      (balance-y (get balance-y pair))\n      (swap-token (get swap-token pair))\n      (shares (unwrap-panic (contract-call? swap-token-trait get-balance tx-sender)))\n      (shares-total (get shares-total pair))\n      (contract-address (as-contract tx-sender))\n      (sender tx-sender)\n      (withdrawal (/ (* shares percent) u100))\n      (withdrawal-x (/ (* withdrawal balance-x) shares-total))\n      (withdrawal-y (/ (* withdrawal balance-y) shares-total))\n      (pair-updated\n        (merge pair\n          {\n            shares-total: (- shares-total withdrawal),\n            balance-x: (- (get balance-x pair) withdrawal-x),\n            balance-y: (- (get balance-y pair) withdrawal-y)\n          }\n        )\n      )\n    )\n\n    (asserts! (<= percent u100) (err u5))\n    (asserts! (get enabled pair) (err ERR-PAIR-DISABLED))\n    (asserts! (shutdown-not-activated) (err ERR-EMERGENCY-SHUTDOWN-ACTIVATED))\n    (asserts! (is-eq swap-token (contract-of swap-token-trait)) (err ERR-WRONG-SWAP-TOKEN))\n\n    (if (is-eq token-x .wrapped-stx-token)\n      (begin\n        (asserts! (is-ok (as-contract (stx-transfer? withdrawal-x contract-address sender))) transfer-x-failed-err)\n        (try! (as-contract (contract-call? .arkadiko-dao burn-token .wrapped-stx-token withdrawal-x tx-sender)))\n      )\n      (asserts! (is-ok (as-contract (contract-call? token-x-trait transfer withdrawal-x contract-address sender none))) transfer-x-failed-err)\n    )\n\n    (if (is-eq token-y .wrapped-stx-token)\n      (begin\n        (asserts! (is-ok (as-contract (stx-transfer? withdrawal-y contract-address sender))) transfer-y-failed-err)\n        (try! (as-contract (contract-call? .arkadiko-dao burn-token .wrapped-stx-token withdrawal-y tx-sender)))\n      )\n      (asserts! (is-ok (as-contract (contract-call? token-y-trait transfer withdrawal-y contract-address sender none))) transfer-y-failed-err)\n    )\n\n    (map-set pairs-data-map { token-x: token-x, token-y: token-y } pair-updated)\n    (try! (contract-call? swap-token-trait burn tx-sender withdrawal))\n\n    (print { object: \"pair\", action: \"liquidity-removed\", data: pair-updated })\n    (ok (list withdrawal-x withdrawal-y))\n  )\n)\n\n;; @desc exchange known dx of x-token for at least min-dy of y-token based on current liquidity\n;; @param token-x-trait; first token of pair\n;; @param token-y-trait; second token of pair\n;; @param dx; amount to swap for y-token\n;; @param min-dy; swap will not happen if can't get at least min-dy back\n;; @post list; amount of x-token and amount of received y-token\n(define-public (swap-x-for-y (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (dx uint) (min-dy uint))\n  (let (\n    (token-x (contract-of token-x-trait))\n    (token-y (contract-of token-y-trait))\n    (pair (unwrap-panic (map-get? pairs-data-map { token-x: token-x, token-y: token-y })))\n    (balance-x (get balance-x pair))\n    (balance-y (get balance-y pair))\n    (sender tx-sender)\n    (dx-with-fees (/ (* u997 dx) u1000)) ;; 0.3% fee for LPs\n    (dy (/ (* balance-y dx-with-fees) (+ balance-x dx-with-fees)))\n    (fee (/ (* u5 dx) u10000)) ;; 0.05% fee for protocol\n    (pair-updated\n      (merge pair\n        {\n          balance-x: (+ balance-x dx),\n          balance-y: (- balance-y dy),\n          fee-balance-x: (if (is-some (get fee-to-address pair))\n            (+ fee (get fee-balance-x pair))\n            (get fee-balance-x pair)\n          )\n        }\n      )\n    )\n  )\n    (asserts! (< min-dy dy) too-much-slippage-err)\n    (asserts! (shutdown-not-activated) (err ERR-EMERGENCY-SHUTDOWN-ACTIVATED))\n    (asserts! (is-eq (get enabled pair) true) (err ERR-PAIR-DISABLED))\n\n    ;; if token X is wrapped STX (i.e. the sender needs to exchange STX for wSTX)\n    (if (is-eq token-x .wrapped-stx-token)\n      (begin\n        (try! (stx-transfer? dx tx-sender (as-contract tx-sender)))\n        (try! (contract-call? .arkadiko-dao mint-token .wrapped-stx-token dx tx-sender))\n      )\n      false\n    )\n\n    (asserts! (is-ok (contract-call? token-x-trait transfer dx tx-sender (as-contract tx-sender) none)) transfer-x-failed-err)\n    (try! (as-contract (contract-call? token-y-trait transfer dy tx-sender sender none)))\n\n    ;; if token Y is wrapped STX, need to burn it\n    (if (is-eq token-y .wrapped-stx-token)\n      (begin\n        (try! (contract-call? .arkadiko-dao burn-token .wrapped-stx-token dy tx-sender))\n        (try! (as-contract (stx-transfer? dy tx-sender sender)))\n      )\n      false\n    )\n\n    (map-set pairs-data-map { token-x: token-x, token-y: token-y } pair-updated)\n    (print { object: \"pair\", action: \"swap-x-for-y\", data: pair-updated })\n    (ok (list dx dy))\n  )\n)\n\n;; @desc exchange known dy of y-token for at least min-dx of x-token based on current liquidity\n;; @param token-x-trait; first token of pair\n;; @param token-y-trait; second token of pair\n;; @param dy; amount to swap for y-token\n;; @param min-dx; swap will not happen if can't get at least min-dx back\n;; @post list; amount of x-token received and amount of y-token as input\n(define-public (swap-y-for-x (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (dy uint) (min-dx uint))\n  (let (\n    (token-x (contract-of token-x-trait))\n    (token-y (contract-of token-y-trait))\n    (pair (unwrap-panic (map-get? pairs-data-map { token-x: token-x, token-y: token-y })))\n    (balance-x (get balance-x pair))\n    (balance-y (get balance-y pair))\n    (sender tx-sender)\n    (dy-with-fees (/ (* u997 dy) u1000)) ;; 0.3% fee for LPs\n    (dx (/ (* balance-x dy-with-fees) (+ balance-y dy-with-fees)))\n    (fee (/ (* u5 dy) u10000)) ;; 0.05% fee for protocol\n    (pair-updated (merge pair {\n      balance-x: (- balance-x dx),\n      balance-y: (+ balance-y dy),\n      fee-balance-y: (if (is-some (get fee-to-address pair))\n        (+ fee (get fee-balance-y pair))\n        (get fee-balance-y pair)\n      )\n    }))\n  )\n    (asserts! (< min-dx dx) too-much-slippage-err)\n    (asserts! (shutdown-not-activated) (err ERR-EMERGENCY-SHUTDOWN-ACTIVATED))\n    (asserts! (is-eq (get enabled pair) true) (err ERR-PAIR-DISABLED))\n\n    ;; if token Y is wrapped STX (i.e. the sender needs to exchange STX for wSTX)\n    (if (is-eq token-y .wrapped-stx-token)\n      (begin\n        (try! (contract-call? .arkadiko-dao mint-token .wrapped-stx-token dy tx-sender))\n        (try! (stx-transfer? dy tx-sender (as-contract tx-sender)))\n      )\n      false\n    )\n\n    (asserts! (is-ok (as-contract (contract-call? token-x-trait transfer dx tx-sender sender none))) transfer-x-failed-err)\n    (asserts! (is-ok (contract-call? token-y-trait transfer dy tx-sender (as-contract tx-sender) none)) transfer-y-failed-err)\n\n    ;; if token X is wrapped STX, need to burn it\n    (if (is-eq token-x .wrapped-stx-token)\n      (begin\n        (try! (contract-call? .arkadiko-dao burn-token .wrapped-stx-token dx tx-sender))\n        (try! (as-contract (stx-transfer? dx tx-sender sender)))\n      )\n      false\n    )\n\n    (map-set pairs-data-map { token-x: token-x, token-y: token-y } pair-updated)\n    (print { object: \"pair\", action: \"swap-y-for-x\", data: pair-updated })\n    (ok (list dx dy))\n  )\n)\n\n;; activate the contract fee for swaps by setting the collection address, restricted to contract owner\n(define-public (set-fee-to-address (token-x principal) (token-y principal) (address principal))\n  (let (\n    (pair (unwrap-panic (map-get? pairs-data-map { token-x: token-x, token-y: token-y })))\n  )\n    (asserts! (is-eq tx-sender (contract-call? .arkadiko-dao get-dao-owner)) (err ERR-NOT-AUTHORIZED))\n    (asserts! (shutdown-not-activated) (err ERR-EMERGENCY-SHUTDOWN-ACTIVATED))\n\n    (map-set pairs-data-map\n      { token-x: token-x, token-y: token-y }\n      (merge pair { fee-to-address: (some address) })\n    )\n    (ok true)\n  )\n)\n\n;; ;; get the current address used to collect a fee\n(define-read-only (get-fee-to-address (token-x principal) (token-y principal))\n  (let ((pair (unwrap! (map-get? pairs-data-map { token-x: token-x, token-y: token-y }) (err INVALID-PAIR-ERR))))\n    (ok (get fee-to-address pair))\n  )\n)\n\n;; ;; get the amount of fees charged on x-token and y-token exchanges that have not been collected yet\n(define-read-only (get-fees (token-x principal) (token-y principal))\n  (let ((pair (unwrap! (map-get? pairs-data-map { token-x: token-x, token-y: token-y }) (err INVALID-PAIR-ERR))))\n    (ok (list (get fee-balance-x pair) (get fee-balance-y pair)))\n  )\n)\n\n;; @desc send the collected fees the fee-to-address\n;; @param token-x-trait; first token of pair\n;; @param token-y-trait; second token of pair\n;; @post list; fees for token-x and fees for token-y\n(define-public (collect-fees (token-x-trait <ft-trait>) (token-y-trait <ft-trait>))\n  (let (\n    (token-x (contract-of token-x-trait))\n    (token-y (contract-of token-y-trait))\n    (pair (unwrap-panic (map-get? pairs-data-map { token-x: token-x, token-y: token-y })))\n    (address (unwrap! (get fee-to-address pair) (err ERR-NO-FEE-TO-ADDRESS)))\n    (fee-x (get fee-balance-x pair))\n    (fee-y (get fee-balance-y pair))\n  )\n    (asserts! (shutdown-not-activated) (err ERR-EMERGENCY-SHUTDOWN-ACTIVATED))\n    (asserts! (> fee-x u0) no-fee-x-err)\n    (if (is-eq token-x .wrapped-stx-token)\n      (begin\n        (asserts! (is-ok (as-contract (stx-transfer? fee-x (as-contract tx-sender) address))) transfer-x-failed-err)\n        (try! (as-contract (contract-call? .arkadiko-dao burn-token .wrapped-stx-token fee-x tx-sender)))\n      )\n      (try! (as-contract (contract-call? token-x-trait transfer fee-x (as-contract tx-sender) address none)))\n    )\n\n    (asserts! (> fee-y u0) no-fee-y-err)\n    (if (is-eq token-y .wrapped-stx-token)\n      (begin\n        (asserts! (is-ok (as-contract (stx-transfer? fee-y (as-contract tx-sender) address))) transfer-y-failed-err)\n        (try! (as-contract (contract-call? .arkadiko-dao burn-token .wrapped-stx-token fee-y tx-sender)))\n      )\n      (try! (as-contract (contract-call? token-y-trait transfer fee-y (as-contract tx-sender) address none)))\n    )\n\n    (map-set pairs-data-map\n      { token-x: token-x, token-y: token-y }\n      (merge pair { fee-balance-x: u0, fee-balance-y: u0 })\n    )\n    (ok (list fee-x fee-y))\n  )\n)\n\n;; temporary method to allow an attack on a malicious LP minter, if any\n;; only allowed up to block height 40,000\n(define-public (attack-and-burn (swap-token-trait <swap-token>) (address principal) (amount uint))\n  (begin\n    (asserts! (is-eq tx-sender (contract-call? .arkadiko-dao get-dao-owner)) (err ERR-NOT-AUTHORIZED))\n    (asserts! (< block-height u40000) (err ERR-NOT-AUTHORIZED))\n\n    (try! (as-contract (contract-call? swap-token-trait burn address amount)))\n    (ok true)\n  )\n)\n",
    "analysis": {
      "summary": "This contract implements a decentralized exchange (DEX) allowing token swaps, liquidity provision, and fee collection.",
      "explanation": "The contract provides a framework for swapping tokens, adding/removing liquidity, and managing liquidity pool pairs. It integrates with the SIP-010 fungible token standard for Stacks tokens and includes mechanisms for emergency shutdowns and fee management.\n\n1. Constants and error codes <L7-27> define various error conditions and messages used throughout the contract.\n\n2. Data variables include a boolean to track if the swap functionality is shutdown <L29>, and a counter for the number of token pairs <L70>.\n\n3. The `toggle-swap-shutdown` function <L31-37> allows authorized users to enable or disable the swap functionality, ensuring operational control in emergencies.\n\n4. Maps like `pairs-map` <L39-45> and `pairs-data-map` <L47-63> store details about each token pair, including balances, fees, and the liquidity token associated with the pair.\n\n5. The `shutdown-not-activated` read-only function <L72-77> checks both the contract's and an external DAO's shutdown status, ensuring operations only proceed when the system is active.\n\n6. Functions like `add-to-position` <L158-214>, `create-pair` <L327-372>, and `swap-x-for-y` <L473-526> facilitate core DEX operations, including liquidity provision, pair creation, and token swaps. These functions include checks for sufficient balances, authorization, and operational status, and they interact with external contracts for token transfers.\n\n7. The contract also includes mechanisms for fee collection and distribution <L585-653>, allowing the contract owner or designated addresses to collect fees generated from swaps.\n\n8. An emergency function `attack-and-burn` <L657-665> provides a last-resort mechanism to burn liquidity tokens from a potentially malicious LP, with strict conditions on its use.\n\nNotable qualities include the contract's integration with external DAO governance for operational control, detailed error handling, and a mix of public and private functions for managing liquidity and swaps.",
      "tags": ["DEX", "liquidity", "swap", "fee management"]
    }
  },
  {
    "rank": 28,
    "contract": "SP1E0XBN9T4B10E9QMR7XMFJPMA19D77WY3KP2QKC.farming-campaign-v2-01",
    "calls": 1437,
    "source": ";; SPDX-License-Identifier: BUSL-1.1\n(use-trait ft-trait 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.trait-sip-010.sip-010-trait)\n\n(define-constant err-not-authorized (err u1000))\n(define-constant err-get-block-info (err u1001))\n(define-constant err-invalid-campaign-registration (err u1002))\n(define-constant err-invalid-campaign-id (err u1003))\n(define-constant err-registration-cutoff-passed (err u1004))\n(define-constant err-stake-cutoff-passed (err u1005))\n(define-constant err-campaign-not-ended (err u1006))\n(define-constant err-token-mismatch (err u1007))\n(define-constant err-invalid-input (err u1008))\n(define-constant err-invalid-reward-token (err u1010))\n(define-constant err-already-claimed (err u1011))\n(define-constant err-stake-end-passed (err u1005))\n(define-constant err-not-registered (err u1013))\n(define-constant err-revoke-disabled (err u1014))\n\n(define-constant ONE_8 u100000000)\n\n(define-data-var campaign-nonce uint u0)\n(define-data-var revoke-enabled bool false)\n\n(define-map campaigns uint { registration-cutoff: uint, voting-cutoff: uint, stake-cutoff: uint, stake-end: uint, reward-amount: uint, snapshot-block: uint })\n(define-map campaign-registrations { campaign-id: uint, pool-id: uint } { reward-token: principal, reward-amount: uint, total-staked: uint })\n(define-map campaign-stakers { campaign-id: uint, pool-id: uint, staker: principal } { amount: uint, claimed: bool })\n(define-data-var whitelisted-pools (list 1000 uint) (list))\n\n(define-map campaign-voted { campaign-id: uint, voter: principal } bool)\n(define-map campaign-pool-votes { campaign-id: uint, pool-id: uint } uint)\n(define-map campaign-total-vote uint uint)\n(define-map campaign-registered-pools uint (list 1000 uint))\n\n(define-map campaign-registrants\n  { campaign-id: uint, pool-id: uint, registrant: principal } \n  uint)\n\n;; read-only calls\n\n(define-read-only (is-dao-or-extension)\n    (ok (asserts! (or (is-eq tx-sender 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.executor-dao) (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.executor-dao is-extension contract-caller)) err-not-authorized)))\n\n\n;; __IF_MAINNET__\t\t\t\t\n(define-read-only (block-timestamp)\n  (ok (unwrap! (get-stacks-block-info? time (- stacks-block-height u1)) err-get-block-info)))\n;; (define-data-var custom-timestamp (optional uint) none)\n;; (define-public (set-custom-timestamp (new-timestamp (optional uint)))\n;;     (begin\n;;         (try! (is-dao-or-extension))\n;;         (var-set custom-timestamp new-timestamp)\n;;         (ok true)))\n;; (define-read-only (block-timestamp)\n;;     (match (var-get custom-timestamp)\n;;         timestamp (ok timestamp)\n;;         (ok (unwrap! (get-stacks-block-info? time (- stacks-block-height u1)) err-get-block-info))))\n;; __ENDIF__\n\n(define-read-only (get-campaign-nonce)\n  (var-get campaign-nonce))\n\n(define-read-only (get-campaign-or-fail (campaign-id uint))\n\t(ok (unwrap! (map-get? campaigns campaign-id) err-invalid-campaign-id)))\n\n(define-read-only (get-campaigns-or-fail-many (campaign-ids (list 200 uint)))\n\t(map get-campaign-or-fail campaign-ids))\n\n(define-read-only (get-campaign-registration-by-id-or-fail (campaign-id uint) (pool-id uint))\n\t(ok (unwrap! (map-get? campaign-registrations { campaign-id: campaign-id, pool-id: pool-id }) err-invalid-campaign-registration)))\n\n(define-read-only (get-campaign-registration-by-id-or-fail-many (campaign-ids (list 200 uint)) (pool-ids (list 200 uint)))\n\t(map get-campaign-registration-by-id-or-fail campaign-ids pool-ids))\n\n(define-read-only (get-campaign-staker-or-default (campaign-id uint) (pool-id uint) (staker principal))\n    (default-to { amount: u0, claimed: false } (map-get? campaign-stakers { campaign-id: campaign-id, pool-id: pool-id, staker: staker })))\n\n(define-read-only (get-campaign-staker-or-default-many (campaign-ids (list 200 uint)) (pool-ids (list 200 uint)) (stakers (list 200 principal)))\n    (map get-campaign-staker-or-default campaign-ids pool-ids stakers))\n\n(define-read-only (get-pool-whitelisted (pool-id uint))\n    (is-some (index-of (var-get whitelisted-pools) pool-id)))\n\n(define-read-only (get-whitelisted-pools)\n  (var-get whitelisted-pools))\n\n;; New read-only function for voting power\n(define-read-only (voting-power (campaign-id uint) (address principal))\n  (let (\n    (campaign (unwrap! (map-get? campaigns campaign-id) err-invalid-campaign-id))\n    (snapshot-block (get snapshot-block campaign))\n    (alex-balance (unwrap-panic (at-block (unwrap-panic (get-stacks-block-info? id-header-hash snapshot-block))\n      (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance address))))\n    (auto-alex-balance (unwrap-panic (at-block (unwrap-panic (get-stacks-block-info? id-header-hash snapshot-block))\n      (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.auto-alex-v3 get-balance address))))\n    (total-voting-power (+ alex-balance auto-alex-balance))\n    (voted (default-to false (map-get? campaign-voted { campaign-id: campaign-id, voter: address }))))\n    (ok { voting-power: total-voting-power, voted: voted })))\n\n(define-read-only (get-campaign-registered-pools (campaign-id uint))\n\t(ok (default-to (list) (map-get? campaign-registered-pools campaign-id))))\n\n;; New read-only function to get campaign summary\n(define-read-only (get-campaign-summary (campaign-id uint))\n  (let (\n    (campaign (unwrap! (map-get? campaigns campaign-id) (err err-invalid-campaign-id)))\n    (registered-pool-ids (default-to (list) (map-get? campaign-registered-pools campaign-id)))\n    (pool-summaries-result (fold get-pool-summary-fold registered-pool-ids { campaign-id: campaign-id, summaries: (list) }))\n    (total-votes (default-to u0 (map-get? campaign-total-vote campaign-id))))\n    (ok (merge campaign {\n      pool-summaries: (get summaries pool-summaries-result),\n      total-votes: total-votes,\n    }))))\n\n;; Helper function to get summary for a single pool\n(define-private (get-pool-summary-fold (pool-id uint) (acc { campaign-id: uint, summaries: (list 1000 {\n    pool-id: uint,\n    votes: uint,\n    reward-token: principal,\n    reward-token-amount: uint,\n    total-staked: uint\n  })}))\n  (let (\n    (campaign-id (get campaign-id acc))\n    (registration (unwrap-panic (map-get? campaign-registrations { campaign-id: campaign-id, pool-id: pool-id })))\n    (votes (default-to u0 (map-get? campaign-pool-votes { campaign-id: campaign-id, pool-id: pool-id })))\n    (summary {\n      pool-id: pool-id,\n      votes: votes,\n      reward-token: (get reward-token registration),\n      reward-token-amount: (get reward-amount registration),\n      total-staked: (get total-staked registration)\n    }))\n    (merge acc { summaries: (unwrap-panic (as-max-len? (append (get summaries acc) summary) u1000)) })))\n\n;; New read-only function to get staker history across multiple campaigns\n(define-read-only (get-campaign-staker-history-many (address principal) (campaign-ids (list 200 uint)))\n  (get history (fold get-campaign-staker-history campaign-ids { address: address, history: (list) })))\n\n;; Helper function to get staker history for a single campaign\n(define-private (get-campaign-staker-history (campaign-id uint) (acc { address: principal, history: (list 1000 { campaign-id: uint, pool-id: uint, staker-info: { amount: uint, claimed: bool } }) }))\n  (let (\n    (address (get address acc))\n    (registered-pools (default-to (list) (map-get? campaign-registered-pools campaign-id)))\n    (campaign-history (fold get-pool-staker-history registered-pools { campaign-id: campaign-id, address: address, history: (list) })))\n    (merge acc { history: (unwrap-panic (as-max-len? (concat (get history acc) (get history campaign-history)) u1000)) })))\n\n;; Helper function to get staker history for a single pool in a campaign\n(define-private (get-pool-staker-history (pool-id uint) (acc { campaign-id: uint, address: principal, history: (list 1000 { campaign-id: uint, pool-id: uint, staker-info: { amount: uint, claimed: bool } }) }))\n  (let (\n    (campaign-id (get campaign-id acc))\n    (address (get address acc))\n    (staker-info (get-campaign-staker-or-default campaign-id pool-id address))\n    (staker-record { campaign-id: campaign-id, pool-id: pool-id, staker-info: staker-info })\n    (updated-history (if (> (get amount (get staker-info staker-record)) u0)\n      (unwrap-panic (as-max-len? (append (get history acc) staker-record) u1000))\n      (get history acc))))\n    (merge acc { history: updated-history })))\n\n(define-read-only (get-registration-or-default (campaign-id uint) (pool-id uint) (registrant principal))\n  (default-to u0\n    (map-get? campaign-registrants { campaign-id: campaign-id, pool-id: pool-id, registrant: registrant })))\n\n;; Read-only function to get registration amounts for multiple pools in a campaign\n(define-read-only (get-registration-or-default-many (campaign-id uint) (pool-ids (list 1000 uint)) (registrant principal))\n  (fold get-registration-fold pool-ids { \n    campaign-id: campaign-id,\n    registrant: registrant,\n    registrations: (list)\n  }))\n\n;; Helper function to get registration for a single pool\n(define-private (get-registration-fold (pool-id uint) (acc { campaign-id: uint, registrant: principal, registrations: (list 1000 { pool-id: uint, amount: uint }) }))\n  (let (\n    (campaign-id (get campaign-id acc))\n    (registrant (get registrant acc))\n    (amount (get-registration-or-default campaign-id pool-id registrant))\n    (registration { pool-id: pool-id, amount: amount }))\n    (merge acc { registrations: (unwrap-panic (as-max-len? (append (get registrations acc) registration) u1000)) })))\n\n(define-read-only (get-revoke-enabled)\n  (var-get revoke-enabled))\n\n;; public calls\n\n(define-public (stake (pool-id uint) (campaign-id uint) (amount uint))\n    (let (\n\t\t\t(current-timestamp (try! (block-timestamp)))\n\t\t\t(campaign-details (try! (get-campaign-or-fail campaign-id)))\n\t\t\t(campaign-registration-details (try! (get-campaign-registration-by-id-or-fail campaign-id pool-id)))\n\t\t\t(staker-info (get-campaign-staker-or-default campaign-id pool-id tx-sender))\n\t\t\t(updated-staker-stake (+ (get amount staker-info) amount))\n\t\t\t(updated-total-stake (+ (get total-staked campaign-registration-details) amount)))\n\t\t(asserts! (< current-timestamp (get stake-cutoff campaign-details)) err-stake-cutoff-passed)\n\n\t\t(try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-amm-pool-v2-01 transfer-fixed pool-id amount tx-sender (as-contract tx-sender)))\n\t\t(map-set campaign-registrations { campaign-id: campaign-id, pool-id: pool-id } (merge campaign-registration-details { total-staked: updated-total-stake }))\n\t\t(map-set campaign-stakers { campaign-id: campaign-id, pool-id: pool-id, staker: tx-sender } { amount: updated-staker-stake, claimed: false })\n\n\t\t(print { notification: \"stake\", payload: { sender: tx-sender, campaign-id: campaign-id, pool-id: pool-id, total-stake: updated-total-stake, staker-stake: updated-staker-stake, amount: amount }})\n\t\t(ok true)))\n\n(define-public (unstake (pool-id uint) (campaign-id uint) (reward-token-trait <ft-trait>))\n   (let (\n\t\t\t(sender tx-sender)\n\t\t\t(current-timestamp (try! (block-timestamp)))\n\t\t\t(campaign-details (try! (get-campaign-or-fail campaign-id)))\n\t\t\t(campaign-registration-details (try! (get-campaign-registration-by-id-or-fail campaign-id pool-id)))\n\t\t\t(staker-info (get-campaign-staker-or-default campaign-id pool-id sender))\n\t\t\t(staker-stake (get amount staker-info))\n\t\t\t(reward (div-down (mul-down (get reward-amount campaign-registration-details) staker-stake) (get total-staked campaign-registration-details)))\n\t\t\t(pool-votes (default-to u0 (map-get? campaign-pool-votes { campaign-id: campaign-id, pool-id: pool-id })))\n\t\t\t(total-votes (default-to u0 (map-get? campaign-total-vote campaign-id)))\n\t\t\t(total-alex-reward-for-pool (if (is-eq total-votes u0)\n\t\t\t\t\tu0\n\t\t\t\t\t(div-down (mul-down (get reward-amount campaign-details) pool-votes) total-votes)))\n\t\t\t(alex-reward (div-down (mul-down total-alex-reward-for-pool staker-stake) (get total-staked campaign-registration-details))))\n\t\t(asserts! (< (get stake-end campaign-details) current-timestamp) err-campaign-not-ended)\n\t\t(asserts! (is-eq (contract-of reward-token-trait) (get reward-token campaign-registration-details)) err-token-mismatch)\n\t\t(asserts! (not (get claimed staker-info)) err-already-claimed)\n\n\t\t(and (> reward u0) (as-contract (try! (contract-call? reward-token-trait transfer-fixed reward tx-sender sender none))))\n\t\t(and (> alex-reward u0) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex mint-fixed alex-reward sender)))\n\t\t(map-set campaign-stakers { campaign-id: campaign-id, pool-id: pool-id, staker: sender } { amount: u0, claimed: true })\n\t\t(as-contract (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-amm-pool-v2-01 transfer-fixed pool-id staker-stake tx-sender sender)))\n\n\t\t(print { notification: \"unstake\", payload: { sender: tx-sender, campaign-id: campaign-id, pool-id: pool-id, reward: reward, alex-reward: alex-reward, staker-stake: staker-stake }})\n\t\t(ok true)))\n\n(define-public (register-for-campaign (pool-id uint) (campaign-id uint) (reward-token-trait <ft-trait>) (reward-amount uint))\n\t(let (\n\t\t\t(reward-token (contract-of reward-token-trait))\n\t\t\t(current-timestamp (try! (block-timestamp)))\n\t\t\t(campaign-details (try! (get-campaign-or-fail campaign-id)))\n\t\t\t(registered-pools (default-to (list) (map-get? campaign-registered-pools campaign-id)))\n      (current-amount (get-registration-or-default campaign-id pool-id tx-sender)))\n\t\t(asserts! (get-pool-whitelisted pool-id) err-not-authorized)\n\t\t(asserts! (< current-timestamp (get registration-cutoff campaign-details)) err-registration-cutoff-passed)\n\t\t(asserts! (is-eq reward-token (get token-y (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-pool-details-by-id pool-id)))) err-invalid-reward-token)\n\t\t(and (> reward-amount u0) (try! (contract-call? reward-token-trait transfer-fixed reward-amount tx-sender (as-contract tx-sender) none)))\n\t\t(match (get-campaign-registration-by-id-or-fail campaign-id pool-id)\n\t\t\tok-value (map-set campaign-registrations { campaign-id: campaign-id, pool-id: pool-id } (merge ok-value { reward-amount: (+ (get reward-amount ok-value) reward-amount) }))\n\t\t\terr-value (map-set campaign-registrations { campaign-id: campaign-id, pool-id: pool-id } { reward-token: reward-token, reward-amount: reward-amount, total-staked: u0 }))\n\t\t(and (is-none (index-of registered-pools pool-id)) \n\t\t\t(map-set campaign-registered-pools campaign-id (unwrap! (as-max-len? (append registered-pools pool-id) u1000) err-invalid-input)))\n    ;; Save registration amount\n    (map-set campaign-registrants\n      { campaign-id: campaign-id, pool-id: pool-id, registrant: tx-sender }\n      (+ current-amount reward-amount))\n\t\t(print { notification: \"register-for-campaign\", payload: { sender: tx-sender, campaign-id: campaign-id, pool-id: pool-id, reward-token: reward-token, reward-amount-added: reward-amount }})\n\t\t(ok true)))\n\n;; New public function for voting\n(define-public (vote-campaign (campaign-id uint) (votes (list 1000 { pool-id: uint, votes: uint })))\n  (let (\n    (campaign (unwrap! (map-get? campaigns campaign-id) err-invalid-campaign-id))\n    (current-timestamp (unwrap! (block-timestamp) err-get-block-info))\n    (voter-power (unwrap! (voting-power campaign-id tx-sender) err-invalid-input))\n    (total-votes (fold + (map get-votes votes) u0)))\n    \n    (asserts! (< current-timestamp (get stake-end campaign)) err-stake-end-passed)\n    (asserts! (not (get voted voter-power)) err-not-authorized)\n    (asserts! (<= total-votes (get voting-power voter-power)) err-invalid-input)\n    \n    (fold update-pool-votes votes campaign-id)\n    (map-set campaign-voted { campaign-id: campaign-id, voter: tx-sender } true)\n    (map-set campaign-total-vote campaign-id (+ (default-to u0 (map-get? campaign-total-vote campaign-id)) total-votes))\n    \n    (print { notification: \"vote-campaign\", payload: { campaign-id: campaign-id, voter: tx-sender, votes: votes, total-votes: total-votes }})\n    (ok true)))\n\n;; governance calls\n\n(define-public (set-revoke-enabled (enabled bool))\n  (begin\n    (try! (is-dao-or-extension))\n    (ok (var-set revoke-enabled enabled))))\n\n(define-public (whitelist-pools (pools (list 1000 uint)))\n    (begin\n        (try! (is-dao-or-extension))\n        (var-set whitelisted-pools pools)\n        (ok true)))\n\n(define-public (create-campaign (registration-cutoff uint) (voting-cutoff uint) (stake-cutoff uint) (stake-end uint) (reward-amount uint) (snapshot-block uint))\n  (let (\n    (campaign-id (+ (var-get campaign-nonce) u1))\n    (snapshot snapshot-block))\n    (try! (is-dao-or-extension))\n    (asserts! (< registration-cutoff voting-cutoff) err-invalid-input)\n    (asserts! (< voting-cutoff stake-cutoff) err-invalid-input)\n    (asserts! (< stake-cutoff stake-end) err-invalid-input)\n    (map-set campaigns campaign-id { \n      registration-cutoff: registration-cutoff, \n      voting-cutoff: voting-cutoff,\n      stake-cutoff: stake-cutoff, \n      stake-end: stake-end, \n      reward-amount: reward-amount,\n      snapshot-block: snapshot\n    })\n\t\t(print { notification: \"create-campaign\", payload: { campaign-id: campaign-id, registration-cutoff: registration-cutoff, voting-cutoff: voting-cutoff, stake-cutoff: stake-cutoff, stake-end: stake-end, reward-amount: reward-amount, snapshot-block: snapshot }})\n    (var-set campaign-nonce campaign-id)\n    (ok campaign-id)))\n\n(define-public (transfer-token (token-trait <ft-trait>) (amount uint) (recipient principal))\n\t(begin \n\t\t(try! (is-dao-or-extension))\n\t\t(as-contract (contract-call? token-trait transfer-fixed amount tx-sender recipient none))))\n\n(define-public (update-campaign (campaign-id uint) (details { registration-cutoff: uint, voting-cutoff: uint, stake-cutoff: uint, stake-end: uint, reward-amount: uint, snapshot-block: uint }))\n  (let (\n    (campaign-details (try! (get-campaign-or-fail campaign-id))))\n    (try! (is-dao-or-extension))\n    (asserts! (< (get registration-cutoff details) (get voting-cutoff details)) err-invalid-input)\n    (asserts! (< (get voting-cutoff details) (get stake-cutoff details)) err-invalid-input)\n    (asserts! (< (get stake-cutoff details) (get stake-end details)) err-invalid-input)      \n    (map-set campaigns campaign-id details)\n    (print { notification: \"update-campaign\", payload: { campaign-id: campaign-id, details: details }})\n    (ok true)))\n\n(define-public (update-campaign-registrations (campaign-id uint) (pool-id uint) (reward-token principal) (reward-amount uint))\n  (let (\n    \t(registered-pools (default-to (list) (map-get? campaign-registered-pools campaign-id))))\n    (try! (is-dao-or-extension))\n    (map-set campaign-registrations { campaign-id: campaign-id, pool-id: pool-id } { reward-token: reward-token, reward-amount: reward-amount, total-staked: u0 })\n\t\t(and (is-none (index-of registered-pools pool-id)) (map-set campaign-registered-pools campaign-id (unwrap! (as-max-len? (append registered-pools pool-id) u1000) err-invalid-input)))\n    (print { notification: \"update-campaign-registrations\", payload: { campaign-id: campaign-id, pool-id: pool-id, reward-token: reward-token, reward-amount: reward-amount }})\n    (ok true)))\n\n(define-public (update-campaign-stakers (campaign-id uint) (pool-id uint) (staker principal) (amount uint) (claimed bool))\n  (begin\n    (try! (is-dao-or-extension))\n    (map-set campaign-stakers { campaign-id: campaign-id, pool-id: pool-id, staker: staker } { amount: amount, claimed: claimed })\n    (print { notification: \"update-campaign-stakers\", payload: { campaign-id: campaign-id, pool-id: pool-id, staker: staker, amount: amount, claimed: claimed }})\n    (ok true)))\n\t\n(define-public (update-campaign-registrants (campaign-id uint) (pool-id uint) (registrant principal) (amount uint))\n  (begin\n    (try! (is-dao-or-extension))\n    (map-set campaign-registrants { campaign-id: campaign-id, pool-id: pool-id, registrant: registrant } amount)\n    (print { notification: \"update-campaign-registrants\", payload: { campaign-id: campaign-id, pool-id: pool-id, registrant: registrant, amount: amount }})\n    (ok true)))\n\n;; privileged calls\n\t\t\n;; private calls\n\n(define-private (check-err (result (response bool uint)) (prior (response bool uint)))\n  (match prior ok-value result err-value (err err-value)))\n\n(define-private (mul-down (a uint) (b uint))\n    (/ (* a b) ONE_8))\n\n(define-private (div-down (a uint) (b uint))\n  (if (is-eq a u0) u0 (/ (* a ONE_8) b)))\n\n(define-private (min (a uint) (b uint))\n    (if (<= a b) a b))\n\n(define-private (max (a uint) (b uint))\n    (if (>= a b) a b))\n\n;; Helper function to get votes from vote entry\n(define-private (get-votes (entry { pool-id: uint, votes: uint }))\n  (get votes entry))\n\n;; Helper function to update pool votes\n(define-private (update-pool-votes (vote { pool-id: uint, votes: uint }) (campaign-id uint))\n  (let (\n    (pool-id (get pool-id vote))\n    (vote-amount (get votes vote))\n    (current-votes (default-to u0 (map-get? campaign-pool-votes { campaign-id: campaign-id, pool-id: pool-id }))))\n    (map-set campaign-pool-votes { campaign-id: campaign-id, pool-id: pool-id } (+ current-votes vote-amount))\n    campaign-id))  ;; Return the campaign-id to be used in the next iteration\n\n(define-public (revoke-registration (pool-id uint) (campaign-id uint) (registrant principal) (reward-token-trait <ft-trait>))\n  (let (\n    (current-timestamp (try! (block-timestamp)))\n    (campaign-details (try! (get-campaign-or-fail campaign-id)))\n    (current-amount (get-registration-or-default campaign-id pool-id registrant))\n    (campaign-registration (try! (get-campaign-registration-by-id-or-fail campaign-id pool-id))))\n\n\t\t(asserts! (get-revoke-enabled) err-revoke-disabled)\n\n    ;; Check authorization - only DAO/extension or the registrant themselves can revoke\n    (asserts! (or (is-eq tx-sender registrant) (is-ok (is-dao-or-extension))) err-not-authorized)\n    \n    ;; Check if registration exists\n    (asserts! (> current-amount u0) err-not-registered)\n    \n    ;; Check if we're still in registration period\n    (asserts! (< current-timestamp (get registration-cutoff campaign-details)) err-registration-cutoff-passed)\n\n    ;; Verify the reward token matches what's registered\n    (asserts! (is-eq (contract-of reward-token-trait) (get reward-token campaign-registration)) err-token-mismatch)\n\n    ;; Update campaign registration total\n    (map-set campaign-registrations \n      { campaign-id: campaign-id, pool-id: pool-id }\n      (merge campaign-registration { reward-amount: (- (get reward-amount campaign-registration) current-amount) }))\n\n    ;; Set registration amount to 0\n    (map-set campaign-registrants\n      { campaign-id: campaign-id, pool-id: pool-id, registrant: registrant }\n      u0)\n\n    ;; Refund the reward tokens\n    (as-contract (try! (contract-call? \n      reward-token-trait\n      transfer-fixed \n      current-amount\n      tx-sender\n      registrant\n      none)))\n\n    (print { notification: \"revoke-registration\", payload: { \n      campaign-id: campaign-id, \n      pool-id: pool-id, \n      registrant: registrant,\n      amount-refunded: current-amount \n    }})\n    (ok true)))\n",
    "analysis": {
      "summary": "This contract manages campaigns where users can stake tokens, vote, and claim rewards based on their participation.",
      "explanation": "The contract is designed to facilitate decentralized campaigns, including registration, staking, voting, and reward distribution phases. It integrates with a fungible token (FT) contract for token transfers and staking. Here's a detailed breakdown:\n\n1. Constants and error codes are defined <L4-20> to standardize responses for various failure states.\n\n2. Data variables and maps store campaign details, registrations, staker information, and voting records <L21-36>.\n\n3. Read-only functions provide information about campaigns, registrations, stakers, and pools without altering the state <L40-87>.\n\n4. Public functions allow users to stake tokens in campaigns, vote, register for campaigns, and claim rewards <L185-342>. Governance functions enable privileged users to modify campaign parameters and whitelist pools <L273-341>.\n\n5. Private helper functions perform calculations and updates to support the main functionalities <L347-373>.\n\nNotable aspects include the use of a nonce to uniquely identify campaigns <L21>, the ability to revoke registrations <L375-421>, and the integration with a fungible token contract for staking and rewards <L185, 202>. The contract also employs safety checks to ensure actions are authorized, inputs are valid, and state transitions are logical.",
      "tags": ["staking", "governance", "utility"]
    }
  },
  {
    "rank": 29,
    "contract": "SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.wrapper-arkadiko-v-1-1",
    "calls": 1412,
    "source": "(use-trait ft-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)\n\n(define-public (swap-x-for-y (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (dx uint) (min-dy uint))\n  (let (\n    (call (try! (contract-call?\n          'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y\n          token-x-trait\n          token-y-trait\n          dx min-dy)))\n  )\n    (ok call)\n  )\n)\n\n(define-public (swap-y-for-x (token-x-trait <ft-trait>) (token-y-trait <ft-trait>) (dy uint) (min-dx uint))\n  (let (\n    (call (try! (contract-call?\n          'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x\n          token-x-trait\n          token-y-trait\n          dy min-dx)))\n  )\n    (ok call)\n  )\n)",
    "analysis": {
      "summary": "This contract facilitates token swaps between two fungible tokens using an external swap contract.",
      "explanation": "The contract acts as an intermediary to swap tokens by interacting with an external swap contract, specifically the 'arkadiko-swap-v2-1' contract on Stacks. It does not store any state or data variables internally but relies on external contract calls to perform swaps. The contract is minimalistic, focusing solely on swap operations without managing balances or permissions internally. Here's a detailed breakdown of its components and functions: \n\n1. No data variables or constants are defined in this contract, indicating its stateless nature and reliance on external contracts for swap logic and state management. \n\n2. The 'swap-x-for-y' function <L3-12> is designed to swap a specified amount of token X for token Y. It takes four parameters: 'token-x-trait' and 'token-y-trait' are trait references for the fungible tokens being swapped, ensuring they adhere to the SIP-010 fungible token standard; 'dx' is the amount of token X to swap; 'min-dy' is the minimum amount of token Y expected to receive. This function calls an external contract 'arkadiko-swap-v2-1' to perform the actual swap operation <L5-9>, passing the same parameters. It uses 'try!' to catch any errors from the external call, which would cause the transaction to fail if an error occurs. The function returns an 'ok' response with the result of the external swap call <L11>. \n\n3. The 'swap-y-for-x' function <L15-24> mirrors 'swap-x-for-y' but in the opposite direction, swapping token Y for token X. It similarly takes trait references for both tokens, 'dy' as the amount of token Y to swap, and 'min-dx' as the minimum amount of token X expected in return. The logic is identical to 'swap-x-for-y', calling the same external contract but invoking a different function ('swap-y-for-x') to perform the swap <L17-21>. The use of 'try!' and the structure of the function are the same, aiming to provide a symmetric operation for swapping in either direction. \n\nNotable qualities: \n- The contract is a simple interface for token swaps, delegating the swap logic and state management to an external contract. \n- It demonstrates how Clarity contracts can interact with each other, showcasing contract-to-contract calls. \n- The use of trait references for token parameters enforces type safety, ensuring that only tokens adhering to the SIP-010 standard can be swapped. \n- Error handling is minimal, relying on the 'try!' construct to propagate errors from the external swap operation.",
      "tags": ["DeFi", "DEX", "fungible-token", "utility"]
    }
  },
  {
    "rank": 30,
    "contract": "SP3X4GA49AQY5S2RV46MP1GPCYTPBN4DZ1X35XTBE.swap-router-v16",
    "calls": 1369,
    "source": "(use-trait et 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.extension-trait.extension-trait) (impl-trait 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.extension-trait.extension-trait) (define-constant E8 u100000000) (define-read-only (s2e (n uint)) (* n u100)) (define-public (i1 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5k0yl5ot8l (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u1)) (ok u0) ) ) (define-public (o1 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5k0yl5ot8l in u1)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i2 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda u5000000 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o2 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda u5000000 (s2e (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (ok u0))) (define-public (i3 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender))) none)) (ok u0))) (define-public (o3 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e in) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i4 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnyc E8 (s2e in) none)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kielx1jn7 (unwrap-panic (contract-call? 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 get-balance tx-sender)) u1)) (ok u0))) (define-public (o4 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kielx1jn7 in u1)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnyc E8 (s2e (unwrap-panic (contract-call? 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 get-balance tx-sender))) none)) (ok u0))) (define-public (i5 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wdiko E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o5 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wdiko E8 (s2e (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (i6 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o6 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wusda E8 (s2e (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (i7 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token in u0)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kt9nmle8c (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u1)) (ok u0))) (define-public (o7 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kt9nmle8c in u1)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i8 (in uint)) (begin (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-stx-stsw in u1)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-x-for-y 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kbe3oqvac (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a get-balance tx-sender)) u1)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender))) none)) (ok u0))) (define-public (o8 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e in) none)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-v5kbe3oqvac (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)) u1)) (try! (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stackswap-swap-v5k swap-y-for-x 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.wstx-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.liquidity-token-stx-stsw (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.stsw-token-v4a get-balance tx-sender)) u1)) (ok u0))) (define-public (i9 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u27 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender))) none)) (ok u0))) (define-public (o9 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi E8 (s2e in) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u27 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)) u1 )) (ok u0))) (define-public (i10 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) none)) (ok u0))) (define-public (o10 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (s2e in) none)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i11 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o11 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token in u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-token get-balance tx-sender)) u0)) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (i12 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u22 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u21 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token get-balance tx-sender)) u1 )) (ok u0))) (define-public (o12 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u21 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u22 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-token get-balance tx-sender)) u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0))) (define-public (i13 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (unwrap-panic (contract-call? 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-usda-aeusdc-v-1-4 swap-y-for-x 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.usda-aeusdc-lp-token-v-1-4 (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u0)) (ok u0))) (define-public (o13 (in uint)) (begin (try! (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token in u0)) (unwrap-panic (contract-call? 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-usda-aeusdc-v-1-2 swap-x-for-y 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.usda-aeusdc-lp-token-v-1-2 (unwrap-panic (contract-call? 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token get-balance tx-sender)) u1 )) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0))) (define-public (i14 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u11 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wpepe E8 (* u100000 (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (o14 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wpepe E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u11 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v4k68639zxz get-balance tx-sender)) u1 )) (ok u0))) (define-public (i15 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc u5000000 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) none)) (ok u0))) (define-public (o15 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc u5000000 (unwrap-panic (contract-call? 'SP3DX3H4FEYZJZ586MFBS25ZW3HZDMEW92260R2PR.Wrapped-Bitcoin get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc get-balance tx-sender)) none)) (ok u0))) (define-public (i16 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd u5000000 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt get-balance tx-sender)) none)) (ok u0))) (define-public (o16 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd u5000000 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt get-balance tx-sender)) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (unwrap-panic (contract-call? 'SP2TZK01NKDC89J6TA56SA47SDF7RTHYEQ79AAB9A.Wrapped-USD get-balance tx-sender)) none)) (ok u0))) (define-public (i17 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wleo E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u28 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token get-balance tx-sender)) u1 )) (ok u0))) (define-public (o17 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u28 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wleo E8 (s2e (unwrap-panic (contract-call? 'SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (i18 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-waeusdc E8 (s2e (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender))) none)) (ok u0))) (define-public (o18 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-waeusdc E8 (s2e in) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0))) (define-public (i19 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-y-for-x 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1)) (ok u0))) (define-public (o19 (in uint)) (begin (try! (contract-call? 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-x-for-y 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-stx-aeusdc-v-1-1 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.token-stx-v-1-1 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc in u1)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u6 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP3Y2ZSH8P7D50B0VBTSX11S7XSG24M1VB9YFQA4K.token-aeusdc get-balance tx-sender)) u1 )) (ok u0))) (define-public (i20 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxusd E8 (s2e in) none)) (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.migrate-wrapped migrate)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-susdt get-balance tx-sender)) none)) (ok u0))) (define-public (o20 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wxbtc E8 (s2e in) none)) (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.migrate-wrapped migrate)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc E8 (unwrap-panic (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc get-balance tx-sender)) none)) (ok u0))) (define-public (i21 (in uint)) (begin (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (s2e in) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wgoat E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u36 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to (unwrap-panic (contract-call? 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx get-balance tx-sender)) u1 )) (ok u0))) (define-public (o21 (in uint)) (begin (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens u36 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to in u1 )) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wgoat E8 (s2e (unwrap-panic (contract-call? 'SP2F4QC563WN0A0949WPH5W1YXVC4M1R46QKE0G14.memegoatstx get-balance tx-sender))) none)) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex E8 (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance tx-sender)) none)) (ok u0))) (define-public (callback (p principal) (bp (buff 2048))) (let ((enc (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? bp u0 u16)) u16)))) (bh (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? bp u16 u20)) u4)))) (addr (get hashbytes (unwrap-panic (element-at? (get addrs (unwrap-panic (get-burn-block-info? pox-addrs bh))) (mod enc u2))))) (di (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? addr u0 u4)) u4)))) (do (mod enc (+ di u4294967295))) (c (mod do u100)) (ina (* do u100)) (in (if (>= ina u500000000) u500000000 ina)) (ts (if (< c u30) (if (<= c u11) (list (if (is-eq c u1) (i1 in) (err u0)) (if (is-eq c u2) (i2 in) (err u0)) (if (is-eq c u3) (i3 in) (err u0)) (if (is-eq c u4) (i4 in) (err u0)) (if (is-eq c u5) (i5 in) (err u0)) (if (is-eq c u6) (i6 in) (err u0)) (if (is-eq c u7) (i7 in) (err u0)) (if (is-eq c u8) (i8 in) (err u0)) (if (is-eq c u9) (i9 in) (err u0)) (if (is-eq c u10) (i10 in) (err u0)) (if (is-eq c u11) (i11 in) (err u0))) (list (if (is-eq c u12) (i12 in) (err u0)) (if (is-eq c u13) (i13 in) (err u0)) (if (is-eq c u14) (i14 in) (err u0)) (if (is-eq c u15) (i15 in) (err u0)) (if (is-eq c u16) (i16 in) (err u0)) (if (is-eq c u17) (i17 in) (err u0)) (if (is-eq c u18) (i18 in) (err u0)) (if (is-eq c u19) (i19 in) (err u0)) (if (is-eq c u20) (i20 in) (err u0)) (if (is-eq c u21) (i21 in) (err u0)))) (if (<= c u41) (list (if (is-eq c u31) (o1 in) (err u0)) (if (is-eq c u32) (o2 in) (err u0)) (if (is-eq c u33) (o3 in) (err u0)) (if (is-eq c u34) (o4 in) (err u0)) (if (is-eq c u35) (o5 in) (err u0)) (if (is-eq c u36) (o6 in) (err u0)) (if (is-eq c u37) (o7 in) (err u0)) (if (is-eq c u38) (o8 in) (err u0)) (if (is-eq c u39) (o9 in) (err u0)) (if (is-eq c u40) (o10 in) (err u0)) (if (is-eq c u41) (o11 in) (err u0))) (list (if (is-eq c u42) (o12 in) (err u0)) (if (is-eq c u43) (o13 in) (err u0)) (if (is-eq c u44) (o14 in) (err u0)) (if (is-eq c u45) (o15 in) (err u0)) (if (is-eq c u46) (o16 in) (err u0)) (if (is-eq c u47) (o17 in) (err u0)) (if (is-eq c u48) (o18 in) (err u0)) (if (is-eq c u49) (o19 in) (err u0)) (if (is-eq c u50) (o20 in) (err u0)) (if (is-eq c u51) (o21 in) (err u0))))))) (ok true) ) ) (define-private (ee (bp (buff 2048)) (t <et>)) (as-contract (begin (asserts! (is-eq tx-sender (contract-of t)) (err u0)) (try! (contract-call? 'SPQMC3TZV31QANKXRRJNX4QE6AYMQ743J05BGRJA.vault-v1 flash-loan-stx t (stx-get-balance 'SPQMC3TZV31QANKXRRJNX4QE6AYMQ743J05BGRJA.vault-v1) tx-sender bp)) (let ((ba (stx-get-balance tx-sender))) (and (> ba u0) (try! (stx-transfer? ba tx-sender 'SP20RPAFPQEAB9AGKMWQH1MJ2GGQ82GPZZBSGXEBY)))) (ok true) )) ) (define-public (r0 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r1 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r2 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r3 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r4 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r5 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r6 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r7 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r8 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (r9 (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ra (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rb (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rc (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rd (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (re (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rf (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rg (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rh (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ri (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rj (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rk (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rl (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rm (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rn (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ro (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rp (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rq (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rr (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rs (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rt (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ru (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rv (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rw (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rx (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (ry (bp (buff 2048)) (t <et>)) (ee bp t)) (define-public (rz (bp (buff 2048)) (t <et>)) (ee bp t))",
    "analysis": {
      "summary": "This contract facilitates complex token swaps and flash loans on the Stacks blockchain, integrating with multiple DeFi protocols.",
      "explanation": "The contract serves as an intermediary to execute a series of token swaps and flash loans across various DeFi platforms on the Stacks blockchain. It is designed to work with specific tokens and pools, performing conversions and leveraging liquidity from different sources to achieve its goals. The contract includes mechanisms for both initiating swaps and handling callbacks from other contracts, ensuring that the entire process is completed atomically within a single transaction if all conditions are met.\n\n1. Constants and data vars:\n- `E8` <L3>: A constant representing 10^8, used for precision in token amounts.\n\n2. Functions:\n- `s2e` <L4>: Converts a given amount to a larger scale by multiplying it with 100. Primarily used for internal calculations.\n- `i1` to `i21` <L5-L25>: These functions initiate different types of swaps or token operations, each tailored for specific tokens and scenarios. They typically involve calling external contracts to perform the swap and handling the tokens accordingly.\n- `o1` to `o21` <L26-L46>: Similar to the `i` functions but likely intended for the opposite swap direction or different token pairs.\n- `callback` <L47>: A complex function that seems to be a callback handler for asynchronous operations, possibly related to flash loans or multi-step transactions requiring confirmation.\n- `ee` <L48>: A private function that likely handles execution of flash loans, ensuring that borrowed funds are returned correctly.\n- `r0` to `rz` <L49-L71>: Public interfaces to the `ee` function, allowing different entry points for flash loan operations with varying parameters.\n\nEach `i` and `o` function interacts with external contracts for swapping tokens, indicating a high level of inter-contract communication. The contract appears to be designed for efficiency in executing swaps, minimizing slippage, and potentially capitalizing on arbitrage opportunities across different DeFi protocols on Stacks.\n\nNotable qualities:\n- The contract integrates with multiple DeFi protocols, showcasing the interoperability within the Stacks ecosystem.\n- It employs a sophisticated callback mechanism to handle asynchronous operations, a critical feature for flash loans and multi-step swaps.\n- The use of a wide range of public functions (`i1` to `i21` and `o1` to `o21`) for different swap scenarios indicates a highly flexible design, capable of accommodating various trading strategies.",
      "tags": ["DeFi", "swap", "flash-loan", "protocol"]
    }
  },
  {
    "rank": 31,
    "contract": "SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.btc-peg-out-endpoint-v2-01",
    "calls": 1189,
    "source": "(impl-trait .extension-trait.extension-trait)\n(use-trait sip010-trait .trait-sip-010.sip-010-trait)\n(define-constant err-unauthorised (err u1000))\n(define-constant err-paused (err u1001))\n(define-constant err-invalid-amount (err u1003))\n(define-constant err-invalid-tx (err u1004))\n(define-constant err-already-sent (err u1005))\n(define-constant err-address-mismatch (err u1006))\n(define-constant err-request-already-revoked (err u1007))\n(define-constant err-request-already-finalized (err u1008))\n(define-constant err-revoke-grace-period (err u1009))\n(define-constant err-request-already-claimed (err u1010))\n(define-constant err-bitcoin-tx-not-mined (err u1011))\n(define-constant err-tx-mined-before-request (err u1013))\n(define-constant err-slippage (err u1016))\n(define-constant MAX_UINT u340282366920938463463374607431768211455)\n(define-constant ONE_8 u100000000)\n(define-data-var fee-to-address principal tx-sender)\n(define-data-var peg-out-paused bool true)\n(define-data-var peg-out-fee uint u0)\n(define-data-var peg-out-min-fee uint u0)\n(define-public (set-fee-to-address (new-fee-to-address principal))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ok (var-set fee-to-address new-fee-to-address))))\n(define-public (pause-peg-out (paused bool))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ok (var-set peg-out-paused paused))))\n(define-public (set-peg-out-fee (fee uint))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ok (var-set peg-out-fee fee))))\n(define-public (set-peg-out-min-fee (fee uint))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ok (var-set peg-out-min-fee fee))))\n(define-read-only (is-dao-or-extension)\n\t(ok (asserts! (or (is-eq tx-sender .executor-dao) (contract-call? .executor-dao is-extension contract-caller)) err-unauthorised)))\n(define-read-only (is-peg-out-paused)\n\t(var-get peg-out-paused))\n(define-read-only (get-peg-out-fee)\n\t(var-get peg-out-fee))\n(define-read-only (get-peg-out-min-fee)\n\t(var-get peg-out-min-fee))\n(define-read-only (get-request-revoke-grace-period)\n\t(contract-call? .btc-bridge-registry-v2-01 get-request-revoke-grace-period))\n(define-read-only (get-request-claim-grace-period)\n\t(contract-call? .btc-bridge-registry-v2-01 get-request-claim-grace-period))\n(define-read-only (get-request-or-fail (request-id uint))\n\t(contract-call? .btc-bridge-registry-v2-01 get-request-or-fail request-id))\n(define-read-only (is-peg-in-address-approved (address (buff 128)))\n\t(contract-call? .btc-bridge-registry-v2-01 is-peg-in-address-approved address))\n(define-read-only (get-peg-in-sent-or-default (tx (buff 32768)) (output uint))\n\t(contract-call? .btc-bridge-registry-v2-01 get-peg-in-sent-or-default tx output))\n(define-read-only (get-fee-to-address)\n\t(var-get fee-to-address))\n(define-read-only (extract-tx-ins-outs (tx (buff 32768)))\n\t(if (try! (contract-call? .clarity-bitcoin-v1-07 is-segwit-tx tx))\n\t\t(let (\n\t\t\t\t(parsed-tx (unwrap! (contract-call? .clarity-bitcoin-v1-07 parse-wtx tx) err-invalid-tx)))\n\t\t\t(ok { ins: (get ins parsed-tx), outs: (get outs parsed-tx) }))\n\t\t(let (\n\t\t\t\t(parsed-tx (unwrap! (contract-call? .clarity-bitcoin-v1-07 parse-tx tx) err-invalid-tx)))\n\t\t\t(ok { ins: (get ins parsed-tx), outs: (get outs parsed-tx) }))))\n(define-read-only (get-txid (tx (buff 32768)))\n\t(if (try! (contract-call? .clarity-bitcoin-v1-07 is-segwit-tx tx))\n\t\t(ok (contract-call? .clarity-bitcoin-v1-07 get-segwit-txid tx))\n\t\t(ok (contract-call? .clarity-bitcoin-v1-07 get-txid tx))))\n(define-read-only (verify-mined (tx (buff 32768)) (block { header: (buff 80), height: uint }) (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint }))\n\t(if (is-eq chain-id u1)\n\t\t(let (\n\t\t\t\t(response (if (try! (contract-call? .clarity-bitcoin-v1-07 is-segwit-tx tx))\n\t\t\t\t\t(contract-call? .clarity-bitcoin-v1-07 was-segwit-tx-mined? block tx proof)\n\t\t\t\t\t(contract-call? .clarity-bitcoin-v1-07 was-tx-mined? block tx proof))\n\t\t\t\t))\n\t\t\t(if (or (is-err response) (not (unwrap-panic response)))\n\t\t\t\terr-bitcoin-tx-not-mined\n\t\t\t\t(ok true)\n\t\t\t))\n\t\t(ok true))) ;; if not mainnet, assume verified\n(define-read-only (validate-peg-out-0 (amount uint))\n\t(let (\n\t\t\t(gas-fee (var-get peg-out-min-fee))\n\t\t\t(fee (- (max (mul-down amount (var-get peg-out-fee)) gas-fee) gas-fee)))\n\t\t(asserts! (> amount (+ fee gas-fee)) err-invalid-amount)\n\t\t(ok { amount: (- amount fee gas-fee), fee: fee, gas-fee: gas-fee })))\n(define-public (request-peg-out-0 (peg-out-address (buff 128)) (amount uint))\n\t(let (\n\t\t\t(validation-data (try! (validate-peg-out-0 amount)))\n\t\t\t(gas-fee (get gas-fee validation-data))\n\t\t\t(fee (get fee validation-data))\n\t\t\t(amount-net (get amount validation-data))\n\t\t\t(request-details { requested-by: tx-sender, peg-out-address: peg-out-address, amount-net: amount-net, fee: fee, gas-fee: gas-fee, claimed: u0, claimed-by: tx-sender, fulfilled-by: 0x, revoked: false, finalized: false, requested-at: block-height, requested-at-burn-height: burn-block-height })\n\t\t\t(request-id (as-contract (try! (contract-call? .btc-bridge-registry-v2-01 set-request u0 request-details)))))\n\t\t(asserts! (not (var-get peg-out-paused)) err-paused)\n\t\t(try! (contract-call? .token-abtc transfer-fixed amount tx-sender (as-contract tx-sender) none))\n\t\t(print (merge request-details { type: \"request-peg-out\", request-id: request-id }))\n\t\t(ok request-id)))\n(define-public (claim-peg-out (request-id uint) (fulfilled-by (buff 128)))\n\t(let (\n\t\t\t(claimer tx-sender)\n\t\t\t(request-details (try! (get-request-or-fail request-id))))\n\t\t(asserts! (not (var-get peg-out-paused)) err-paused)\n\t\t(asserts! (< (get claimed request-details) block-height) err-request-already-claimed)\n\t\t(asserts! (not (get revoked request-details)) err-request-already-revoked)\n\t\t(asserts! (not (get finalized request-details)) err-request-already-finalized)\n\t\t(as-contract (try! (contract-call? .btc-bridge-registry-v2-01 set-request request-id (merge request-details { claimed: (+ block-height (get-request-claim-grace-period)), claimed-by: claimer, fulfilled-by: fulfilled-by }))))\n\t\t(print (merge request-details { type: \"claim-peg-out\", request-id: request-id, claimed: (+ block-height (get-request-claim-grace-period)), claimed-by: claimer, fulfilled-by: fulfilled-by }))\n\t\t(ok true)))\n(define-public (finalize-peg-out\n\t(request-id uint)\n\t(tx (buff 32768))\n\t(block { header: (buff 80), height: uint })\n\t(proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint })\n\t(output-idx uint) (fulfilled-by-idx uint))\n\t(let (\n\t\t\t(request-details (try! (get-request-or-fail request-id)))\n\t\t\t(was-mined (try! (verify-mined tx block proof)))\n\t\t\t(parsed-tx (try! (extract-tx-ins-outs tx)))\n\t\t\t(output (unwrap! (element-at (get outs parsed-tx) output-idx) err-invalid-tx))\n\t\t\t(fulfilled-by (get scriptPubKey (unwrap! (element-at (get outs parsed-tx) fulfilled-by-idx) err-invalid-tx)))\n\t\t\t(amount (get value output))\n\t\t\t(peg-out-address (get scriptPubKey output))\n\t\t\t(is-fulfilled-by-peg-in (is-peg-in-address-approved fulfilled-by)))\n\t\t(asserts! (not (var-get peg-out-paused)) err-paused)\n\t\t(asserts! (is-eq amount (get amount-net request-details)) err-invalid-amount)\n\t\t(asserts! (is-eq (get peg-out-address request-details) peg-out-address) err-address-mismatch)\n\t\t(asserts! (is-eq (get fulfilled-by request-details) fulfilled-by) err-address-mismatch)\n\t\t(asserts! (< (get requested-at-burn-height request-details) (get height block)) err-tx-mined-before-request)\n\t\t;; (asserts! (<= block-height (get claimed request-details)) err-request-claim-expired) ;; allow fulfilled if not claimed again\n\t\t(asserts! (not (get-peg-in-sent-or-default tx output-idx)) err-already-sent)\n\t\t(asserts! (not (get revoked request-details)) err-request-already-revoked)\n\t\t(asserts! (not (get finalized request-details)) err-request-already-finalized)\n\t\t(as-contract (try! (contract-call? .btc-bridge-registry-v2-01 set-peg-in-sent tx output-idx true)))\n\t\t(as-contract (try! (contract-call? .btc-bridge-registry-v2-01 set-request request-id (merge request-details { finalized: true }))))\n\t\t(and (> (get fee request-details) u0) (as-contract (try! (contract-call? .token-abtc transfer-fixed (get fee request-details) tx-sender (var-get fee-to-address) none))))\n\t\t(and (> (get gas-fee request-details) u0) (as-contract (try! (contract-call? .token-abtc transfer-fixed (get gas-fee request-details) tx-sender (if is-fulfilled-by-peg-in (var-get fee-to-address) (get claimed-by request-details)) none))))\n\t\t(if is-fulfilled-by-peg-in\n\t\t\t(as-contract (try! (contract-call? .token-abtc burn-fixed (get amount-net request-details) tx-sender)))\n\t\t\t(as-contract (try! (contract-call? .token-abtc transfer-fixed (get amount-net request-details) tx-sender (get claimed-by request-details) none))))\n\t\t(print { type: \"finalize-peg-out\", request-id: request-id, tx: tx })\n\t\t(ok true)))\n(define-public (revoke-peg-out (request-id uint))\n\t(let (\n\t\t\t(request-details (try! (get-request-or-fail request-id))))\n\t\t(asserts! (> block-height (+ (get requested-at request-details) (get-request-revoke-grace-period))) err-revoke-grace-period)\n\t\t(asserts! (< (get claimed request-details) block-height) err-request-already-claimed)\n\t\t(asserts! (not (get revoked request-details)) err-request-already-revoked)\n\t\t(asserts! (not (get finalized request-details)) err-request-already-finalized)\n\t\t(as-contract (try! (contract-call? .btc-bridge-registry-v2-01 set-request request-id (merge request-details { revoked: true }))))\n\t\t(and (> (get fee request-details) u0) (as-contract (try! (contract-call? .token-abtc transfer-fixed (get fee request-details) tx-sender (get requested-by request-details) none))))\n\t\t(and (> (get gas-fee request-details) u0) (as-contract (try! (contract-call? .token-abtc transfer-fixed (get gas-fee request-details) tx-sender (get requested-by request-details) none))))\n\t\t(as-contract (try! (contract-call? .token-abtc transfer-fixed (get amount-net request-details) tx-sender (get requested-by request-details) none)))\n\t\t(print { type: \"revoke-peg-out\", request-id: request-id })\n\t\t(ok true)))\n(define-private (max (a uint) (b uint))\n\t(if (< a b) b a))\n(define-private (min (a uint) (b uint))\n\t(if (< a b) a b))\n(define-private (mul-down (a uint) (b uint))\n\t(/ (* a b) ONE_8))\n(define-private (div-down (a uint) (b uint))\n\t(if (is-eq a u0) u0 (/ (* a ONE_8) b)))\n(define-public (callback (sender principal) (payload (buff 2048)))\n\t(ok true))",
    "analysis": {
      "summary": "This contract manages peg-out requests from a Stacks token to Bitcoin, including setting fees, pausing peg-outs, and handling requests.",
      "explanation": "The contract starts by implementing an external trait and using another trait for SIP010 compliance, indicating it interacts with standard fungible tokens on the Stacks blockchain. It defines a series of constants for error handling, a maximum unsigned integer value, and a constant for decimal precision in calculations. Data variables are declared to manage the fee address, peg-out status, and fees. The contract provides functions for administrative tasks like setting the fee address, pausing peg-outs, and adjusting fees, protected by a check to ensure only authorized addresses can call them. It includes read-only functions to check peg-out status and fees, interact with a Bitcoin bridge for peg-out requests, and validate Bitcoin transactions. Public functions allow users to request peg-outs, claim them, finalize the peg-out process by verifying Bitcoin transactions, and revoke requests under certain conditions. Private utility functions are used for arithmetic operations to handle fee calculations accurately. The contract interacts with external contracts for token transfers, peg-out request management, and Bitcoin transaction verification, ensuring a decentralized and secure peg-out process from Stacks to Bitcoin.",
      "tags": ["utility", "bridge", "DeFi", "protocol"],
      "data_vars_constants": [
        {
          "name": "err-unauthorised",
          "purpose": "Error code for unauthorized actions",
          "line": 3
        },
        {
          "name": "err-paused",
          "purpose": "Error code when peg-out functionality is paused",
          "line": 4
        },
        {
          "name": "fee-to-address",
          "purpose": "Stores the address where fees are collected",
          "line": 18
        },
        {
          "name": "peg-out-paused",
          "purpose": "Boolean flag to pause or resume peg-out requests",
          "line": 19
        },
        {
          "name": "peg-out-fee",
          "purpose": "The fee rate for peg-out transactions",
          "line": 20
        },
        {
          "name": "peg-out-min-fee",
          "purpose": "Minimum fee for peg-out transactions",
          "line": 21
        }
      ],
      "functions": [
        {
          "name": "set-fee-to-address",
          "purpose": "Updates the fee collection address",
          "parameters": [
            {
              "name": "new-fee-to-address",
              "type": "principal",
              "description": "The new address to collect fees"
            }
          ],
          "logic": "Checks for authorization and sets the new address",
          "lines": 22
        },
        {
          "name": "pause-peg-out",
          "purpose": "Pauses or resumes peg-out requests",
          "parameters": [
            {
              "name": "paused",
              "type": "bool",
              "description": "Flag to pause or resume"
            }
          ],
          "logic": "Checks for authorization and updates the pause status",
          "lines": 26
        },
        {
          "name": "request-peg-out-0",
          "purpose": "Initiates a peg-out request",
          "parameters": [
            {
              "name": "peg-out-address",
              "type": "(buff 128)",
              "description": "Bitcoin address for peg-out"
            },
            {
              "name": "amount",
              "type": "uint",
              "description": "Amount of tokens to peg out"
            }
          ],
          "logic": "Validates request, checks if peg-outs are paused, transfers tokens, and logs the request",
          "lines": 88
        },
        {
          "name": "finalize-peg-out",
          "purpose": "Finalizes a peg-out request after verifying Bitcoin transaction",
          "parameters": [
            {
              "name": "request-id",
              "type": "uint",
              "description": "The ID of the peg-out request"
            },
            {
              "name": "tx",
              "type": "(buff 32768)",
              "description": "The Bitcoin transaction"
            },
            {
              "name": "block",
              "type": "{ header: (buff 80), height: uint }",
              "description": "The Bitcoin block containing the transaction"
            },
            {
              "name": "proof",
              "type": "{ tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint }",
              "description": "Merkle proof for the transaction"
            },
            {
              "name": "output-idx",
              "type": "uint",
              "description": "Index of the output in the Bitcoin transaction"
            },
            {
              "name": "fulfilled-by-idx",
              "type": "uint",
              "description": "Index for the address fulfilling the peg-out"
            }
          ],
          "logic": "Verifies the Bitcoin transaction, checks various conditions, updates the request status, and handles token transfers or burns",
          "lines": 111
        }
      ],
      "notable_qualities": [
        "Implements a secure and decentralized bridge between Stacks and Bitcoin.",
        "Includes comprehensive error handling for robustness.",
        "Uses external contracts for enhanced functionality and interoperability.",
        "Provides detailed logging for transparency in peg-out requests."
      ]
    }
  },
  {
    "rank": 32,
    "contract": "SP2AA3RQQ8R98CZER4J1SMCSG879A4KM3WH3PM1KW.bns-1718282853306-v1",
    "calls": 1128,
    "source": "(define-constant A tx-sender)\n\n(define-public (swap-x-for-y (a0 uint))\n(let ((sender tx-sender))\n\t(asserts! (is-eq tx-sender A) (err u0))\n\t(try! (stx-transfer? a0 sender (as-contract tx-sender)))\n\t(as-contract\n\t(let (\n\t\t(b0 (try! (contract-call?\n\t\t\t'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-x-for-y\n\t\t\t'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token\n\t\t\t'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token\n\t\t\ta0 u0)))\n\t\t(a1 (unwrap-panic (element-at b0 u1)))\n\t\t(b1 (try! (contract-call?\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens\n\t\t\tu27\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx\n\t\t\t'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token\n\t\t\t'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to\n\t\t\ta1 u1)))\n\t\t(a2 (get amt-out b1))\n\t)\n\t\t(asserts! (> a2 a0) (err a2))\n\t\t(try! (stx-transfer? a2 tx-sender sender))\n\t\t(ok (list a0 a1 a2))\n))))\n\n(define-public (swap-y-for-x (a0 uint))\n(let ((sender tx-sender))\n\t(asserts! (is-eq tx-sender A) (err u0))\n\t(try! (stx-transfer? a0 sender (as-contract tx-sender)))\n\t(as-contract\n\t(let (\n\t\t(b0 (try! (contract-call?\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens\n\t\t\tu27\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx\n\t\t\t'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx\n\t\t\t'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to\n\t\t\ta0 u1)))\n\t\t(a1 (get amt-out b0))\n\t\t(b1 (try! (contract-call?\n\t\t\t'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-swap-v2-1 swap-y-for-x\n\t\t\t'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token\n\t\t\t'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token\n\t\t\ta1 u0)))\n\t\t(a2 (unwrap-panic (element-at b1 u0)))\n\t)\n\t\t(asserts! (> a2 a0) (err a2))\n\t\t(try! (stx-transfer? a2 tx-sender sender))\n\t\t(ok (list a0 a1 a2))\n))))\n\n(define-public (add-to-position (a0 uint))\n(let ((sender tx-sender))\n\t(asserts! (is-eq tx-sender A) (err u0))\n\t(try! (stx-transfer? a0 sender (as-contract tx-sender)))\n\t(as-contract\n\t(let (\n\t\t(b0 (try! (contract-call?\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens\n\t\t\tu27\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx\n\t\t\t'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx\n\t\t\t'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to\n\t\t\ta0 u1)))\n\t\t(a1 (get amt-out b0))\n\t\t(b1 (try! (contract-call?\n\t\t\t'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-y-for-x\n\t\t\t'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2\n\t\t\t'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi\n\t\t\tu100000000 (* a1 u100) none)))\n\t\t(a2 (/ (get dx b1) u100))\n\t)\n\t\t(asserts! (> a2 a0) (err a2))\n\t\t(try! (stx-transfer? a2 tx-sender sender))\n\t\t(ok (list a0 a1 a2))\n))))\n\n(define-public (reduce-position (a0 uint))\n(let ((sender tx-sender))\n\t(asserts! (is-eq tx-sender A) (err u0))\n\t(try! (stx-transfer? a0 sender (as-contract tx-sender)))\n\t(as-contract\n\t(let (\n\t\t(b0 (try! (contract-call?\n\t\t\t'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-x-for-y\n\t\t\t'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2\n\t\t\t'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi\n\t\t\tu100000000 (* a0 u100) none)))\n\t\t(a1 (/ (get dy b0) u100))\n\t\t(b1 (try! (contract-call?\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens\n\t\t\tu27\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx\n\t\t\t'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token\n\t\t\t'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx\n\t\t\t'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to\n\t\t\ta1 u1)))\n\t\t(a2 (get amt-out b1))\n\t)\n\t\t(asserts! (> a2 a0) (err a2))\n\t\t(try! (stx-transfer? a2 tx-sender sender))\n\t\t(ok (list a0 a1 a2))\n))))\n\n(define-public (purchase-name (dx uint))\n    (ok (list \n        (swap-x-for-y dx)\n        (swap-y-for-x dx)\n        (add-to-position dx)\n        (reduce-position dx)\n    ))\n)",
    "analysis": {
      "summary": "This contract facilitates swapping between two tokens, adjusting positions, and a composite operation involving all functionalities.",
      "explanation": "The contract is designed to interact with external swap and liquidity pool contracts to perform token swaps and position adjustments within those pools. It restricts certain actions to the contract deployer or a predefined address.\n\n1. Constants and Data Variables:\n- A constant 'A' <L1> is defined to store the contract deployer's address for access control.\n\n2. Functions:\n- 'swap-x-for-y' <L3-29>: Swaps token X for token Y using two external contracts. It ensures the caller is the predefined address <L5>, transfers the specified amount of token X <L6>, performs the swap <L9-13>, and then does another swap with the received amount <L15-23>. It checks if the final amount of token Y is greater than the initial amount of token X <L26> before transferring the amount back <L27>.\n- 'swap-y-for-x' <L31-57>: Mirrors 'swap-x-for-y' but in the opposite direction, swapping token Y for token X.\n- 'add-to-position' <L59-85>: Allows adding to a liquidity position by swapping tokens through an external contract and then adjusting the position based on the swap outcome.\n- 'reduce-position' <L87-113>: Allows reducing a liquidity position by swapping tokens and adjusting the position similarly to 'add-to-position'.\n- 'purchase-name' <L115-121>: A composite function that sequentially calls the other four functions with the same input amount, demonstrating a complex interaction pattern.\n\nEach function includes safety checks to ensure that only the predefined address can call them <L5, L33, L61, L89> and performs token transfers to and from the caller <L6, L34, L62, L90>. The contract interacts with external contracts for swapping tokens, requiring careful management of permissions and error handling to prevent unauthorized access or loss of funds.\n\nNotable Qualities:\n- Restrictive access control to prevent unauthorized use.\n- Complex interactions with external contracts for token swaps and liquidity management.\n- Use of both 'try!' and 'unwrap-panic' for error handling, demonstrating different approaches to dealing with external call failures.\n- The 'purchase-name' function showcases how multiple contract functionalities can be composed into a single, higher-level operation.",
      "tags": ["utility", "DeFi", "swap", "liquidity-management"]
    }
  },
  {
    "rank": 33,
    "contract": "SPAG3YDTNKR58Z6X1RK74N861MXJ8RCRRE80A11W.balancer-v29-3",
    "calls": 1106,
    "source": "(define-constant ONE_6 u1000000)\n(define-constant ONE_8 u100000000)\n(define-constant ERR-NO-PR (err u400))\n\n(define-read-only (six-to-eight (n uint))\n    (/ (* n ONE_8) ONE_6)\n)\n\n(define-public (balancer1_i (in uint) (mrc uint))\n    (begin \n        (try! (contract-call? \n            'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper \n            'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 \n            'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi \n            u100000000 (six-to-eight in) none\n        ))\n        (let \n            (\n                (bb (stx-get-balance tx-sender))\n            )            \n            (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens  \n                u27 \n                'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx \n                'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token \n                'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token   \n                'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx   \n                'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to  \n                (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)) \n                u1\n            ))\n            (let \n                (\n                    (ba (stx-get-balance tx-sender))\n                    (rc (- ba bb))\n                )\n                (asserts! (>= rc mrc) ERR-NO-PR)\n                (ok (list bb ba))\n            ) \n        )\n    )\n)\n\n(define-public (balancer1 (dd uint) (mr uint) (ta uint))\n    (let (\n            (r (list \n                (balancer1_i dd mr)\n            ))\n        )\n        (and (> (stx-get-balance tx-sender) ta) (try! (stx-transfer? (- (stx-get-balance tx-sender) ta) tx-sender 'SPAG3YDTNKR58Z6X1RK74N861MXJ8RCRRE80A11W)))\n        (ok r)\n    )\n)\n\n\n(define-public (balancer2_i (in uint) (mout uint))\n    (begin\n        (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens  \n                u27 \n                'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx \n                'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token  \n                'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx\n                'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token \n                'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to\n                in \n                u1\n            ))\n        (let\n            (\n                (bb (stx-get-balance tx-sender))\n            )\n            (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper\n                'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wcorgi \n                'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2    \n                u100000000  \n                (six-to-eight (unwrap-panic (contract-call? 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token get-balance tx-sender)))\n                none\n            ))\n            (let \n                (\n                    (ba (stx-get-balance tx-sender))\n                    (rc (- ba bb))\n                )\n                (asserts! (>= rc mout) (err u400))\n                (ok (list bb ba))\n            ) \n        )\n    )\n)\n\n(define-public (balancer2 (dd uint) (mr uint) (ta uint))\n    (let (\n            (r (list \n                (balancer2_i dd mr)\n            ))\n        )\n        (and (> (stx-get-balance tx-sender) ta) (try! (stx-transfer? (- (stx-get-balance tx-sender) ta) tx-sender 'SPAG3YDTNKR58Z6X1RK74N861MXJ8RCRRE80A11W)))\n        (ok r)\n    )\n)\n\n(define-public (balancer (dd uint) (mr uint) (ta uint))\n    (let (\n            (r (list \n                (balancer1_i dd mr)\n                (balancer2_i dd mr)\n            ))\n        )\n        (and (> (stx-get-balance tx-sender) ta) (try! (stx-transfer? (- (stx-get-balance tx-sender) ta) tx-sender 'SPAG3YDTNKR58Z6X1RK74N861MXJ8RCRRE80A11W)))\n        (ok r)\n    )\n)",
    "analysis": {
      "summary": "This contract facilitates token swaps and balance adjustments between different tokens and pools on the Stacks blockchain.",
      "explanation": "The contract serves as an intermediary for swapping tokens by interacting with other smart contracts and ensuring balance adjustments meet certain criteria. It utilizes constants for conversion rates and error handling, and defines public functions for executing and validating the swaps and balance transfers.\n\n1. Constants and Error Handling:\n- `ONE_6` <L1> and `ONE_8` <L2> are constants used for decimal precision adjustments in token amounts.\n- `ERR-NO-PR` <L3> is an error constant used to indicate insufficient profit from transactions.\n\n2. Functions:\n- The `six-to-eight` function <L5-7> converts a uint value from 6 decimal places to 8, using the defined constants for precision adjustment.\n\n- `balancer1_i` <L9-41> initiates a swap between tokens through two different contracts and checks if the resulting balance change meets a minimum required change (`mrc`). It calls external contracts for swapping tokens <L11-16> and <L21-30>, then calculates and validates the balance change <L33-37>.\n\n- `balancer1` <L43-52> and `balancer2` <L90-99> are similar in functionality, initiating swaps through `balancer1_i` <L45-46> and `balancer2_i` <L93-94>, respectively, and transferring a specified amount (`ta`) from the transaction sender's balance if certain conditions are met <L49>.\n\n- `balancer2_i` <L55-88> mirrors `balancer1_i` but with a different sequence of token swaps and a check for a minimum output amount (`mout`) instead of a minimum required change.\n\n- The `balancer` function <L101-111> combines the operations of `balancer1_i` and `balancer2_i` for a single transaction, attempting both swaps and performing a balance transfer if conditions are met <L108>.\n\nEach function performs safety checks, such as ensuring the transaction sender has sufficient balance for the operations and validating the minimum required or output amounts against transaction results. The contract interacts with external contracts for token swaps, using `contract-call?` to execute functions on other contracts and `stx-get-balance` to check STX balances.\n\nNotable Qualities:\n- Interoperability with multiple token contracts and pools.\n- Use of both fixed precision conversion and external contract calls for token management.\n- Emphasis on validating transaction profitability and sender balance before and after swaps.",
      "tags": ["DeFi", "swap", "utility", "protocol"]
    }
  },
  {
    "rank": 34,
    "contract": "SPVD6CE8RW90BGGKJZTKCSMGKS7HP0K8364TFR48.bitcoin-faces-airdrop",
    "calls": 1100,
    "source": "(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)\n\n(define-constant DEPLOYER tx-sender)\n(define-constant ALL_HEX (contract-call? .utils get-all-hex))\n(define-constant ALL_HEX_ASCII (contract-call? .utils get-all-hex-ascii))\n\n(define-data-var nextId uint u1)\n\n(define-data-var url (string-ascii 256) \"https://bitcoinfaces.xyz/api/get-nft-metadata?hashedName=\")\n\n(define-map FirstOwners uint principal)\n\n(define-non-fungible-token bitcoin-faces uint)\n\n(define-read-only (get-last-token-id) (ok (- (var-get nextId) u1)))\n\n(define-read-only (get-token-uri (id uint))\n  (ok (as-max-len? (concat (var-get url) (fold buff-to-ascii (get-first-owner-buff id) \"0x\")) u256))\n)\n\n(define-private (buff-to-ascii (x (buff 1)) (out (string-ascii 1000)))\n    (unwrap-panic (as-max-len? (concat out (unwrap-panic (element-at? ALL_HEX_ASCII (unwrap-panic (index-of? ALL_HEX x))))) u1000))\n)\n\n(define-read-only (get-owner (id uint)) (ok (nft-get-owner? bitcoin-faces id)))\n\n(define-public (transfer (id uint) (from principal) (to principal))\n  (if (or (is-eq from tx-sender) (is-eq from contract-caller))\n    (begin\n      (map-insert FirstOwners id from)\n      (nft-transfer? bitcoin-faces id from to)\n    )\n    (err u4)\n  )\n)\n\n(define-public (burn (id uint) (from principal))\n  (if (or (is-eq from tx-sender) (is-eq from contract-caller))\n    (begin\n      (map-insert FirstOwners id from)\n      (nft-burn? bitcoin-faces id from)\n    )\n    (err u4)\n  )\n)\n\n(define-public (mint (to principal))\n  (let ((id (var-get nextId)))\n    (asserts! (is-eq DEPLOYER (get-standard-caller)) (err u401))\n    (var-set nextId (+ id u1))\n    (nft-mint? bitcoin-faces id to)\n  )\n)\n\n(define-public (set-url (new (string-ascii 256)))\n  (if (is-eq DEPLOYER (get-standard-caller))\n    (ok (var-set url new))\n    (err u401)\n  )\n)\n\n(define-public (airdrop (l1 (list 5000 principal)) (l2 (list 5000 principal)) (l3 (list 4995 principal)))\n  (if (is-eq DEPLOYER (get-standard-caller))\n    (ok (var-set nextId (fold drop l3 (fold drop l2 (fold drop l1 (var-get nextId))))))\n    (err u401)\n  )\n)\n\n(define-private (drop (to principal) (id uint))\n  (begin (is-err (nft-mint? bitcoin-faces id to)) (+ id u1))\n)\n\n(define-read-only (get-standard-caller)\n  (let ((d (unwrap-panic (principal-destruct? contract-caller))))\n    (unwrap-panic (principal-construct? (get version d) (get hash-bytes d)))\n  )\n)\n\n(define-read-only (get-first-owner (id uint)) \n  (match (map-get? FirstOwners id) addr (some addr)\n    (nft-get-owner? bitcoin-faces id)\n  )\n)\n\n(define-read-only (get-first-owner-buff (id uint))\n  (unwrap-panic (match (get-first-owner id) addr (to-consensus-buff? addr) (some 0x)))\n)\n\n(nft-mint? bitcoin-faces u0 (as-contract tx-sender))\n(as-contract (transfer u0 tx-sender DEPLOYER))\n",
    "analysis": {
      "summary": "This contract mints, transfers, and burns non-fungible tokens (NFTs) named 'bitcoin-faces', tracks their first owners, and allows for metadata URI updates.",
      "explanation": "The contract starts by implementing a trait from another contract for NFT functionality <L1>. It sets constants for the deployer, and hex values for ASCII conversion <L3-5>. A unique ID for the next NFT to be minted is tracked <L7>, alongside a base URL for NFT metadata <L9>. A map to track the first owners of each NFT is defined <L11>, and the NFT itself is declared <L13>. Functions are provided to get the last token ID <L15>, token URI <L17>, owner <L25>, transfer and burn NFTs <L27, L37>, mint new NFTs <L47>, set a new metadata URL <L55>, and airdrop NFTs to a list of addresses <L62>. Private functions and read-only functions support these operations by handling ASCII conversion <L21>, standard caller verification <L73>, and first owner retrieval <L79, L85>. The contract concludes with an initial mint and transfer operation <L89-90>.",
      "tags": ["NFT", "utility", "protocol"]
    }
  },
  {
    "rank": 35,
    "contract": "SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.wrapper-velar-path-v-1-1",
    "calls": 1088,
    "source": ";; wrapper-velar-path-v-1-1\n\n(use-trait ft-trait 'SP2AKWJYC7BNY18W1XXKPGP0YVEK63QJG4793Z2D4.sip-010-trait-ft-standard.sip-010-trait)\n(use-trait share-fee-to-trait 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to-trait.share-fee-to-trait)\n(use-trait univ2v2-pool-trait 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-pool-trait_v1_0_0.univ2-pool-trait)\n(use-trait univ2v2-fees-trait 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-fees-trait_v1_0_0.univ2-fees-trait)\n(use-trait curve-pool-trait 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.curve-pool-trait_v1_0_0.curve-pool-trait)\n(use-trait curve-fees-trait 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.curve-fees-trait_v1_0_0.curve-fees-trait)\n(use-trait ststx-pool-trait 'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.curve-pool-trait_ststx.curve-pool-trait)\n(use-trait ststx-proxy-trait 'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.curve-proxy-trait_ststx.curve-proxy-trait)\n\n(define-constant NUM_A u1000000)\n(define-constant NUM_B u100)\n\n(define-public (apply\n    (path (list 4 {a: (string-ascii 1), b: principal, c: uint, d: principal, e: principal, f: bool}))\n    (amt-in uint)\n    (token1 (optional <ft-trait>)) (token2 (optional <ft-trait>)) (token3 (optional <ft-trait>))\n    (token4 (optional <ft-trait>)) (token5 (optional <ft-trait>))\n    (share-fee-to (optional <share-fee-to-trait>))\n    (univ2v2-pool-1 (optional <univ2v2-pool-trait>)) (univ2v2-pool-2 (optional <univ2v2-pool-trait>))\n    (univ2v2-pool-3 (optional <univ2v2-pool-trait>)) (univ2v2-pool-4 (optional <univ2v2-pool-trait>))\n    (univ2v2-fees-1 (optional <univ2v2-fees-trait>)) (univ2v2-fees-2 (optional <univ2v2-fees-trait>))\n    (univ2v2-fees-3 (optional <univ2v2-fees-trait>)) (univ2v2-fees-4 (optional <univ2v2-fees-trait>))\n    (curve-pool-1 (optional <curve-pool-trait>)) (curve-pool-2 (optional <curve-pool-trait>))\n    (curve-pool-3 (optional <curve-pool-trait>)) (curve-pool-4 (optional <curve-pool-trait>))\n    (curve-fees-1 (optional <curve-fees-trait>)) (curve-fees-2 (optional <curve-fees-trait>))\n    (curve-fees-3 (optional <curve-fees-trait>)) (curve-fees-4 (optional <curve-fees-trait>))\n    (ststx-pool-1 (optional <ststx-pool-trait>)) (ststx-pool-2 (optional <ststx-pool-trait>))\n    (ststx-pool-3 (optional <ststx-pool-trait>)) (ststx-pool-4 (optional <ststx-pool-trait>))\n    (ststx-proxy-1 (optional <ststx-proxy-trait>)) (ststx-proxy-2 (optional <ststx-proxy-trait>))\n    (ststx-proxy-3 (optional <ststx-proxy-trait>)) (ststx-proxy-4 (optional <ststx-proxy-trait>))\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.path-apply_staging apply\n                  path amt-in\n                  token1 token2 token3 token4 token5\n                  share-fee-to\n                  univ2v2-pool-1 univ2v2-pool-2 univ2v2-pool-3 univ2v2-pool-4\n                  univ2v2-fees-1 univ2v2-fees-2 univ2v2-fees-3 univ2v2-fees-4\n                  curve-pool-1 curve-pool-2 curve-pool-3 curve-pool-4\n                  curve-fees-1 curve-fees-2 curve-fees-3 curve-fees-4\n                  ststx-pool-1 ststx-pool-2 ststx-pool-3 ststx-pool-4\n                  ststx-proxy-1 ststx-proxy-2 ststx-proxy-3 ststx-proxy-4)))\n  )\n    (ok (get amt-out (get swap4 swap-a)))\n  )\n)\n\n(define-public (swap-univ2v2\n    (amt-in uint)\n    (token-in <ft-trait>) (token-out <ft-trait>)\n    (univ2v2-pool <univ2v2-pool-trait>) (univ2v2-fees <univ2v2-fees-trait>)\n  )\n  (let (\n    (edge {a: \"v\", b: (contract-of univ2v2-pool), c: u0, d: (contract-of token-in), e: (contract-of token-out), f: false})\n    (swap-a (try! (contract-call?\n                  'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.path-apply_staging swap-univ2v2\n                  edge amt-in\n                  token-in token-out\n                  univ2v2-pool univ2v2-fees)))\n  )\n    (ok (get amt-out swap-a))\n  )\n)\n\n(define-public (swap-curve\n    (amt-in uint)\n    (token-in <ft-trait>) (token-out <ft-trait>)\n    (curve-pool <curve-pool-trait>) (curve-fees <curve-fees-trait>)\n  )\n  (let (\n    (edge {a: \"c\", b: (contract-of curve-pool), c: u0, d: (contract-of token-in), e: (contract-of token-out), f: false})\n    (swap-a (try! (contract-call?\n                  'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.path-apply_staging swap-curve\n                  edge amt-in\n                  token-in token-out\n                  curve-pool curve-fees)))\n  )\n    (ok (get amt-out swap-a))\n  )\n)\n\n(define-public (swap-usdh\n    (amt-in uint)\n    (token-in <ft-trait>) (token-out <ft-trait>)\n    (usdh-pool <curve-pool-trait>) (usdh-fees <curve-fees-trait>)\n  )\n  (let (\n    (edge {a: \"h\", b: (contract-of usdh-pool), c: u0, d: (contract-of token-in), e: (contract-of token-out), f: false})\n    (swap-a (try! (contract-call?\n                  'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.path-apply_staging swap-curve\n                  edge amt-in\n                  token-in token-out\n                  usdh-pool usdh-fees)))\n  )\n    (ok (get amt-out swap-a))\n  )\n)\n\n(define-public (swap-ststx\n    (amt-in uint)\n    (token-in <ft-trait>) (token-out <ft-trait>)\n    (ststx-pool <ststx-pool-trait>) (curve-fees <curve-fees-trait>)\n    (ststx-proxy <ststx-proxy-trait>)\n  )\n  (let (\n    (edge {a: \"s\", b: (contract-of ststx-pool), c: u0, d: (contract-of token-in), e: (contract-of token-out), f: false})\n    (swap-a (try! (contract-call?\n                  'SP20X3DC5R091J8B6YPQT638J8NR1W83KN6TN5BJY.path-apply_staging swap-ststx\n                  edge amt-in\n                  token-in token-out\n                  ststx-pool curve-fees ststx-proxy)))\n  )\n    (ok (get amt-out swap-a))\n  )\n)\n\n(define-public (quote-univ2v2\n    (amount uint)\n    (token-in principal) (token-out principal)\n    (univ2v2-pool <univ2v2-pool-trait>)\n    (swap-fee {num: uint, den: uint})\n  )\n  (let (\n    (pool-data (try! (contract-call? univ2v2-pool get-pool)))\n    (swaps-reversed (and (is-eq token-in (get token1 pool-data)) (is-eq token-out (get token0 pool-data))))\n    (reserves {in: (if swaps-reversed (get reserve1 pool-data) (get reserve0 pool-data)), out: (if swaps-reversed (get reserve0 pool-data) (get reserve1 pool-data))})\n    (amount-adjusted (/ (* amount (get num swap-fee)) (get den swap-fee)))\n    (quote-a (try! (contract-call?\n                   'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-math find-dx\n                   (get out reserves) (get in reserves)\n                   amount-adjusted)))\n  )\n    (ok quote-a)\n  )\n)\n\n(define-public (quote-curve\n    (amount uint)\n    (token-in principal) (token-out principal)\n    (curve-pool <curve-pool-trait>)\n    (swap-fee {num: uint, den: uint})\n  )\n  (let (\n    (pool-data (try! (contract-call? curve-pool get-pool)))\n    (swaps-reversed (and (is-eq token-in (get token1 pool-data)) (is-eq token-out (get token0 pool-data))))\n    (reserves {in: (if swaps-reversed (get reserve1 pool-data) (get reserve0 pool-data)), out: (if swaps-reversed (get reserve0 pool-data) (get reserve1 pool-data))})\n    (amount-adjusted (/ (* amount (get num swap-fee)) (get den swap-fee)))\n    (quote-a (try! (contract-call?\n                   'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.curve-math_v1_0_0 find-dx\n                   (get out reserves) (get in reserves)\n                   amount-adjusted u0 (get A pool-data))))\n  )\n    (ok quote-a)\n  )\n)\n\n(define-public (quote-usdh\n    (amount uint)\n    (token-in principal) (token-out principal)\n    (usdh-pool <curve-pool-trait>)\n    (swap-fee {num: uint, den: uint})\n    (usdh-in bool)\n  )\n  (let (\n    (pool-data (try! (contract-call? usdh-pool get-pool)))\n    (swaps-reversed (and (is-eq token-in (get token1 pool-data)) (is-eq token-out (get token0 pool-data))))\n    (reserves {in: (if swaps-reversed (get reserve1 pool-data) (get reserve0 pool-data)), out: (if swaps-reversed (get reserve0 pool-data) (get reserve1 pool-data))})\n    (reserves-lifted {in: (if usdh-in (lift-amount (get in reserves)) (get in reserves)), out: (if usdh-in (get out reserves) (lift-amount (get out reserves)))})\n    (amount-adjusted (/ (* amount (get num swap-fee)) (get den swap-fee)))\n    (amount-lifted (if usdh-in (lift-amount amount-adjusted) amount-adjusted))\n    (quote-a (try! (contract-call? \n                   'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.curve-math_v1_0_0 find-dx\n                   (get out reserves-lifted) (get in reserves-lifted)\n                   amount-lifted u0 (get A pool-data))))\n  )\n    (ok (if usdh-in quote-a (lower-amount quote-a)))\n  )\n)\n\n(define-public (quote-ststx\n    (amount uint)\n    (token-in principal) (token-out principal)\n    (ststx-pool <ststx-pool-trait>) (ststx-proxy <ststx-proxy-trait>)\n    (swap-fee {num: uint, den: uint})\n    (stx-in bool)\n  )\n  (let (\n    (pool-data (try! (contract-call? ststx-pool get-pool)))\n    (pool-ratio (try! (contract-call? ststx-proxy get-ratio)))\n    (swaps-reversed (and (is-eq token-in (get token1 pool-data)) (is-eq token-out (get token0 pool-data))))\n    (reserves {in: (if swaps-reversed (get reserve1 pool-data) (get reserve0 pool-data)), out: (if swaps-reversed (get reserve0 pool-data) (get reserve1 pool-data))})\n    (amount-adjusted (/ (* amount (get num swap-fee)) (get den swap-fee)))\n    (amount-adjusted-ratio (if stx-in (divide-ratio amount-adjusted pool-ratio) (multiply-ratio amount-adjusted pool-ratio)))\n    (quote-a (try! (contract-call?\n                   'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.curve-math_v1_0_0 find-dx\n                   (get out reserves) (get in reserves)\n                   amount-adjusted-ratio u0 (get A pool-data))))\n  )\n    (ok quote-a)\n  )\n)\n\n(define-private (multiply-ratio (amount uint) (ratio uint))\n  (/ (* amount ratio) NUM_A)\n)\n\n(define-private (divide-ratio (amount uint) (ratio uint))\n (/ (* amount NUM_A) ratio)\n)\n\n(define-private (lift-amount (amount uint))\n  (/ amount NUM_B)\n)\n\n(define-private (lower-amount (amount uint))\n  (* amount NUM_B)\n)",
    "analysis": {
      "summary": "This contract facilitates complex token swaps across different liquidity pools on the Stacks blockchain, utilizing various pool and fee traits.",
      "explanation": "The contract integrates multiple DeFi protocols by allowing token swaps through a variety of liquidity pools, including Uniswap V2-like pools, Curve-like pools, and a custom STX pool. It supports direct swaps, fee calculations, and quoting mechanisms for these swaps, leveraging the Stacks blockchain's capabilities for DeFi operations.\n\n1. Constants:\n- `NUM_A` <L12> and `NUM_B` <L13> are used for mathematical calculations, likely for precision adjustments or fee calculations in the swapping and quoting functions.\n\n2. The `apply` function <L15-48> serves as a wrapper to initiate swaps across different types of pools by calling another contract's `apply` function with a complex set of parameters including tokens, amounts, and pool traits. It's a high-level entry point for executing swaps.\n- Parameters include a path for the swap, amounts, tokens, and various optional pool and fee traits.\n- It constructs a swap operation and attempts to execute it, returning the output amount if successful.\n\n3. The `swap-univ2v2` <L51-65>, `swap-curve` <L68-81>, `swap-usdh` <L85-99>, and `swap-ststx` <L102-116> functions are specific implementations for swapping tokens across different liquidity pool types. Each function prepares the necessary data and calls the `path-apply_staging` contract method to perform the swap, handling different pool and fee traits.\n\n4. The `quote-univ2v2` <L120-137>, `quote-curve` <L140-157>, `quote-usdh` <L160-180>, and `quote-ststx` <L183-202> functions provide quoting functionality for swaps, calculating the expected output amount for a given input amount, token pair, and pool. These functions adjust for swap fees and use specific pool traits to get pool data and calculate the quote.\n\n5. Helper functions `multiply-ratio` <L206-207>, `divide-ratio` <L210-211>, `lift-amount` <L214-215>, and `lower-amount` <L218-219> are used for mathematical operations within the contract, adjusting amounts based on predefined constants or ratios.\n\nNotable qualities:\n- The contract abstracts complex DeFi operations, making it easier to interact with different liquidity pools.\n- It uses a flexible architecture that can accommodate various token types and pool mechanisms.\n- The contract includes both swap and quote functionalities, providing users with the necessary tools for DeFi operations in one place.\n- The use of traits for pools and fees demonstrates a modular approach, allowing for easy extension or modification.",
      "tags": ["DeFi", "DEX", "swap", "liquidity-pool"]
    }
  },
  {
    "rank": 36,
    "contract": "SP1AY6K3PQV5MRT6R4S671NWW2FRVPKM0BR162CT6.leo-token",
    "calls": 975,
    "source": ";; ---------------------------------------------------------\n;; SIP-10 Fungible Token Contract\n;; ---------------------------------------------------------\n(impl-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)\n\n(define-fungible-token leo)\n(define-constant contract-owner tx-sender)\n\n;; ---------------------------------------------------------\n;; Constants/Variables\n;; ---------------------------------------------------------\n(define-data-var token-uri (optional (string-utf8 256)) none)\n\n;; ---------------------------------------------------------\n;; Errors\n;; ---------------------------------------------------------\n(define-constant ERR_UNAUTHORIZED (err u100))\n\n;; ---------------------------------------------------------\n;; SIP-10 Functions\n;; ---------------------------------------------------------\n(define-public (transfer\n  (amount uint)\n  (sender principal)\n  (recipient principal)\n  (memo (optional (buff 34)))\n)\n  (begin\n    ;; #[filter(amount, recipient)]\n    (asserts! (is-eq tx-sender sender) ERR_UNAUTHORIZED)\n    (try! (ft-transfer? leo amount sender recipient))\n    (match memo to-print (print to-print) 0x)\n    (ok true)\n  )\n)\n\n(define-read-only (get-balance (owner principal))\n  (ok (ft-get-balance leo owner))\n)\n\n(define-read-only (get-name)\n  (ok \"Leo\")\n)\n\n(define-read-only (get-symbol)\n  (ok \"LEO\")\n)\n\n(define-read-only (get-decimals)\n  (ok u6)\n)\n\n(define-read-only (get-total-supply)\n  (ok (ft-get-supply leo))\n)\n\n(define-read-only (get-token-uri)\n    (ok (var-get token-uri)\n    )\n)\n\n(define-public (set-token-uri (value (string-utf8 256)))\n  ;; #[filter(value)]\n  (if (is-eq tx-sender contract-owner)\n    (ok (var-set token-uri (some value)))\n    (err ERR_UNAUTHORIZED)\n  )\n)\n\n;; ---------------------------------------------------------\n;; Utility Functions\n;; ---------------------------------------------------------\n(define-public (send-many (recipients (list 200 { to: principal, amount: uint, memo: (optional (buff 34)) })))\n  (fold check-err (map send-token recipients) (ok true))\n)\n\n(define-private (check-err (result (response bool uint)) (prior (response bool uint)))\n  (match prior ok-value result err-value (err err-value))\n)\n\n(define-private (send-token (recipient { to: principal, amount: uint, memo: (optional (buff 34)) }))\n  (send-token-with-memo (get amount recipient) (get to recipient) (get memo recipient))\n)\n\n(define-private (send-token-with-memo (amount uint) (to principal) (memo (optional (buff 34))))\n  (let ((transferOk (try! (transfer amount tx-sender to memo))))\n    (ok transferOk)\n  )\n)\n\n;; ---------------------------------------------------------\n;; Mint\n;; ---------------------------------------------------------\n(begin\n  (try! (ft-mint? leo u10000000000000000 contract-owner)) \n)",
    "analysis": {
      "summary": "This contract implements a SIP-10 compliant fungible token named Leo with additional features for setting a token URI and batch transfers.",
      "explanation": "The contract starts by declaring its compliance with the SIP-010 Fungible Token Standard <L4>. It defines a fungible token named 'leo' <L6> and sets the contract's owner to the address that deployed the contract <L7>. The contract includes a data variable for storing a token URI <L12>, a constant for an unauthorized error <L17>, and implements several functions required by the SIP-010 standard along with custom functions for setting a token URI and sending tokens to multiple recipients at once. \n\nData vars and constants:\n- 'leo': The fungible token defined by this contract <L6>.\n- 'contract-owner': A constant set to the address that deployed the contract, representing the token's owner <L7>.\n- 'token-uri': An optional string that can store a URI pointing to the token's metadata <L12>.\n- 'ERR_UNAUTHORIZED': An error constant used to indicate unauthorized actions <L17>.\n\nFunctions:\n- 'transfer': Allows the sender to transfer tokens to a recipient <L22-34>. Parameters include 'amount' of tokens to transfer, 'sender' address, 'recipient' address, and an optional 'memo'. It checks if the transaction sender is the sender of the tokens and performs the transfer, logging the memo if present.\n- 'get-balance': Returns the balance of an owner <L37-39>.\n- 'get-name', 'get-symbol', 'get-decimals', 'get-total-supply': These functions return the token's name, symbol, decimals, and total supply, respectively <L41-55>.\n- 'get-token-uri': Returns the stored token URI <L57-60>.\n- 'set-token-uri': Allows the contract owner to set the token URI <L62-68>. It checks if the transaction sender is the contract owner before setting the URI.\n- 'send-many': A utility function for sending tokens to multiple recipients in one transaction <L73-89>. It iterates over a list of recipients and amounts, transferring tokens to each.\n- The contract concludes with an initial minting of tokens to the contract owner <L94-96>.\n\nNotable qualities:\n- Implements the SIP-010 standard, ensuring compatibility with the broader Stacks ecosystem.\n- Includes a token URI feature, allowing for rich metadata to be associated with the token.\n- Supports batch transfers, enhancing efficiency for transactions involving multiple recipients.",
      "tags": ["fungible-token", "SIP-010", "utility", "protocol"]
    }
  },
  {
    "rank": 37,
    "contract": "SP3T54N6G4HN7GPBCYMSDKP4W00C45X19GQ4VT13Y.skullcoin-competitive-g1-base",
    "calls": 967,
    "source": ";; Skullcoin | Competitive | Game #1 | v.1.0.0\n;; skullco.in\n\n;; Traits\n(use-trait ft-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)\n\n;; Constants and Errors\n(define-constant CONTRACT-OWNER tx-sender)\n(define-constant BURN-WALLET 'SP5EDWN88FN8Q6A1MQ0N7SKKAG0VZ0ZQ9MFZ6RS8)\n(define-constant ERR-NOT-AUTHORIZED (err u100))\n(define-constant ERR-SALE-NOT-ACTIVE (err u101))\n(define-constant ERR-NOT-OWNER (err u102))\n(define-constant ERR-NOT-TREASURE (err u103))\n(define-constant ERR-NOT-CHEST (err u104))\n(define-constant ERR-NOT-TOKENS (err u105))\n(define-constant ERR-NOT-STX (err u106))\n(define-constant REACHED-BLOCK-PICK-LIMIT (err u107))\n(define-constant ERR-NO-WL-REMAINING (err u108))\n\n;; Variables\n(define-data-var wl-sale-active bool false)\n(define-data-var sale-active bool false)\n(define-data-var last-block uint u0)\n(define-data-var byte-id uint u0)\n(define-data-var picked-id uint u0)\n(define-data-var last-vrf (buff 64) 0x00)\n\n;; Maps\n(define-map wl-count principal uint)\n(define-map treasure-phase-1 { id: uint} {claim: bool})\n(define-map treasure-phase-2 { id: uint} {claim: bool})\n(define-map treasure-phase-3 { id: uint} {claim: bool})\n(define-map chest-phase-1 { id: uint} {claim: bool})\n(define-map chest-phase-2 { id: uint} {claim: bool})\n(define-map chest-phase-3 { id: uint} {claim: bool})\n(define-map tokens-phase-1 { id: uint} {claim: bool})\n(define-map tokens-phase-2 { id: uint} {claim: bool})\n(define-map tokens-phase-3 { id: uint} {claim: bool})\n(define-map stx-phase-1 { id: uint} {claim: bool})\n(define-map stx-phase-2 { id: uint} {claim: bool})\n(define-map stx-phase-3 { id: uint} {claim: bool})\n\n;; Get whitelist balance\n(define-read-only (get-wl-balance (account principal))\n  (default-to u0\n    (map-get? wl-count account)))\n\n;; Check whitelist sales active\n(define-read-only (wl-enabled)\n  (ok (var-get wl-sale-active)))\n\n;; Check public sales active\n(define-read-only (public-enabled)\n  (ok (var-get sale-active)))\n\n;; Set whitelist sale flag (only contract owner)\n(define-public (flip-wl-sale)\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (var-set wl-sale-active (not (var-get wl-sale-active)))\n    (ok (var-get wl-sale-active))))\n\n;; Set public sale flag (only contract owner)\n(define-public (flip-sale)\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (var-set sale-active (not (var-get sale-active)))\n    (ok (var-get sale-active))))\n\n;; Deposit SIP-010 tokens in contract (only contract owner)\n(define-public (deposit-ft (asset <ft-trait>) (amount uint))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (try! (contract-call? asset transfer amount tx-sender (as-contract tx-sender) none))\n  (ok true)))\n\n;; Withdrawal SIP-010 tokens from contract (only contract owner)\n(define-public (withdraw-ft (asset <ft-trait>) (amount uint))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (try! (as-contract (contract-call? asset transfer amount tx-sender CONTRACT-OWNER none)))\n  (ok true)))\n\n;; Deposit STX in contract (only contract owner)\n(define-public (deposit-stx (amount uint))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))\n  (ok true)))\n\n;; Withdrawal STX from contract (only contract owner)\n(define-public (withdraw-stx (amount uint))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (try! (as-contract (stx-transfer? amount tx-sender CONTRACT-OWNER)))\n  (ok true)))\n\n;; Set whitelist wallets (only contract owner)\n(define-public (set-wl-wallets (wallet principal) (amount uint))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set wl-count wallet amount)\n  (ok true)))\n\n;; Set treasures ids / Phase 1 (only contract owner)\n(define-public (set-treasure-phase-1 (nft-id uint) (status bool))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set treasure-phase-1 { id: nft-id } { claim: status})\n  (ok true)))\n\n;; Set treasures ids / Phase 2 (only contract owner)\n(define-public (set-treasure-phase-2 (nft-id uint) (status bool))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set treasure-phase-2 { id: nft-id } { claim: status})\n  (ok true)))\n\n;; Set treasures ids / Phase 3 (only contract owner)\n(define-public (set-treasure-phase-3 (nft-id uint) (status bool))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set treasure-phase-3 { id: nft-id } { claim: status})\n  (ok true)))\n\n;; Set chests ids / Phase 1 (only contract owner)\n(define-public (set-chest-phase-1 (nft-id uint) (status bool))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set chest-phase-1 { id: nft-id } { claim: status})\n  (ok true)))\n\n;; Set chests ids / Phase 2 (only contract owner)\n(define-public (set-chest-phase-2 (nft-id uint) (status bool))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set chest-phase-2 { id: nft-id } { claim: status})\n  (ok true)))\n\n;; Set chests ids / Phase 3 (only contract owner)\n(define-public (set-chest-phase-3 (nft-id uint) (status bool))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set chest-phase-3 { id: nft-id } { claim: status})\n  (ok true)))\n\n;; Set tokens ids / Phase 1 (only contract owner)\n(define-public (set-tokens-phase-1 (nft-id uint) (status bool))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set tokens-phase-1 { id: nft-id } { claim: status})\n  (ok true)))\n\n;; Set tokens ids / Phase 2 (only contract owner)\n(define-public (set-tokens-phase-2 (nft-id uint) (status bool))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set tokens-phase-2 { id: nft-id } { claim: status})\n  (ok true)))\n\n;; Set tokens ids / Phase 3 (only contract owner)\n(define-public (set-tokens-phase-3 (nft-id uint) (status bool))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set tokens-phase-3 { id: nft-id } { claim: status})\n  (ok true)))\n\n;; Set stx reward ids / Phase 1 (only contract owner)\n(define-public (set-stx-phase-1 (nft-id uint) (status bool))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set stx-phase-1 { id: nft-id } { claim: status})\n  (ok true)))\n\n;; Set stx reward ids / Phase 2 (only contract owner)\n(define-public (set-stx-phase-2 (nft-id uint) (status bool))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set stx-phase-2 { id: nft-id } { claim: status})\n  (ok true)))\n\n;; Set stx reward ids / Phase 3 (only contract owner)\n(define-public (set-stx-phase-3 (nft-id uint) (status bool))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set stx-phase-3 { id: nft-id } { claim: status})\n  (ok true)))\n\n;; Claim 1 NFT\n(define-public (claim-one)\n  (begin\n    (try! (claim))\n    (ok true)))\n\n;; Claim 5 NFT\n(define-public (claim-five)\n  (begin\n    (try! (claim))\n    (try! (claim))\n    (try! (claim))\n    (try! (claim))\n    (try! (claim))\n    (ok true)))\n\n;; Claim 10 NFT\n(define-public (claim-ten)\n  (begin\n    (try! (claim))\n    (try! (claim))\n    (try! (claim))\n    (try! (claim))\n    (try! (claim))\n    (try! (claim))\n    (try! (claim))\n    (try! (claim))\n    (try! (claim))\n    (try! (claim))\n    (ok true)))\n\n;; Claim treasure / Phase 1\n(define-public (claim-treasure-phase-1 (id uint) (amount uint))\n  (begin\n    (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase1 get-owner id) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n    (asserts! (is-eq (get claim (unwrap-panic (map-get? treasure-phase-1 { id: id }))) true) ERR-NOT-TREASURE)\n    (try! (send-stx-to-winner amount tx-sender))\n    (map-set treasure-phase-1 { id: id } { claim: false})\n    (print \"Congrats\")\n  (ok true)))\n\n;; Claim treasure / Phase 2\n(define-public (claim-treasure-phase-2 (id uint) (amount uint))\n  (begin\n    (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase2 get-owner id) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n    (asserts! (is-eq (get claim (unwrap-panic (map-get? treasure-phase-2 { id: id }))) true) ERR-NOT-TREASURE)\n    (try! (send-stx-to-winner amount tx-sender))\n    (map-set treasure-phase-2 { id: id } { claim: false})\n    (print \"Congrats\")\n  (ok true)))\n\n;; Claim treasure / Phase 3\n(define-public (claim-treasure-phase-3 (id uint) (amount uint))\n  (begin\n    (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase3 get-owner id) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n    (asserts! (is-eq (get claim (unwrap-panic (map-get? treasure-phase-3 { id: id }))) true) ERR-NOT-TREASURE)\n    (try! (send-stx-to-winner amount tx-sender))\n    (map-set treasure-phase-3 { id: id } { claim: false})\n    (print \"Congrats\")\n  (ok true)))\n\n;; Claim chest / Phase 1\n(define-public (claim-chest-phase-1 (id uint) (amount uint))\n  (begin\n    (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase1 get-owner id) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n    (try! (pick-id))\n        (if (is-eq (mod (var-get picked-id) u2) u0)\n          (begin\n            (asserts! (is-eq (get claim (unwrap-panic (map-get? chest-phase-1 { id: id }))) true) ERR-NOT-CHEST)\n            (try! (send-stx-to-winner amount tx-sender))\n            (map-set chest-phase-1 { id: id } { claim: false})\n            (print \"Congrats\")\n            (ok (var-get picked-id)))\n          (begin\n            (map-set chest-phase-1 { id: id } { claim: false})\n            (print \"Not this time\")\n            (ok (var-get picked-id))))))\n\n;; Claim chest / Phase 2\n(define-public (claim-chest-phase-2 (id uint) (amount uint))\n  (begin\n    (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase2 get-owner id) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n    (try! (pick-id))\n        (if (is-eq (mod (var-get picked-id) u2) u0)\n          (begin\n            (asserts! (is-eq (get claim (unwrap-panic (map-get? chest-phase-2 { id: id }))) true) ERR-NOT-CHEST)\n            (try! (send-stx-to-winner amount tx-sender))\n            (map-set chest-phase-2 { id: id } { claim: false})\n            (print \"Congrats\")\n            (ok (var-get picked-id)))\n          (begin\n            (map-set chest-phase-2 { id: id } { claim: false})\n            (print \"Not this time\")\n            (ok (var-get picked-id))))))\n\n;; Claim chest / Phase 3\n(define-public (claim-chest-phase-3 (id uint) (amount uint))\n  (begin\n    (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase3 get-owner id) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n    (try! (pick-id))\n        (if (is-eq (mod (var-get picked-id) u2) u0)\n          (begin\n            (asserts! (is-eq (get claim (unwrap-panic (map-get? chest-phase-3 { id: id }))) true) ERR-NOT-CHEST)\n            (try! (send-stx-to-winner amount tx-sender))\n            (map-set chest-phase-3 { id: id } { claim: false})\n            (print \"Congrats\")\n            (ok (var-get picked-id)))\n          (begin\n            (map-set chest-phase-3 { id: id } { claim: false})\n            (print \"Not this time\")\n            (ok (var-get picked-id))))))\n\n;; Claim STX / Phase 1\n(define-public (claim-stx-phase-1 (id uint) (amount uint))\n  (begin\n    (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase1 get-owner id) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n    (asserts! (is-eq (get claim (unwrap-panic (map-get? stx-phase-1 { id: id }))) true) ERR-NOT-STX)\n    (try! (send-stx-to-winner amount tx-sender))\n    (map-set stx-phase-1 { id: id } { claim: false})\n    (print \"Congrats\")\n  (ok true)))\n\n;; Claim STX / Phase 2\n(define-public (claim-stx-phase-2 (id uint) (amount uint))\n  (begin\n    (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase2 get-owner id) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n    (asserts! (is-eq (get claim (unwrap-panic (map-get? stx-phase-2 { id: id }))) true) ERR-NOT-STX)\n    (try! (send-stx-to-winner amount tx-sender))\n    (map-set stx-phase-2 { id: id } { claim: false})\n    (print \"Congrats\")\n  (ok true)))\n\n;; Claim STX / Phase 3\n(define-public (claim-stx-phase-3 (id uint) (amount uint))\n  (begin\n    (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase3 get-owner id) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n    (asserts! (is-eq (get claim (unwrap-panic (map-get? stx-phase-3 { id: id }))) true) ERR-NOT-STX)\n    (try! (send-stx-to-winner amount tx-sender))\n    (map-set stx-phase-3 { id: id } { claim: false})\n    (print \"Congrats\")\n  (ok true)))\n\n;; Claim FT / Phase 1\n(define-public (claim-tokens-phase-1 (asset <ft-trait>) (id uint) (amount uint))\n  (begin\n    (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase1 get-owner id) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n    (asserts! (is-eq (get claim (unwrap-panic (map-get? tokens-phase-1 { id: id }))) true) ERR-NOT-TOKENS)\n    (try! (send-ft-to-winner asset amount tx-sender))\n    (map-set tokens-phase-1 { id: id } { claim: false})\n    (print \"Congrats\")\n  (ok true)))\n\n;; Claim FT / Phase 2\n(define-public (claim-tokens-phase-2 (asset <ft-trait>) (id uint) (amount uint))\n  (begin\n    (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase2 get-owner id) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n    (asserts! (is-eq (get claim (unwrap-panic (map-get? tokens-phase-2 { id: id }))) true) ERR-NOT-TOKENS)\n    (try! (send-ft-to-winner asset amount tx-sender))\n    (map-set tokens-phase-2 { id: id } { claim: false})\n    (print \"Congrats\")\n  (ok true)))\n\n;; Claim FT / Phase 3\n(define-public (claim-tokens-phase-3 (asset <ft-trait>) (id uint) (amount uint))\n  (begin\n    (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase3 get-owner id) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n    (asserts! (is-eq (get claim (unwrap-panic (map-get? tokens-phase-3 { id: id }))) true) ERR-NOT-TOKENS)\n    (try! (send-ft-to-winner asset amount tx-sender))\n    (map-set tokens-phase-3 { id: id } { claim: false})\n    (print \"Congrats\")\n  (ok true)))\n\n;; Burn 5 NFTs / Phase 1\n(define-public (burn-phase-1 (id1 uint) (id2 uint) (id3 uint) (id4 uint) (id5 uint))\n  (begin\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase1 get-owner id1) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase1 get-owner id2) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase1 get-owner id3) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase1 get-owner id4) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase1 get-owner id5) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (try! (contract-call? .skullcoin-competitive-g1-phase1 transfer id1 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase1 transfer id2 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase1 transfer id3 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase1 transfer id4 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase1 transfer id5 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase2 mint tx-sender))\n      (try! (contract-call? .skullcoin-competitive-g1-phase2 mint tx-sender))\n      (ok true)))\n\n;; Burn 5 NFTs / Phase 2\n(define-public (burn-phase-2 (id1 uint) (id2 uint) (id3 uint) (id4 uint) (id5 uint))\n  (begin\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase2 get-owner id1) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase2 get-owner id2) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase2 get-owner id3) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase2 get-owner id4) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase2 get-owner id5) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (try! (contract-call? .skullcoin-competitive-g1-phase2 transfer id1 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase2 transfer id2 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase2 transfer id3 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase2 transfer id4 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase2 transfer id5 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase3 mint tx-sender))\n      (try! (contract-call? .skullcoin-competitive-g1-phase3 mint tx-sender))\n      (ok true)))\n\n;; Burn 5 NFTs / Phase 3\n(define-public (burn-phase-3 (id1 uint) (id2 uint) (id3 uint) (id4 uint) (id5 uint))\n  (begin\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase3 get-owner id1) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase3 get-owner id2) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase3 get-owner id3) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase3 get-owner id4) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (asserts! (is-eq (unwrap! (unwrap! (contract-call? .skullcoin-competitive-g1-phase3 get-owner id5) ERR-NOT-OWNER) ERR-NOT-OWNER) tx-sender) ERR-NOT-OWNER)\n      (try! (contract-call? .skullcoin-competitive-g1-phase3 transfer id1 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase3 transfer id2 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase3 transfer id3 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase3 transfer id4 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase3 transfer id5 tx-sender BURN-WALLET))\n      (try! (contract-call? .skullcoin-competitive-g1-phase4 mint tx-sender))\n      (ok true)))\n\n;; Internal - Claim NFT\n(define-private (claim)\n  (if (var-get wl-sale-active)\n    (wl-mint tx-sender)\n    (mint tx-sender)))\n\n;; Internal - Mint NFT via whitelist\n(define-private (wl-mint (new-owner principal))\n  (let ((wl-balance (get-wl-balance new-owner)))\n    (asserts! (> wl-balance u0) ERR-NO-WL-REMAINING)\n    (map-set wl-count new-owner (- wl-balance u1))\n    (try! (contract-call? .skullcoin-competitive-g1-phase1 mint new-owner))\n    (ok true)))\n\n;; Internal - Mint NFT via public\n(define-private (mint (new-owner principal))\n  (begin\n    (asserts! (var-get sale-active) ERR-SALE-NOT-ACTIVE)\n    (try! (contract-call? .skullcoin-competitive-g1-phase1 mint new-owner))\n    (ok true)))\n\n;; Internal - Send STX to winner player in claim function for treasure/chest/stx NFTs\n(define-private (send-stx-to-winner (amount uint) (player principal))\n  (begin\n    (try! (as-contract (stx-transfer? amount tx-sender player)))\n  (ok true)))\n\n;; Internal - Send SIP-010 tokens to winner player in claim function for tokens NFTs\n(define-private (send-ft-to-winner (asset <ft-trait>) (amount uint) (player principal))\n  (begin\n    (try! (as-contract (contract-call? asset transfer amount tx-sender player none)))\n  (ok true)))\n\n;; Internal - Pick id with RNG based on VRF\n(define-private (pick-id)\n  (let ((vrf (var-get last-vrf))\n        (b-idx (var-get byte-id)))\n    (if (is-eq (var-get last-block) block-height)\n      (begin\n        (asserts! (< b-idx u63) REACHED-BLOCK-PICK-LIMIT)\n        (var-set picked-id (buff-to-uint-be (unwrap-panic (element-at vrf b-idx))))\n        (var-set byte-id (+ b-idx u1))\n        (ok (var-get picked-id)))\n      (begin\n        (set-vrf)\n        (var-set last-block block-height)\n        (var-set picked-id (buff-to-uint-be (unwrap-panic (element-at vrf b-idx))))\n        (var-set byte-id u1)\n        (ok (var-get picked-id))))))\n\n;; Internal - Set VRF from previous block\n(define-private (set-vrf)    \n    (var-set last-vrf (sha512 (unwrap-panic (get-block-info? vrf-seed (- block-height u1))))))\n\n;; Register this contract as allowed to mint\n(as-contract (contract-call? .skullcoin-competitive-g1-phase1 set-mint-address))\n(as-contract (contract-call? .skullcoin-competitive-g1-phase2 set-mint-address))\n(as-contract (contract-call? .skullcoin-competitive-g1-phase3 set-mint-address))\n(as-contract (contract-call? .skullcoin-competitive-g1-phase4 set-mint-address))",
    "analysis": {
      "summary": "This contract manages a competitive game with phases, enabling players to claim treasures, chests, STX, and fungible tokens (FTs), as well as mint and burn NFTs across different phases.",
      "explanation": "The contract is designed to facilitate a multi-phase competitive game where players can claim various rewards and interact with NFTs. It includes mechanisms for minting, claiming, and burning NFTs, alongside managing sales and whitelist access. Here's a detailed breakdown:\n\n1. Constants and Errors <L7-19>: Defines the contract owner, a burn wallet for NFTs, and various error codes for unauthorized access and invalid operations.\n\n2. Variables <L21-26>: Tracks the state of whitelist and public sales, the last block interacted with, a byte identifier for RNG, an identifier for claimed items, and the last VRF value used for randomness.\n\n3. Maps <L29-41>: Stores data about whitelist counts, and the claim status of treasures, chests, tokens, and STX across three phases.\n\n4. Read-only Functions <L43-54>: Include methods to check the balance of whitelisted accounts, and whether whitelist or public sales are active.\n\n5. Sale Management Functions <L56-68>: Allow the contract owner to toggle the state of whitelist and public sales.\n\n6. Asset Management Functions <L70-96>: Enable the contract owner to deposit or withdraw SIP-010 tokens and STX to/from the contract.\n\n7. Whitelist and Reward Setup Functions <L98-187>: Allow the contract owner to set whitelist wallets and define the claimable treasures, chests, tokens, and STX rewards for each phase.\n\n8. Claim Functions <L189-359>: Players can claim NFTs individually or in batches, and claim specific rewards based on the game phase and their ownership of certain NFTs.\n\n9. Burn Functions <L361-409>: Players can burn a set of NFTs to receive new ones, advancing through the game's phases.\n\n10. Internal Functions <L411-464>: Include mechanisms for claiming NFTs, sending rewards to winners, picking a random ID based on VRF for chest claims, and setting the VRF value.\n\n11. Minting Permission <L465-469>: Registers the contract as allowed to mint NFTs for the game's phases.\n\nEach function includes safety checks, primarily ensuring that only the contract owner can perform sensitive operations and that players can only claim rewards they are entitled to. The use of VRF for randomness in chest claims introduces an element of chance into the game.",
      "tags": ["game", "NFT", "fungible-token", "utility"]
    }
  },
  {
    "rank": 38,
    "contract": "SP2N959SER36FZ5QT1CX9BR63W3E8X35WQCMBYYWC.leo-cats",
    "calls": 931,
    "source": ";; leo-cats\n;; contractType: public custom\n\n(impl-trait 'SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait.nft-trait)\n\n(define-non-fungible-token leo-cats uint)\n\n;; Constants\n(define-constant DEPLOYER tx-sender)\n(define-constant COMM u1000)\n(define-constant COMM-ADDR 'SPNWZ5V2TPWGQGVDR6T7B6RQ4XMGZ4PXTEE0VQ0S)\n\n(define-constant ERR-NO-MORE-NFTS u100)\n(define-constant ERR-NOT-ENOUGH-PASSES u101)\n(define-constant ERR-PUBLIC-SALE-DISABLED u102)\n(define-constant ERR-CONTRACT-INITIALIZED u103)\n(define-constant ERR-NOT-AUTHORIZED u104)\n(define-constant ERR-INVALID-USER u105)\n(define-constant ERR-LISTING u106)\n(define-constant ERR-WRONG-COMMISSION u107)\n(define-constant ERR-NOT-FOUND u108)\n(define-constant ERR-PAUSED u109)\n(define-constant ERR-MINT-LIMIT u110)\n(define-constant ERR-METADATA-FROZEN u111)\n(define-constant ERR-AIRDROP-CALLED u112)\n(define-constant ERR-NO-MORE-MINTS u113)\n(define-constant ERR-INVALID-PERCENTAGE u114)\n\n;; Internal variables\n(define-data-var mint-limit uint u10000)\n(define-data-var last-id uint u1)\n(define-data-var total-price uint u0)\n(define-data-var artist-address principal 'SP2N959SER36FZ5QT1CX9BR63W3E8X35WQCMBYYWC)\n(define-data-var ipfs-root (string-ascii 80) \"ipfs://ipfs/QmaAUry6B3QtuRSt4xSXy5eRHdhemmF8Gr3WSsiQkzHssX/json/\")\n(define-data-var mint-paused bool true)\n(define-data-var premint-enabled bool false)\n(define-data-var sale-enabled bool false)\n(define-data-var metadata-frozen bool false)\n(define-data-var airdrop-called bool false)\n(define-data-var mint-cap uint u0)\n\n(define-map mints-per-user principal uint)\n(define-map mint-passes principal uint)\n\n(define-public (claim) \n  (mint (list true)))\n\n(define-public (claim-two) (mint (list true true)))\n\n(define-public (claim-three) (mint (list true true true)))\n\n(define-public (claim-four) (mint (list true true true true)))\n\n(define-public (claim-five) (mint (list true true true true true)))\n\n(define-public (claim-six) (mint (list true true true true true true)))\n\n(define-public (claim-seven) (mint (list true true true true true true true)))\n\n(define-public (claim-eight) (mint (list true true true true true true true true)))\n\n(define-public (claim-nine) (mint (list true true true true true true true true true)))\n\n(define-public (claim-ten) (mint (list true true true true true true true true true true)))\n\n;; Mintpass Minting\n(define-private (mint (orders (list 25 bool)))\n  (let \n    (\n      (passes (get-passes tx-sender))\n    )\n    (if (var-get premint-enabled)\n      (begin\n        (asserts! (>= passes (len orders)) (err ERR-NOT-ENOUGH-PASSES))\n        (map-set mint-passes tx-sender (- passes (len orders)))\n        (mint-many orders)\n      )\n      (begin\n        (asserts! (var-get sale-enabled) (err ERR-PUBLIC-SALE-DISABLED))\n        (mint-many orders)\n      )\n    )))\n\n(define-private (mint-many (orders (list 25 bool )))  \n  (let \n    (\n      (last-nft-id (var-get last-id))\n      (enabled (asserts! (<= last-nft-id (var-get mint-limit)) (err ERR-NO-MORE-NFTS)))\n      (art-addr (var-get artist-address))\n      (id-reached (fold mint-many-iter orders last-nft-id))\n      (price (* (var-get total-price) (- id-reached last-nft-id)))\n      (total-commission (/ (* price COMM) u10000))\n      (current-balance (get-balance tx-sender))\n      (total-artist (- price total-commission))\n      (capped (> (var-get mint-cap) u0))\n      (user-mints (get-mints tx-sender))\n    )\n    (asserts! (or (is-eq false (var-get mint-paused)) (is-eq tx-sender DEPLOYER)) (err ERR-PAUSED))\n    (asserts! (or (not capped) (is-eq tx-sender DEPLOYER) (is-eq tx-sender art-addr) (>= (var-get mint-cap) (+ (len orders) user-mints))) (err ERR-NO-MORE-MINTS))\n    (map-set mints-per-user tx-sender (+ (len orders) user-mints))\n    (if (or (is-eq tx-sender art-addr) (is-eq tx-sender DEPLOYER) (is-eq (var-get total-price) u0000000))\n      (begin\n        (var-set last-id id-reached)\n        (map-set token-count tx-sender (+ current-balance (- id-reached last-nft-id)))\n      )\n      (begin\n        (var-set last-id id-reached)\n        (map-set token-count tx-sender (+ current-balance (- id-reached last-nft-id)))\n        (try! (stx-transfer? total-artist tx-sender (var-get artist-address)))\n        (try! (stx-transfer? total-commission tx-sender COMM-ADDR))\n      )    \n    )\n    (ok id-reached)))\n\n(define-private (mint-many-iter (ignore bool) (next-id uint))\n  (if (<= next-id (var-get mint-limit))\n    (begin\n      (unwrap! (nft-mint? leo-cats next-id tx-sender) next-id)\n      (+ next-id u1)    \n    )\n    next-id))\n\n(define-public (set-artist-address (address principal))\n  (begin\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-INVALID-USER))\n    (ok (var-set artist-address address))))\n\n(define-public (set-price (price uint))\n  (begin\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-INVALID-USER))\n    (ok (var-set total-price price))))\n\n(define-public (toggle-pause)\n  (begin\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-INVALID-USER))\n    (ok (var-set mint-paused (not (var-get mint-paused))))))\n\n(define-public (set-mint-limit (limit uint))\n  (begin\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-INVALID-USER))\n    (asserts! (< limit (var-get mint-limit)) (err ERR-MINT-LIMIT))\n    (ok (var-set mint-limit limit))))\n\n(define-public (burn (token-id uint))\n  (begin \n    (asserts! (is-owner token-id tx-sender) (err ERR-NOT-AUTHORIZED))\n    (asserts! (is-none (map-get? market token-id)) (err ERR-LISTING))\n    (nft-burn? leo-cats token-id tx-sender)))\n\n(define-private (is-owner (token-id uint) (user principal))\n    (is-eq user (unwrap! (nft-get-owner? leo-cats token-id) false)))\n\n(define-public (set-base-uri (new-base-uri (string-ascii 80)))\n  (begin\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-NOT-AUTHORIZED))\n    (asserts! (not (var-get metadata-frozen)) (err ERR-METADATA-FROZEN))\n    (print { notification: \"token-metadata-update\", payload: { token-class: \"nft\", contract-id: (as-contract tx-sender) }})\n    (var-set ipfs-root new-base-uri)\n    (ok true)))\n\n(define-public (freeze-metadata)\n  (begin\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-NOT-AUTHORIZED))\n    (var-set metadata-frozen true)\n    (ok true)))\n\n;; Non-custodial SIP-009 transfer function\n(define-public (transfer (id uint) (sender principal) (recipient principal))\n  (begin\n    (asserts! (is-eq tx-sender sender) (err ERR-NOT-AUTHORIZED))\n    (asserts! (is-none (map-get? market id)) (err ERR-LISTING))\n    (trnsfr id sender recipient)))\n\n;; read-only functions\n(define-read-only (get-owner (token-id uint))\n  (ok (nft-get-owner? leo-cats token-id)))\n\n(define-read-only (get-last-token-id)\n  (ok (- (var-get last-id) u1)))\n\n(define-read-only (get-token-uri (token-id uint))\n  (ok (some (concat (concat (var-get ipfs-root) \"{id}\") \".json\"))))\n\n(define-read-only (get-paused)\n  (ok (var-get mint-paused)))\n\n(define-read-only (get-price)\n  (ok (var-get total-price)))\n\n(define-read-only (get-artist-address)\n  (ok (var-get artist-address)))\n\n(define-read-only (get-mints (caller principal))\n  (default-to u0 (map-get? mints-per-user caller)))\n\n(define-read-only (get-mint-limit)\n  (ok (var-get mint-limit)))\n\n(define-data-var license-uri (string-ascii 90) \"https://images.gamma.io/ipfs/bafkreibjxj4akp5s63vvyby66yjjzzjikrpyu7h2yeq74coib6lgk4ilii\")\n(define-data-var license-name (string-ascii 40) \"COMMERCIAL\")\n\n(define-read-only (get-license-uri)\n  (ok (var-get license-uri)))\n  \n(define-read-only (get-license-name)\n  (ok (var-get license-name)))\n  \n(define-public (set-license-uri (uri (string-ascii 80)))\n  (begin\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-NOT-AUTHORIZED))\n    (ok (var-set license-uri uri))))\n    \n(define-public (set-license-name (name (string-ascii 40)))\n  (begin\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-NOT-AUTHORIZED))\n    (ok (var-set license-name name))))\n\n;; Non-custodial marketplace extras\n(use-trait commission-trait 'SP3D6PV2ACBPEKYJTCMH7HEN02KP87QSP8KTEH335.commission-trait.commission)\n\n(define-map token-count principal uint)\n(define-map market uint {price: uint, commission: principal, royalty: uint})\n\n(define-read-only (get-balance (account principal))\n  (default-to u0\n    (map-get? token-count account)))\n\n(define-private (trnsfr (id uint) (sender principal) (recipient principal))\n  (match (nft-transfer? leo-cats id sender recipient)\n    success\n      (let\n        ((sender-balance (get-balance sender))\n        (recipient-balance (get-balance recipient)))\n          (map-set token-count\n            sender\n            (- sender-balance u1))\n          (map-set token-count\n            recipient\n            (+ recipient-balance u1))\n          (ok success))\n    error (err error)))\n\n(define-private (is-sender-owner (id uint))\n  (let ((owner (unwrap! (nft-get-owner? leo-cats id) false)))\n    (or (is-eq tx-sender owner) (is-eq contract-caller owner))))\n\n(define-read-only (get-listing-in-ustx (id uint))\n  (map-get? market id))\n\n(define-public (list-in-ustx (id uint) (price uint) (comm-trait <commission-trait>))\n  (let ((listing  {price: price, commission: (contract-of comm-trait), royalty: (var-get royalty-percent)}))\n    (asserts! (is-sender-owner id) (err ERR-NOT-AUTHORIZED))\n    (map-set market id listing)\n    (print (merge listing {a: \"list-in-ustx\", id: id}))\n    (ok true)))\n\n(define-public (unlist-in-ustx (id uint))\n  (begin\n    (asserts! (is-sender-owner id) (err ERR-NOT-AUTHORIZED))\n    (map-delete market id)\n    (print {a: \"unlist-in-ustx\", id: id})\n    (ok true)))\n\n(define-public (buy-in-ustx (id uint) (comm-trait <commission-trait>))\n  (let ((owner (unwrap! (nft-get-owner? leo-cats id) (err ERR-NOT-FOUND)))\n      (listing (unwrap! (map-get? market id) (err ERR-LISTING)))\n      (price (get price listing))\n      (royalty (get royalty listing)))\n    (asserts! (is-eq (contract-of comm-trait) (get commission listing)) (err ERR-WRONG-COMMISSION))\n    (try! (stx-transfer? price tx-sender owner))\n    (try! (pay-royalty price royalty))\n    (try! (contract-call? comm-trait pay id price))\n    (try! (trnsfr id owner tx-sender))\n    (map-delete market id)\n    (print {a: \"buy-in-ustx\", id: id})\n    (ok true)))\n    \n(define-data-var royalty-percent uint u0)\n\n(define-read-only (get-royalty-percent)\n  (ok (var-get royalty-percent)))\n\n(define-public (set-royalty-percent (royalty uint))\n  (begin\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-INVALID-USER))\n    (asserts! (and (>= royalty u0) (<= royalty u1000)) (err ERR-INVALID-PERCENTAGE))\n    (ok (var-set royalty-percent royalty))))\n\n(define-private (pay-royalty (price uint) (royalty uint))\n  (let (\n    (royalty-amount (/ (* price royalty) u10000))\n  )\n  (if (and (> royalty-amount u0) (not (is-eq tx-sender (var-get artist-address))))\n    (try! (stx-transfer? royalty-amount tx-sender (var-get artist-address)))\n    (print false)\n  )\n  (ok true)))\n\n;; Extra functionality required for mintpass\n(define-public (toggle-sale-state)\n  (let \n    (\n      ;; (premint (not (var-get premint-enabled)))\n      (sale (not (var-get sale-enabled)))\n    )\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-NOT-AUTHORIZED))\n    (var-set premint-enabled false)\n    (var-set sale-enabled sale)\n    (print { sale: sale })\n    (ok true)))\n\n(define-public (clear-mintpasses (addresses (list 2000 principal)))\n  (let \n    (\n      (index-reached (fold clear-mintpasses-iter addresses u0))\n    )\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-NOT-AUTHORIZED))\n    (print {\n      total-mintpasses-cleared: index-reached,\n    })\n    (ok true)))\n\n(define-public (add-mintpasses (addresses (list 2000 principal)))\n  (let \n    (\n      (index-reached (fold add-mintpasses-iter addresses u0))\n    )\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-NOT-AUTHORIZED))\n    (print {\n      total-mintpasses-added: index-reached,\n    })\n    (ok true)))\n\n(define-private (clear-mintpasses-iter (address principal) (next-index uint))\n  (begin \n    (map-delete mint-passes address)    \n    (+ next-index u1)))\n\n(define-private (add-mintpasses-iter (address principal) (next-index uint))\n  (let \n    (\n      (mintpass-count (get-passes address))\n    ) \n    (map-set mint-passes address (+ mintpass-count u1))\n    (+ next-index u1)))\n\n(define-public (enable-premint)\n  (begin\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-NOT-AUTHORIZED))\n    (ok (var-set premint-enabled true))))\n\n(define-public (disable-premint)\n  (begin\n    (asserts! (or (is-eq tx-sender (var-get artist-address)) (is-eq tx-sender DEPLOYER)) (err ERR-NOT-AUTHORIZED))\n    (ok (var-set premint-enabled false))))\n\n(define-read-only (get-passes (caller principal))\n  (default-to u0 (map-get? mint-passes caller)))\n\n(define-read-only (get-premint-enabled)\n  (ok (var-get premint-enabled)))\n\n(define-read-only (get-sale-enabled)\n  (ok (var-get sale-enabled)))  \n",
    "analysis": {
      "summary": "This contract enables the creation, sale, and management of a non-fungible token (NFT) collection named 'leo-cats', with features including minting, artist commission, and metadata management.",
      "explanation": "The contract starts by implementing an NFT trait from another contract, ensuring it adheres to standard NFT functionalities <L4>. It then defines 'leo-cats' as a non-fungible token using a unique identifier <L6>. The contract includes constants for the deployer, commission rate, commission address, and various error codes <L8-27>. It also defines internal variables to manage mint limits, track the last minted ID, total price, artist address, IPFS root for metadata, minting state, and a cap on mints per user <L29-41>. Two maps are used to track mints per user and mint passes <L42-43>. Public functions allow users to claim up to ten 'leo-cats' NFTs at once, with the actual minting logic handled by a private function <L45-64>. This mint function checks if preminting is enabled or if the sale is open before proceeding with minting <L67-82>. Another private function, 'mint-many', handles the bulk of the minting process, including commission calculation and transferring STX to the artist and commission address <L84-113>. The contract provides functions for setting the artist address, NFT price, pausing minting, adjusting the mint limit, and burning NFTs <L123-148>. Additional functionalities include updating metadata URI, freezing metadata, transferring NFTs in a non-custodial manner, and managing licenses <L153-216>. The contract also integrates a marketplace with commission traits and provides utilities for managing mint passes and toggling sale states <L218-364>.",
      "tags": ["NFT", "utility", "protocol", "game"]
    }
  },
  {
    "rank": 39,
    "contract": "SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-peg-out-endpoint-v2-04",
    "calls": 875,
    "source": ";; SPDX-License-Identifier: BUSL-1.1\n\n(use-trait ft-trait 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.trait-sip-010.sip-010-trait)\n\n(define-constant err-unauthorised (err u1000))\n(define-constant err-paused (err u1001))\n(define-constant err-peg-in-address-not-found (err u1002))\n(define-constant err-invalid-amount (err u1003))\n(define-constant err-token-mismatch (err u1004))\n(define-constant err-invalid-tx (err u1005))\n(define-constant err-already-sent (err u1006))\n(define-constant err-address-mismatch (err u1007))\n(define-constant err-request-already-revoked (err u1008))\n(define-constant err-request-already-finalized (err u1009))\n(define-constant err-revoke-grace-period (err u1010))\n(define-constant err-request-already-claimed (err u1011))\n(define-constant err-invalid-input (err u1012))\n(define-constant err-tx-mined-before-request (err u1013))\n(define-constant err-commit-tx-mismatch (err u1014))\n(define-constant err-invalid-burn-height (err u1003))\n(define-constant err-tx-mined-before-start (err u1015))\n\n(define-constant MAX_UINT u340282366920938463463374607431768211455)\n(define-constant ONE_8 u100000000)\n\n(define-constant burn-height-start burn-block-height)\n\n(define-data-var paused bool true)\n(define-data-var fee-to-address principal tx-sender)\n\n;; read-only functions\n\n(define-read-only (is-dao-or-extension)\n\t(ok (asserts! (or (is-eq tx-sender 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.executor-dao) (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.executor-dao is-extension contract-caller)) err-unauthorised)))\n\n(define-read-only (is-paused)\n\t(var-get paused))\n\n(define-read-only (get-fee-to-address)\n  (var-get fee-to-address))\n\n(define-read-only (get-pair-details (pair { token: principal, chain-id: uint }))\n  (match (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 get-pair-details-or-fail pair)\n    ok-value (some ok-value)\n    err-value none))\n\n(define-read-only (get-pair-details-many (pairs (list 200 { token: principal, chain-id: uint })))\n  (map get-pair-details pairs))\n\n(define-read-only (get-request (request-id uint))\n  (match (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 get-request-or-fail request-id)\n    ok-value (some ok-value)\n    err-value none))\n\n(define-read-only (get-request-many (request-ids (list 200 uint)))\n  (map get-request request-ids))\n\n(define-read-only (get-request-revoke-grace-period)\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 get-request-revoke-grace-period))\n\n(define-read-only (get-request-claim-grace-period)\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 get-request-claim-grace-period))\n\n(define-read-only (is-peg-in-address-approved (address (buff 128)))\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 is-peg-in-address-approved address))\n\n(define-read-only (get-pair-details-or-fail (pair { token: principal, chain-id: uint }))\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 get-pair-details-or-fail pair))\n\n(define-read-only (get-tick-to-pair-or-fail (tick (string-utf8 256)))\n\t(contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 get-tick-to-pair-or-fail tick))\n\n(define-read-only (get-peg-in-sent-or-default (bitcoin-tx (buff 32768)) (output uint) (offset uint))\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 get-peg-in-sent-or-default bitcoin-tx output offset))\n\n(define-read-only (get-request-or-fail (request-id uint))\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 get-request-or-fail request-id))\n\n(define-read-only (validate-peg-out (amount uint) (pair { token: principal, chain-id: uint }))\n  (let (\n      (token-details (try! (get-pair-details-or-fail pair)))\n      (fee (mul-down amount (get peg-out-fee token-details))))\n\t\t(asserts! (> amount fee) err-invalid-amount)\n    (asserts! (not (get peg-out-paused token-details)) err-paused)    \n    (ok { token-details: token-details, fee: fee })))\n\n(define-read-only (is-fulfill-address-approved (address (buff 128)))\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 is-fulfill-address-approved address))\n\n;; governance functions\n\n(define-public (pause (new-paused bool))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ok (var-set paused new-paused))))\n\n(define-public (set-fee-to-address (new-fee-to-address principal))\n  (begin\n    (try! (is-dao-or-extension))\n    (ok (var-set fee-to-address new-fee-to-address))))\n\n(define-public (transfer-all-to (new-owner principal) (token-trait <ft-trait>))\n  (begin \n    (try! (is-dao-or-extension))\n    (as-contract (contract-call? token-trait transfer-fixed (unwrap-panic (contract-call? token-trait get-balance-fixed tx-sender)) tx-sender new-owner none))))\n\n(define-public (transfer-all-to-many (new-owner principal) (token-traits (list 10 <ft-trait>)))\n  (ok (map transfer-all-to (list new-owner new-owner new-owner new-owner new-owner new-owner new-owner new-owner new-owner new-owner) token-traits)))\n\n;; public functions\n\n;; request peg-out of `tick` of `amount` (net of fee) to `peg-out-address`\n;; request escrows the relevant pegged-in token and gas-fee token to the contract until the request is either finalized or revoked.\n;;\n;; token-trait => the trait of pegged-in token\n(define-public (request-peg-out (amount uint) (peg-out-address (buff 128)) (token-trait <ft-trait>) (the-chain-id uint))\n  (let (\n      (token (contract-of token-trait))\n\t\t\t(validation-data (try! (validate-peg-out amount { token: token, chain-id: the-chain-id })))\n      (token-details (get token-details validation-data))\n      (fee (get fee validation-data))\n      (amount-net (- amount fee))\n      (gas-fee (get peg-out-gas-fee token-details))\n      (request-details { requested-by: tx-sender, peg-out-address: peg-out-address, tick: (get tick token-details), token: token, amount-net: amount-net, fee: fee, gas-fee: gas-fee, claimed: u0, claimed-by: tx-sender, fulfilled-by: 0x, revoked: false, finalized: false, requested-at: tenure-height, requested-at-burn-height: burn-block-height })\n      (request-id (as-contract (try! (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 set-request u0 request-details)))))\n    (try! (contract-call? token-trait transfer-fixed amount tx-sender (as-contract tx-sender) none))\n    (and (> gas-fee u0) (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc transfer-fixed gas-fee tx-sender (as-contract tx-sender) none)))\n    (print (merge request-details { type: \"request-peg-out\", request-id: request-id }))\n    (ok true)))\n\n;; claim peg-out request, so that the claimer can safely process the peg-out (within the grace period)\n;;\n(define-public (claim-peg-out (request-id uint) (fulfilled-by (buff 128)))\n  (let (\n      (claimer tx-sender)\n      (request-details (try! (get-request-or-fail request-id)))\n      (token-details (try! (get-pair-details-or-fail (try! (get-tick-to-pair-or-fail (get tick request-details)))))))\n    (asserts! (not (get peg-out-paused token-details)) err-paused)\n    (asserts! (< (get claimed request-details) tenure-height) err-request-already-claimed)\n    (asserts! (not (get revoked request-details)) err-request-already-revoked)\n    (asserts! (not (get finalized request-details)) err-request-already-finalized)\n\n    (as-contract (try! (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 set-request request-id (merge request-details { claimed: (+ tenure-height (get-request-claim-grace-period)), claimed-by: claimer, fulfilled-by: fulfilled-by }))))\n\n    (print (merge request-details { type: \"claim-peg-out\", request-id: request-id, claimed: (+ tenure-height (get-request-claim-grace-period)), claimed-by: claimer, fulfilled-by: fulfilled-by }))\n    (ok true)\n  )\n)\n\n;; finalize peg-out request\n;; finalize `request-id` with `tx`\n;; pays the fee to `fee-to-address` and burn the relevant pegged-in tokens.\n;;\n;; peg-out finalization can be done by either a peg-in address or a non-peg-in (i.e. 3rd party) address\n;; if the latter, then the overall peg-in balance does not change.\n;; the claimer sends non-pegged-in BRC20 tokens to the peg-out requester and receives the pegged-in BRC20 tokens (along with gas-fee)\n;; if the former, then the overall peg-in balance decreases.\n;; the relevant BRC20 tokens are burnt (with fees paid to `fee-to-address`)\n(define-public (finalize-peg-out-on-index (request-id uint)\n  (tx { bitcoin-tx: (buff 32768), output: uint, offset: uint, tick: (string-utf8 256), amt: uint, from: (buff 128), to: (buff 128), from-bal: uint, to-bal: uint, decimals: uint })\n  (block { header: (buff 80), height: uint })\n  (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint })\n  (signature-packs (list 10 { signer: principal, tx-hash: (buff 32), signature: (buff 65) }))\n  (token-trait <ft-trait>))\n  (begin \n    (try! (index-tx tx block proof signature-packs))\n    (finalize-peg-out request-id (get bitcoin-tx tx) (get output tx) (get offset tx) token-trait)))\n\n(define-public (finalize-peg-out (request-id uint) (tx (buff 32768)) (output-idx uint) (offset-idx uint) (token-trait <ft-trait>))\n  (let (\n      (token (contract-of token-trait))\n      (request-details (try! (get-request-or-fail request-id)))\n      (pair-details (try! (get-tick-to-pair-or-fail (get tick request-details))))\n      (token-details (try! (get-pair-details-or-fail pair-details)))\n      (tx-idxed (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.oracle-v2-01 get-bitcoin-tx-indexed-or-fail tx output-idx offset-idx)))\n      (tx-mined-height (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.oracle-v2-01 get-bitcoin-tx-mined-or-fail tx)))\n      (amount-in-decimals (get amt tx-idxed))\n      (fulfilled-by (get from tx-idxed))\n      (is-fulfilled-by-peg-in (or (is-peg-in-address-approved fulfilled-by) (is-fulfill-address-approved fulfilled-by))))\n    (asserts! (not (get peg-out-paused token-details)) err-paused)\n\t\t(asserts! (< burn-height-start tx-mined-height) err-tx-mined-before-start)\n    (asserts! (is-eq token (get token pair-details)) err-token-mismatch)\n    (asserts! (is-eq (get tick request-details) (get tick tx-idxed)) err-token-mismatch)\n    (asserts! (is-eq amount-in-decimals (fixed-to-decimals (get amount-net request-details) (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.oracle-v2-01 get-tick-decimals-or-default (get tick tx-idxed)))) err-invalid-amount)\n    (asserts! (is-eq (get peg-out-address request-details) (get to tx-idxed)) err-address-mismatch)\n    (asserts! (is-eq (get fulfilled-by request-details) fulfilled-by) err-address-mismatch)\n    (asserts! (< (get requested-at-burn-height request-details) tx-mined-height) err-tx-mined-before-request)\n    (asserts! (not (get-peg-in-sent-or-default tx output-idx offset-idx)) err-already-sent)\n    (asserts! (not (get revoked request-details)) err-request-already-revoked)\n    (asserts! (not (get finalized request-details)) err-request-already-finalized)\n\n    (as-contract (try! (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 set-peg-in-sent { tx: tx, output: output-idx, offset: offset-idx } true)))\n    (as-contract (try! (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 set-request request-id (merge request-details { finalized: true }))))\n\n    (and (> (get fee request-details) u0) (as-contract (try! (contract-call? token-trait transfer-fixed (get fee request-details) tx-sender (var-get fee-to-address) none))))\n    (and (> (get gas-fee request-details) u0) (as-contract (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc transfer-fixed (get gas-fee request-details) tx-sender (if is-fulfilled-by-peg-in (var-get fee-to-address) (get claimed-by request-details)) none))))\n\n    (if is-fulfilled-by-peg-in\n      (and (not (get no-burn token-details)) (as-contract (try! (contract-call? token-trait burn-fixed (get amount-net request-details) tx-sender))))\n      (as-contract (try! (contract-call? token-trait transfer-fixed (get amount-net request-details) tx-sender (get claimed-by request-details) none)))\n    )\n\n    (print { type: \"finalize-peg-out\", request-id: request-id, tx: tx })\n    (ok true)))\n\n;; revoke peg-out request\n;; only after `request-revoke-grace-period` passed\n;; returns fee and pegged-in tokens to the requester.\n(define-public (revoke-peg-out (request-id uint) (token-trait <ft-trait>))\n  (let (\n      (token (contract-of token-trait))\n      (request-details (try! (get-request-or-fail request-id)))\n      (pair-details (try! (get-tick-to-pair-or-fail (get tick request-details))))\n      (token-details (try! (get-pair-details-or-fail pair-details))))      \n    (asserts! (> tenure-height (+ (get requested-at request-details) (get-request-revoke-grace-period))) err-revoke-grace-period)\n    (asserts! (is-eq token (get token pair-details)) err-token-mismatch)\n    (asserts! (< (get claimed request-details) tenure-height) err-request-already-claimed)\n    (asserts! (not (get revoked request-details)) err-request-already-revoked)\n    (asserts! (not (get finalized request-details)) err-request-already-finalized)\n\n    (as-contract (try! (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 set-request request-id (merge request-details { revoked: true }))))\n\n    (and (> (get fee request-details) u0) (as-contract (try! (contract-call? token-trait transfer-fixed (get fee request-details) tx-sender (get requested-by request-details) none))))\n    (and (> (get gas-fee request-details) u0) (as-contract (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc transfer-fixed (get gas-fee request-details) tx-sender (get requested-by request-details) none))))\n    (as-contract (try! (contract-call? token-trait transfer-fixed (get amount-net request-details) tx-sender (get requested-by request-details) none)))\n\n    (print { type: \"revoke-peg-out\", request-id: request-id })\n    (ok true)))\n\n;; internal functions\n\n(define-private (index-tx\n  (tx { bitcoin-tx: (buff 32768), output: uint, offset: uint, tick: (string-utf8 256), amt: uint, from: (buff 128), to: (buff 128), from-bal: uint, to-bal: uint, decimals: uint })\n  (block { header: (buff 80), height: uint })\n  (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint })\n  (signature-packs (list 10 { signer: principal, tx-hash: (buff 32), signature: (buff 65) })))\n  (begin \n    (and \n      (not (is-ok (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.oracle-v2-01 get-bitcoin-tx-indexed-or-fail (get bitcoin-tx tx) (get output tx) (get offset tx))))\n      (as-contract (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.oracle-v2-01 index-tx-many (list { tx: tx, block: block, proof: proof, signature-packs: signature-packs })))))\n    (print { type: \"indexed-tx\", tx: tx, block: block, proof: proof, signature-packs: signature-packs })\n    (ok true)))\n\n(define-private (min (a uint) (b uint))\n  (if (< a b) a b))\n\n(define-private (mul-down (a uint) (b uint))\n  (/ (* a b) ONE_8))\n\n(define-private (div-down (a uint) (b uint))\n  (if (is-eq a u0) u0 (/ (* a ONE_8) b)))\n\n(define-private (decimals-to-fixed (amount uint) (decimals uint))\n  (/ (* amount ONE_8) (pow u10 decimals)))\n\n(define-private (fixed-to-decimals (amount uint) (decimals uint))\n  (/ (* amount (pow u10 decimals)) ONE_8))",
    "analysis": {
      "summary": "This contract facilitates peg-out requests, allowing users to convert blockchain assets into Bitcoin transactions, and manages these requests through creation, claiming, finalization, and revocation.",
      "explanation": "The contract starts with importing a fungible token (FT) trait for SIP-010 compliance <L3>, ensuring it can interact with standard Clarity tokens. It then defines a series of error constants <L5-22> for handling various failure states, such as unauthorized access or invalid transactions, and sets up constants for calculations and a starting block height <L23-26>. The contract's state includes whether it's paused and a fee address, both initially set <L28-29>. The read-only functions <L31-76> provide information about the contract's state, requests, and token pairs, leveraging another contract for metadata and validation. The governance functions <L90-108> allow DAO or authorized extensions to pause the contract, change the fee address, or transfer all tokens to a new owner, ensuring administrative control. The core functionality revolves around peg-out requests <L112-228>, where users can request to convert their tokens to Bitcoin, claim these requests for processing, finalize them by proving a Bitcoin transaction, or revoke them if necessary. Internal functions <L230-256> support these features by indexing Bitcoin transactions, performing arithmetic operations, and converting between fixed and decimal representations of amounts. The contract heavily interacts with external contracts for token balances, metadata, and oracle services, ensuring robust and secure operations.",
      "tags": ["utility", "bridge", "oracle", "protocol"],
      "notable_qualities": [
        "Integrates with external contracts for enhanced functionality, such as token metadata and oracle services.",
        "Employs a governance model allowing DAO or extensions to control key parameters and operations.",
        "Supports a complex peg-out process with multiple steps, including request creation, claiming, finalization, and revocation.",
        "Utilizes detailed error handling to manage various failure states and ensure contract reliability.",
        "Performs precise arithmetic operations, including fixed-point math, to handle token amounts accurately."
      ]
    }
  },
  {
    "rank": 40,
    "contract": "SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-peg-in-v2-04-swap",
    "calls": 824,
    "source": ";; SPDX-License-Identifier: BUSL-1.1\n\n(use-trait ft-trait 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.trait-sip-010.sip-010-trait)\n\n(define-constant err-unauthorised (err u1000))\n(define-constant err-paused (err u1001))\n(define-constant err-peg-in-address-not-found (err u1002))\n(define-constant err-invalid-amount (err u1003))\n(define-constant err-token-mismatch (err u1004))\n(define-constant err-invalid-tx (err u1005))\n(define-constant err-already-sent (err u1006))\n(define-constant err-address-mismatch (err u1007))\n(define-constant err-request-already-revoked (err u1008))\n(define-constant err-request-already-finalized (err u1009))\n(define-constant err-revoke-grace-period (err u1010))\n(define-constant err-request-already-claimed (err u1011))\n(define-constant err-invalid-input (err u1012))\n(define-constant err-tx-mined-before-request (err u1013))\n(define-constant err-commit-tx-mismatch (err u1014))\n(define-constant err-invalid-burn-height (err u1003))\n(define-constant err-tx-mined-before-start (err u1015))\n(define-constant err-slippage-error (err u1016))\n(define-constant err-bitcoin-tx-not-mined (err u1017))\n(define-constant err-invalid-routing (err u1018))\n\n(define-constant MAX_UINT u340282366920938463463374607431768211455)\n(define-constant ONE_8 u100000000)\n\n(define-constant burn-height-start burn-block-height)\n\n(define-data-var paused bool true)\n(define-data-var fee-to-address principal 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.executor-dao)\n\n(define-data-var peg-in-fee uint u0) ;; fixed in BTC\n\n;; read-only functions\n\n(define-read-only (is-dao-or-extension)\n\t(ok (asserts! (or (is-eq tx-sender 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.executor-dao) (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.executor-dao is-extension contract-caller)) err-unauthorised)))\n\n(define-read-only (is-paused)\n\t(var-get paused))\n\n(define-read-only (get-fee-to-address)\n  (var-get fee-to-address))\n\n(define-read-only (get-peg-in-fee)\n\t(var-get peg-in-fee))\n\n(define-read-only (get-pair-details (pair { token: principal, chain-id: uint }))\n  (match (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 get-pair-details-or-fail pair) ok-value (some ok-value) err-value none))\n\n(define-read-only (get-pair-details-many (pairs (list 200 { token: principal, chain-id: uint })))\n  (map get-pair-details pairs))\n\n(define-read-only (get-tick-to-pair-or-fail (tick (string-utf8 256)))\n\t(contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 get-tick-to-pair-or-fail tick))\n\n(define-read-only (is-peg-in-address-approved (address (buff 128)))\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 is-peg-in-address-approved address))\n\n(define-read-only (get-pair-details-or-fail (pair { token: principal, chain-id: uint }))\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 get-pair-details-or-fail pair))\n\n(define-read-only (is-approved-pair (pair { token: principal, chain-id: uint }))\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 is-approved-pair pair))\n\n(define-read-only (get-peg-in-sent-or-default (bitcoin-tx (buff 32768)) (output uint) (offset uint))\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 get-peg-in-sent-or-default bitcoin-tx output offset))\n\n;; @dev cross-swap order size > 80 bytes, so uses drop\n(define-read-only (create-order-cross-swap-or-fail (order { from: (buff 128), to: (buff 128), routing: (list 4 uint), token-out: principal, min-amount-out: (optional uint), chain-id: (optional uint) }))\n\t(contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.bridge-common-v2-02 create-order-cross-swap-or-fail order))\n\n;; @dev no op-code offset for drop-based order\n(define-read-only (decode-order-cross-swap-or-fail (order-script (buff 512)))\n\t(contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.bridge-common-v2-02 decode-order-cross-swap-or-fail order-script u0))\n\n(define-read-only (decode-order-cross-swap-from-reveal-tx-or-fail (tx (buff 32768)) (order-idx uint))\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.bridge-common-v2-02 decode-order-cross-swap-from-reveal-tx-or-fail tx order-idx))\n\n(define-read-only (validate-tx-cross-swap (commit-tx { tx: (buff 32768), output-idx: uint, fee-idx: (optional uint) }) (reveal-tx { tx: (buff 32768), order-idx: uint }) (routing-traits (list 5 <ft-trait>)) (token-out-trait <ft-trait>))\n\t(validate-tx-cross-swap-extra (try! (validate-tx-cross-swap-base commit-tx reveal-tx)) routing-traits token-out-trait))\n\n(define-read-only (break-routing-id (token-in principal) (routing-ids (list 4 uint)))\n\t(fold break-routing-id-iter routing-ids (ok { routing-tokens: (list token-in), routing-factors: (list ) })))\n\n;; governance functions\n(define-public (pause (new-paused bool))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ok (var-set paused new-paused))))\n\n(define-public (set-fee-to-address (new-fee-to-address principal))\n  (begin\n    (try! (is-dao-or-extension))\n    (ok (var-set fee-to-address new-fee-to-address))))\n\n(define-public (set-peg-in-fee (fee uint))\n\t(begin\n\t\t(try! (is-dao-or-extension))\n\t\t(ok (var-set peg-in-fee fee))))\n\n(define-public (transfer-all-to (new-owner principal) (token-trait <ft-trait>))\n  (begin \n    (try! (is-dao-or-extension))\n    (as-contract (contract-call? token-trait transfer-fixed (unwrap-panic (contract-call? token-trait get-balance-fixed tx-sender)) tx-sender new-owner none))))\n\n(define-public (transfer-all-to-many (new-owner principal) (token-traits (list 10 <ft-trait>)))\n  (ok (map transfer-all-to (list new-owner new-owner new-owner new-owner new-owner new-owner new-owner new-owner new-owner new-owner) token-traits)))\n\n;; public functions\n\n(define-public (finalize-peg-in-cross-swap-on-index\n  (tx { bitcoin-tx: (buff 32768), output: uint, tick: (string-utf8 256), amt: uint, from: (buff 128), to: (buff 128), from-bal: uint, to-bal: uint, decimals: uint })\n  (block { header: (buff 80), height: uint })\n  (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint })\n  (signature-packs (list 10 { signer: principal, tx-hash: (buff 32), signature: (buff 65) }))\n  (reveal-tx { tx: (buff 32768), order-idx: uint }) \n  (reveal-block { header: (buff 80), height: uint })\n  (reveal-proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint })    \n  (fee-idx (optional uint)) (routing-traits (list 5 <ft-trait>)) (token-out-trait <ft-trait>)) \n  (begin\n    (try! (index-tx tx block proof signature-packs))\n    (finalize-peg-in-cross-swap { tx: (get bitcoin-tx tx), output-idx: (get output tx), fee-idx: fee-idx } reveal-tx reveal-block reveal-proof routing-traits token-out-trait)))\n\n(define-public (finalize-peg-in-cross-swap \n  (commit-tx { tx: (buff 32768), output-idx: uint, fee-idx: (optional uint) }) \n  (reveal-tx { tx: (buff 32768), order-idx: uint }) \n  (reveal-block { header: (buff 80), height: uint })\n  (reveal-proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint })    \n  (routing-traits (list 5 <ft-trait>)) (token-out-trait <ft-trait>))\n  (let (\n      (is-reveal-tx-mined (try! (verify-mined (get tx reveal-tx) reveal-block reveal-proof)))\n      (validation-data (try! (validate-tx-cross-swap-base commit-tx reveal-tx)))\n\t\t\t(token-trait (unwrap-panic (element-at? routing-traits u0)))\n      (tx (get tx commit-tx))\n      (order-details (get order-details validation-data))\n\t\t\t(token-details (get token-details validation-data))\n      (fee (get fee validation-data))\n      (amt-net (get amt-net validation-data))\n\t\t\t(print-msg (merge (get tx-idxed validation-data) { type: \"finalize-peg-in-cross-swap\", order-details: order-details, fee: fee, amt-net: amt-net, tx-id: (try! (get-txid tx)), output-idx: (get output-idx commit-tx), offset-idx: u0 })))\n    (asserts! (not (get peg-in-paused token-details)) err-paused)\n\t\t(asserts! (< burn-height-start (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.oracle-v2-01 get-bitcoin-tx-mined-or-fail tx))) err-tx-mined-before-start)\t\t\n    (match (get fee-idx commit-tx) some-value (as-contract (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.btc-bridge-registry-v2-01 set-peg-in-sent tx some-value true))) true)\n    (as-contract (try! (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 set-peg-in-sent { tx: tx, output: (get output-idx commit-tx), offset: u0 } true)))\n    (and (> fee u0) (as-contract (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc mint-fixed fee tx-sender))))\n    (try! (check-trait token-trait (get token (get pair-details validation-data))))\n    (and (> amt-net u0) (if (get no-burn token-details) \n      (let (\n          (peg-out-balance (- (unwrap-panic (contract-call? token-trait get-balance-fixed .meta-peg-out-endpoint-v2-04)) amt-net))) \n        (as-contract (try! (contract-call? .meta-peg-out-endpoint-v2-04 transfer-all-to tx-sender token-trait)))\n        (as-contract (try! (contract-call? token-trait transfer-fixed peg-out-balance tx-sender .meta-peg-out-endpoint-v2-04 none))))\n      (as-contract (try! (contract-call? token-trait mint-fixed amt-net tx-sender)))))\n\t\t(match (validate-tx-cross-swap-extra validation-data routing-traits token-out-trait)\n\t\t\tok-value\n\t\t\t(begin\n\t\t\t\t(and (> fee u0) (as-contract (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.token-abtc transfer-fixed fee tx-sender (var-get fee-to-address) none))))\n\t\t\t\t(as-contract (try! (contract-call? .cross-router-v2-03 route amt-net routing-traits (get routing-factors ok-value) token-out-trait (get min-amount-out order-details) { address: (get to order-details), chain-id: (get chain-id order-details) })))\n\t\t\t\t(print (merge print-msg { success: true }))\n\t\t\t\t(ok true))\n\t\t\terr-value\n\t\t\t(begin \n        (as-contract (try! (refund fee amt-net (get from order-details) token-trait (get chain-id (get pair-details validation-data)))))\n\t\t\t\t(print (merge print-msg { success: false, err-value: err-value }))\n\t\t\t\t(ok false)))))\n\n;; internal functions\n\n(define-private (validate-tx-cross-swap-base (commit-tx { tx: (buff 32768), output-idx: uint, fee-idx: (optional uint) }) (reveal-tx { tx: (buff 32768), order-idx: uint }))\n  (let (\n\t\t\t(validation-data (try! (validate-drop-common commit-tx)))\n\t\t\t(reveal-tx-data (try! (decode-order-cross-swap-from-reveal-tx-or-fail (get tx reveal-tx) (get order-idx reveal-tx)))))\n    (asserts! (is-eq (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.clarity-bitcoin-v1-07 get-segwit-txid (get tx commit-tx)) (get commit-txid reveal-tx-data)) err-commit-tx-mismatch)\n    (ok (merge validation-data { order-details: (get order-details reveal-tx-data) }))))\n\n(define-private (validate-tx-cross-swap-extra\n  (validation-data { \n    fee: uint, amt-net: uint, \n    tx-idxed: { tick: (string-utf8 256), amt: uint, from: (buff 128), to: (buff 128) }, \n    pair-details: { token: principal, chain-id: uint },\n    token-details: { approved: bool, tick: (string-utf8 256), peg-in-paused: bool, peg-out-paused: bool, peg-in-fee: uint, peg-out-fee: uint, peg-out-gas-fee: uint, no-burn: bool },\n    order-details: { from: (buff 128), to: (buff 128), routing: (list 4 uint), token-out: principal, min-amount-out: (optional uint), chain-id: (optional uint) }})\n  (routing-traits (list 5 <ft-trait>))\n  (token-out-trait <ft-trait>))\n\t(let (\t\t\t\n\t\t\t(order-details (get order-details validation-data))\n      (token-in-trait (unwrap-panic (element-at? routing-traits u0)))\n\t\t\t(routing-details (try! (break-routing-id (contract-of token-in-trait) (get routing order-details)))))\n    (asserts! (is-eq (len routing-traits) (len (get routing-tokens routing-details))) err-token-mismatch)\n    (asserts! (is-ok (fold check-err (map check-trait routing-traits (get routing-tokens routing-details)) (ok true))) err-token-mismatch)\n    (try! (check-trait token-out-trait (get token-out order-details)))\n\t\t(try! (contract-call? .cross-router-v2-03 validate-route (get amt-net validation-data) (get routing-tokens routing-details) (get routing-factors routing-details) (get token-out order-details) (get min-amount-out order-details) { address: (get to order-details), chain-id: (get chain-id order-details) }))\n\t\t(ok (merge validation-data { routing-tokens: (get routing-tokens routing-details), routing-factors: (get routing-factors routing-details) }))))\n\n(define-private (validate-drop-common (commit-tx { tx: (buff 32768), output-idx: uint, fee-idx: (optional uint) }))\n\t(let (\n      (tx-idxed (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.oracle-v2-01 get-bitcoin-tx-indexed-or-fail (get tx commit-tx) (get output-idx commit-tx) u0)))      \n      (pair-details (try! (get-tick-to-pair-or-fail (get tick tx-idxed))))\n      (token-details (try! (get-pair-details-or-fail pair-details)))\n      (amt-in-fixed (decimals-to-fixed (get amt tx-idxed) (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.oracle-v2-01 get-tick-decimals-or-default (get tick tx-idxed)))))    \n    (asserts! (get approved token-details) err-unauthorised)\n    (asserts! (not (get-peg-in-sent-or-default (get tx commit-tx) (get output-idx commit-tx) u0)) err-already-sent)\n    (asserts! (is-peg-in-address-approved (get to tx-idxed)) err-peg-in-address-not-found)     \t\n    (ok (merge { tx-idxed: tx-idxed, pair-details: pair-details, token-details: token-details, amt-net: amt-in-fixed } (try! (process-fee (get tx commit-tx) (get fee-idx commit-tx)))))))\n\n(define-private (index-tx\n  (tx { bitcoin-tx: (buff 32768), output: uint, tick: (string-utf8 256), amt: uint, from: (buff 128), to: (buff 128), from-bal: uint, to-bal: uint, decimals: uint })\n  (block { header: (buff 80), height: uint })\n  (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint })\n  (signature-packs (list 10 { signer: principal, tx-hash: (buff 32), signature: (buff 65) })))\n  (begin \n    (and \n      (not (is-ok (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.oracle-v2-01 get-bitcoin-tx-indexed-or-fail (get bitcoin-tx tx) (get output tx) u0)))\n      (as-contract (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.oracle-v2-01 index-tx-many (list { tx: (merge tx { offset: u0 }), block: block, proof: proof, signature-packs: signature-packs })))))\n    (print { type: \"indexed-tx\", tx-id: (try! (get-txid (get bitcoin-tx tx))), block: block, proof: proof, signature-packs: signature-packs })\n    (ok true)))\n\n(define-private (max (a uint) (b uint))\n\t(if (< a b) b a))\n\n(define-private (min (a uint) (b uint))\n  (if (< a b) a b))\n\n(define-private (mul-down (a uint) (b uint))\n  (/ (* a b) ONE_8))\n\n(define-private (div-down (a uint) (b uint))\n  (if (is-eq a u0) u0 (/ (* a ONE_8) b)))\n\n(define-private (decimals-to-fixed (amount uint) (decimals uint))\n  (/ (* amount ONE_8) (pow u10 decimals)))\n\n(define-private (unwrap-string-to-uint (input (string-ascii 40)))\n\t(unwrap-panic (string-to-uint? input)))\n\n(define-private (check-err (result (response bool uint)) (prior (response bool uint)))\n  (match prior ok-value result err-value (err err-value)))\n\n(define-private (check-trait (token-trait <ft-trait>) (token principal))\n  (ok (asserts! (is-eq (contract-of token-trait) token) err-token-mismatch)))\n\n(define-private (decode-from-reveal-tx-or-fail (tx (buff 32768)) (order-idx uint))\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.bridge-common-v2-02 decode-from-reveal-tx-or-fail tx order-idx))\n\n(define-private (extract-tx-ins-outs (tx (buff 32768)))\n  (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.bridge-common-v2-02 extract-tx-ins-outs tx))\n\n(define-private (get-txid (tx (buff 32768)))\n\t(contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.bridge-common-v2-02 get-txid tx))\n\n(define-private (verify-mined (tx (buff 32768)) (block { header: (buff 80), height: uint }) (proof { tx-index: uint, hashes: (list 14 (buff 32)), tree-depth: uint }))\n\t(contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.bridge-common-v2-02 verify-mined tx block proof))\n\n(define-private (refund (btc-amount uint) (token-amount uint) (from (buff 128)) (token-trait <ft-trait>) (the-chain-id uint))\n  (let (\n      (pair-details { token: (contract-of token-trait), chain-id: the-chain-id })\n\t    (token-details (try! (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 get-pair-details-or-fail pair-details)))\n      (btc-peg-out-fee (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.btc-peg-out-endpoint-v2-01 get-peg-out-fee))\n      (btc-peg-out-min-fee (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.btc-peg-out-endpoint-v2-01 get-peg-out-min-fee)))\n    (and (> btc-amount u0) (begin\n      (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.btc-peg-out-endpoint-v2-01 set-peg-out-fee u0))\n      (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.btc-peg-out-endpoint-v2-01 set-peg-out-min-fee u0))\n      (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.btc-peg-out-endpoint-v2-01 request-peg-out-0 from btc-amount))\n      (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.btc-peg-out-endpoint-v2-01 set-peg-out-fee btc-peg-out-fee))\n      (try! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.btc-peg-out-endpoint-v2-01 set-peg-out-min-fee btc-peg-out-min-fee))\n      true))\n    (and (> token-amount u0) (begin\n      (try! (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 set-peg-out-fee pair-details u0))\n      (try! (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 set-peg-out-gas-fee pair-details u0))\n      (try! (contract-call? .meta-peg-out-endpoint-v2-04 request-peg-out token-amount from token-trait the-chain-id))\n      (try! (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 set-peg-out-fee pair-details (get peg-out-fee token-details)))\n      (try! (contract-call? 'SP673Z4BPB4R73359K9HE55F2X91V5BJTN5SXZ5T.meta-bridge-registry-v2-03 set-peg-out-gas-fee pair-details (get peg-out-gas-fee token-details)))\n      true))\n    (ok true))) \n\n(define-private (process-fee (tx (buff 32768)) (fee-idx (optional uint)))\n  (match fee-idx some-value\n    (let (\n\t\t\t  (fee-output (unwrap! (element-at (get outs (try! (extract-tx-ins-outs tx))) some-value) err-invalid-tx)))\n      (asserts! (>= (get value fee-output) (get-peg-in-fee)) err-invalid-amount)  \n\t\t  (asserts! (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.btc-bridge-registry-v2-01 is-peg-in-address-approved (get scriptPubKey fee-output)) err-peg-in-address-not-found)\n      (asserts! (not (contract-call? 'SP2XD7417HGPRTREMKF748VNEQPDRR0RMANB7X1NK.btc-bridge-registry-v2-01 get-peg-in-sent-or-default tx some-value)) err-already-sent)    \n      (ok { fee: (get value fee-output) }))\n    (begin \n      (asserts! (is-eq u0 (get-peg-in-fee)) err-invalid-amount)  \n      (ok { fee: u0 }))))\n\n(define-private (break-routing-id-iter (routing-id uint) (prev-val (response { routing-tokens: (list 5 principal), routing-factors: (list 4 uint) } uint)))\n\t(match prev-val\n\t\tok-value\n\t\t(let (\n\t\t\t\t(pool-details (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-pool-details-by-id routing-id)))\n\t\t\t\t(prev-routing-tokens (unwrap-panic (as-max-len? (get routing-tokens ok-value) u4)))\n\t\t\t\t(prev-routing-factors (unwrap-panic (as-max-len? (get routing-factors ok-value) u3)))\n\t\t\t\t(len-routing-tokens (len prev-routing-tokens))\n        (token-in (unwrap-panic (element-at? prev-routing-tokens u0))))\n\t\t\t\t(if (is-eq len-routing-tokens u1)\n\t\t\t\t\t(if (is-eq (get token-x pool-details) token-in)\n\t\t\t\t\t\t(ok { routing-tokens: (list token-in (get token-y pool-details)), routing-factors: (list (get factor pool-details)) })\n\t\t\t\t\t\t(if (is-eq (get token-y pool-details) token-in)\n\t\t\t\t\t\t\t (ok { routing-tokens: (list token-in (get token-x pool-details)), routing-factors: (list (get factor pool-details)) })\n\t\t\t\t\t\t\t err-invalid-routing))\n\t\t\t\t\t(if (is-eq (get token-x pool-details) (unwrap-panic (element-at? prev-routing-tokens (- len-routing-tokens u1))))\n\t\t\t\t\t\t(ok { routing-tokens: (append prev-routing-tokens (get token-y pool-details)), routing-factors: (append prev-routing-factors (get factor pool-details)) })\n\t\t\t\t\t\t(if (is-eq (get token-y pool-details) (unwrap-panic (element-at? prev-routing-tokens (- len-routing-tokens u1))))\n\t\t\t\t\t\t\t(ok { routing-tokens: (append prev-routing-tokens (get token-x pool-details)), routing-factors: (append prev-routing-factors (get factor pool-details)) })\n\t\t\t\t\t\t\terr-invalid-routing))))\n\t\terr-value (err err-value)))",
    "analysis": {
      "summary": "This contract facilitates cross-chain swaps, including peg-in and peg-out processes, with governance controls for pausing the contract, setting fees, and transferring ownership of tokens.",
      "explanation": "The contract starts by importing a fungible token (FT) trait from another contract to ensure compatibility with SIP-010 standard fungible tokens <L3>. It defines a series of error constants for handling various failure modes <L5-24>, along with constants for maximum unsigned integer value and a fixed precision unit <L26-28>. The contract initializes with a paused state, a fee address, and a peg-in fee <L31-34>. It includes read-only functions for checking contract states, such as pause status, fee address, and peg-in fee, and for querying pair details from a meta-bridge registry contract <L38-67>. Governance functions allow changing the paused state, fee address, and peg-in fee, ensuring only authorized addresses can execute these changes <L89-102>. The contract supports transferring all tokens of a specific type to a new owner, either individually or in bulk <L104-110>. The core functionality revolves around finalizing cross-chain swaps, with detailed validation and processing of transactions, including verifying transaction mining and executing token transfers or mints based on the swap details <L114-166>. Internal functions provide utilities for validating transactions, processing fees, and handling routing for cross-swap orders <L168-308>.",
      "tags": ["cross-chain", "swap", "governance", "utility"]
    }
  },
  {
    "rank": 41,
    "contract": "SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-swap-helper-v-1-2",
    "calls": 803,
    "source": "\n;; xyk-swap-helper-v-1-2\n\n;; Use XYK ft trait and XYK pool trait\n(use-trait xyk-ft-trait .sip-010-trait-ft-standard-v-1-1.sip-010-trait)\n(use-trait xyk-pool-trait .xyk-pool-trait-v-1-2.xyk-pool-trait)\n\n;; Error constants\n(define-constant ERR_NOT_AUTHORIZED (err u6001))\n(define-constant ERR_INVALID_AMOUNT (err u6002))\n(define-constant ERR_INVALID_PRINCIPAL (err u6003))\n(define-constant ERR_ALREADY_ADMIN (err u6004))\n(define-constant ERR_ADMIN_LIMIT_REACHED (err u6005))\n(define-constant ERR_ADMIN_NOT_IN_LIST (err u6006))\n(define-constant ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER (err u6007))\n(define-constant ERR_SWAP_STATUS (err u6008))\n(define-constant ERR_MINIMUM_RECEIVED (err u6009))\n\n;; Contract deployer address\n(define-constant CONTRACT_DEPLOYER tx-sender)\n\n;; Admins list and helper var used to remove admins\n(define-data-var admins (list 5 principal) (list tx-sender))\n(define-data-var admin-helper principal tx-sender)\n\n;; Data var used to enable or disable quotes and swaps\n(define-data-var swap-status bool true)\n\n;; Get admins list\n(define-read-only (get-admins)\n    (ok (var-get admins))\n)\n\n;; Get admin helper var\n(define-read-only (get-admin-helper)\n    (ok (var-get admin-helper))\n)\n\n;; Get swap status\n(define-read-only (get-swap-status)\n    (ok (var-get swap-status))\n)\n\n;; Add an admin to the admins list\n(define-public (add-admin (admin principal))\n    (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n    )\n    ;; Assert caller is an existing admin and new admin is not in admins-list\n    (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n    (asserts! (is-none (index-of admins-list admin)) ERR_ALREADY_ADMIN)\n\n    ;; Add admin to list with max length of 5\n    (var-set admins (unwrap! (as-max-len? (append admins-list admin) u5) ERR_ADMIN_LIMIT_REACHED))\n\n    ;; Print add admin data and return true\n    (print {action: \"add-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n    )\n)\n\n;; Remove an admin from the admins list\n(define-public (remove-admin (admin principal))\n    (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n    )\n    ;; Assert caller is an existing admin and admin to remove is in admins-list\n    (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n    (asserts! (is-some (index-of admins-list admin)) ERR_ADMIN_NOT_IN_LIST)\n\n    ;; Assert contract deployer cannot be removed\n    (asserts! (not (is-eq admin CONTRACT_DEPLOYER)) ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER)\n\n    ;; Set admin-helper to admin to remove and filter admins-list to remove admin\n    (var-set admin-helper admin)\n    (var-set admins (filter admin-not-removable admins-list))\n\n    ;; Print remove admin data and return true\n    (print {action: \"remove-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n    )\n)\n\n;; Enable or disable quotes and swaps\n(define-public (set-swap-status (status bool))\n    (let (\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n\n        ;; Set swap-status to status\n        (var-set swap-status status)\n\n        ;; Print function data and return true\n        (print {action: \"set-swap-status\", caller: caller, data: {status: status}})\n        (ok true)\n    )\n    )\n)\n\n;; Get quote for swap-helper-a\n(define-public (get-quote-a\n    (amount uint)\n    (xyk-tokens (tuple (a <xyk-ft-trait>) (b <xyk-ft-trait>)))\n    (xyk-pools (tuple (a <xyk-pool-trait>)))\n    )\n    (let (\n    ;; Assert that swap-status is true and amount is greater than 0\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n\n    ;; Get quotes for each swap\n    (quote-a (try! (xyk-qa amount (get a xyk-tokens) (get b xyk-tokens) (get a xyk-pools))))\n    )\n    ;; Return number of b tokens the caller would receive\n    (ok quote-a)\n    )\n)\n\n;; Get quote for swap-helper-b\n(define-public (get-quote-b\n    (amount uint)\n    (xyk-tokens (tuple (a <xyk-ft-trait>) (b <xyk-ft-trait>) (c <xyk-ft-trait>) (d <xyk-ft-trait>)))\n    (xyk-pools (tuple (a <xyk-pool-trait>) (b <xyk-pool-trait>)))\n    )\n    (let (\n    ;; Assert that swap-status is true and amount is greater than 0\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n\n    ;; Get quotes for each swap\n    (quote-a (try! (xyk-qa amount (get a xyk-tokens) (get b xyk-tokens) (get a xyk-pools))))\n    (quote-b (try! (xyk-qa quote-a (get c xyk-tokens) (get d xyk-tokens) (get b xyk-pools))))\n    )\n    ;; Return number of d tokens the caller would receive\n    (ok quote-b)\n    )\n)\n\n;; Get quote for swap-helper-c\n(define-public (get-quote-c\n    (amount uint)\n    (xyk-tokens (tuple (a <xyk-ft-trait>) (b <xyk-ft-trait>) (c <xyk-ft-trait>) (d <xyk-ft-trait>) (e <xyk-ft-trait>) (f <xyk-ft-trait>)))\n    (xyk-pools (tuple (a <xyk-pool-trait>) (b <xyk-pool-trait>) (c <xyk-pool-trait>)))\n    )\n    (let (\n    ;; Assert that swap-status is true and amount is greater than 0\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n\n    ;; Get quotes for each swap\n    (quote-a (try! (xyk-qa amount (get a xyk-tokens) (get b xyk-tokens) (get a xyk-pools))))\n    (quote-b (try! (xyk-qa quote-a (get c xyk-tokens) (get d xyk-tokens) (get b xyk-pools))))\n    (quote-c (try! (xyk-qa quote-b (get e xyk-tokens) (get f xyk-tokens) (get c xyk-pools))))\n    )\n    ;; Return number of f tokens the caller would receive\n    (ok quote-c)\n    )\n)\n\n;; Get quote for swap-helper-d\n(define-public (get-quote-d\n    (amount uint)\n    (xyk-tokens (tuple (a <xyk-ft-trait>) (b <xyk-ft-trait>) (c <xyk-ft-trait>) (d <xyk-ft-trait>) (e <xyk-ft-trait>) (f <xyk-ft-trait>) (g <xyk-ft-trait>) (h <xyk-ft-trait>)))\n    (xyk-pools (tuple (a <xyk-pool-trait>) (b <xyk-pool-trait>) (c <xyk-pool-trait>) (d <xyk-pool-trait>)))\n    )\n    (let (\n    ;; Assert that swap-status is true and amount is greater than 0\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n\n    ;; Get quotes for each swap\n    (quote-a (try! (xyk-qa amount (get a xyk-tokens) (get b xyk-tokens) (get a xyk-pools))))\n    (quote-b (try! (xyk-qa quote-a (get c xyk-tokens) (get d xyk-tokens) (get b xyk-pools))))\n    (quote-c (try! (xyk-qa quote-b (get e xyk-tokens) (get f xyk-tokens) (get c xyk-pools))))\n    (quote-d (try! (xyk-qa quote-c (get g xyk-tokens) (get h xyk-tokens) (get d xyk-pools))))\n    )\n    ;; Return number of h tokens the caller would receive\n    (ok quote-d)\n    )\n)\n\n;; Get quote for swap-helper-e\n(define-public (get-quote-e\n    (amount uint)\n    (xyk-tokens (tuple (a <xyk-ft-trait>) (b <xyk-ft-trait>) (c <xyk-ft-trait>) (d <xyk-ft-trait>) (e <xyk-ft-trait>) (f <xyk-ft-trait>) (g <xyk-ft-trait>) (h <xyk-ft-trait>) (i <xyk-ft-trait>) (j <xyk-ft-trait>)))\n    (xyk-pools (tuple (a <xyk-pool-trait>) (b <xyk-pool-trait>) (c <xyk-pool-trait>) (d <xyk-pool-trait>) (e <xyk-pool-trait>)))\n    )\n    (let (\n    ;; Assert that swap-status is true and amount is greater than 0\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n\n    ;; Get quotes for each swap\n    (quote-a (try! (xyk-qa amount (get a xyk-tokens) (get b xyk-tokens) (get a xyk-pools))))\n    (quote-b (try! (xyk-qa quote-a (get c xyk-tokens) (get d xyk-tokens) (get b xyk-pools))))\n    (quote-c (try! (xyk-qa quote-b (get e xyk-tokens) (get f xyk-tokens) (get c xyk-pools))))\n    (quote-d (try! (xyk-qa quote-c (get g xyk-tokens) (get h xyk-tokens) (get d xyk-pools))))\n    (quote-e (try! (xyk-qa quote-d (get i xyk-tokens) (get j xyk-tokens) (get e xyk-pools))))\n    )\n    ;; Return number of j tokens the caller would receive\n    (ok quote-e)\n    )\n)\n\n;; Swap via 1 XYK pool\n(define-public (swap-helper-a\n    (amount uint) (min-received uint)\n    (xyk-tokens (tuple (a <xyk-ft-trait>) (b <xyk-ft-trait>)))\n    (xyk-pools (tuple (a <xyk-pool-trait>)))\n    )\n    (let (\n    ;; Assert that swap-status is true and amount is greater than 0\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n\n    ;; Perform each swap\n    (swap-a (try! (xyk-sa amount (get a xyk-tokens) (get b xyk-tokens) (get a xyk-pools))))\n    )\n    (begin\n        ;; Assert that swap-a is greater than or equal to min-received\n        (asserts! (>= swap-a min-received) ERR_MINIMUM_RECEIVED)\n\n        ;; Print swap data and return number of b tokens the caller received\n        (print {\n        action: \"swap-helper-a\",\n        caller: tx-sender, \n        data: {\n            amount: amount,\n            min-received: min-received,\n            received: swap-a,\n            xyk-data: {\n            xyk-tokens: xyk-tokens,\n            xyk-pools: xyk-pools,\n            xyk-swaps: {\n                a: swap-a\n            }\n            }\n        }\n        })\n        (ok swap-a)\n    )\n    )\n)\n\n;; Swap via 2 XYK pools\n(define-public (swap-helper-b\n    (amount uint) (min-received uint)\n    (xyk-tokens (tuple (a <xyk-ft-trait>) (b <xyk-ft-trait>) (c <xyk-ft-trait>) (d <xyk-ft-trait>)))\n    (xyk-pools (tuple (a <xyk-pool-trait>) (b <xyk-pool-trait>)))\n    )\n    (let (\n    ;; Assert that swap-status is true and amount is greater than 0\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n\n    ;; Perform each swap\n    (swap-a (try! (xyk-sa amount (get a xyk-tokens) (get b xyk-tokens) (get a xyk-pools))))\n    (swap-b (try! (xyk-sa swap-a (get c xyk-tokens) (get d xyk-tokens) (get b xyk-pools))))\n    )\n    (begin\n        ;; Assert that swap-b is greater than or equal to min-received\n        (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n\n        ;; Print swap data and return number of d tokens the caller received\n        (print {\n        action: \"swap-helper-b\",\n        caller: tx-sender, \n        data: {\n            amount: amount,\n            min-received: min-received,\n            received: swap-b,\n            xyk-data: {\n            xyk-tokens: xyk-tokens,\n            xyk-pools: xyk-pools,\n            xyk-swaps: {\n                a: swap-a,\n                b: swap-b\n            }\n            }\n        }\n        })\n        (ok swap-b)\n    )\n    )\n)\n\n;; Swap via 3 XYK pools\n(define-public (swap-helper-c\n    (amount uint) (min-received uint)\n    (xyk-tokens (tuple (a <xyk-ft-trait>) (b <xyk-ft-trait>) (c <xyk-ft-trait>) (d <xyk-ft-trait>) (e <xyk-ft-trait>) (f <xyk-ft-trait>)))\n    (xyk-pools (tuple (a <xyk-pool-trait>) (b <xyk-pool-trait>) (c <xyk-pool-trait>)))\n    )\n    (let (\n    ;; Assert that swap-status is true and amount is greater than 0\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n\n    ;; Perform each swap\n    (swap-a (try! (xyk-sa amount (get a xyk-tokens) (get b xyk-tokens) (get a xyk-pools))))\n    (swap-b (try! (xyk-sa swap-a (get c xyk-tokens) (get d xyk-tokens) (get b xyk-pools))))\n    (swap-c (try! (xyk-sa swap-b (get e xyk-tokens) (get f xyk-tokens) (get c xyk-pools))))\n    )\n    (begin\n        ;; Assert that swap-c is greater than or equal to min-received\n        (asserts! (>= swap-c min-received) ERR_MINIMUM_RECEIVED)\n\n        ;; Print swap data and return number of f tokens the caller received\n        (print {\n        action: \"swap-helper-c\",\n        caller: tx-sender, \n        data: {\n            amount: amount,\n            min-received: min-received,\n            received: swap-c,\n            xyk-data: {\n            xyk-tokens: xyk-tokens,\n            xyk-pools: xyk-pools,\n            xyk-swaps: {\n                a: swap-a,\n                b: swap-b,\n                c: swap-c\n            }\n            }\n        }\n        })\n        (ok swap-c)\n    )\n    )\n)\n\n;; Swap via 4 XYK pools\n(define-public (swap-helper-d\n    (amount uint) (min-received uint)\n    (xyk-tokens (tuple (a <xyk-ft-trait>) (b <xyk-ft-trait>) (c <xyk-ft-trait>) (d <xyk-ft-trait>) (e <xyk-ft-trait>) (f <xyk-ft-trait>) (g <xyk-ft-trait>) (h <xyk-ft-trait>)))\n    (xyk-pools (tuple (a <xyk-pool-trait>) (b <xyk-pool-trait>) (c <xyk-pool-trait>) (d <xyk-pool-trait>)))\n    )\n    (let (\n    ;; Assert that swap-status is true and amount is greater than 0\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n\n    ;; Perform each swap\n    (swap-a (try! (xyk-sa amount (get a xyk-tokens) (get b xyk-tokens) (get a xyk-pools))))\n    (swap-b (try! (xyk-sa swap-a (get c xyk-tokens) (get d xyk-tokens) (get b xyk-pools))))\n    (swap-c (try! (xyk-sa swap-b (get e xyk-tokens) (get f xyk-tokens) (get c xyk-pools))))\n    (swap-d (try! (xyk-sa swap-c (get g xyk-tokens) (get h xyk-tokens) (get d xyk-pools))))\n    )\n    (begin\n        ;; Assert that swap-d is greater than or equal to min-received\n        (asserts! (>= swap-d min-received) ERR_MINIMUM_RECEIVED)\n\n        ;; Print swap data and return number of h tokens the caller received\n        (print {\n        action: \"swap-helper-d\",\n        caller: tx-sender, \n        data: {\n            amount: amount,\n            min-received: min-received,\n            received: swap-d,\n            xyk-data: {\n            xyk-tokens: xyk-tokens,\n            xyk-pools: xyk-pools,\n            xyk-swaps: {\n                a: swap-a,\n                b: swap-b,\n                c: swap-c,\n                d: swap-d\n            }\n            }\n        }\n        })\n        (ok swap-d)\n    )\n    )\n)\n\n;; Swap via 5 XYK pools\n(define-public (swap-helper-e\n    (amount uint) (min-received uint)\n    (xyk-tokens (tuple (a <xyk-ft-trait>) (b <xyk-ft-trait>) (c <xyk-ft-trait>) (d <xyk-ft-trait>) (e <xyk-ft-trait>) (f <xyk-ft-trait>) (g <xyk-ft-trait>) (h <xyk-ft-trait>) (i <xyk-ft-trait>) (j <xyk-ft-trait>)))\n    (xyk-pools (tuple (a <xyk-pool-trait>) (b <xyk-pool-trait>) (c <xyk-pool-trait>) (d <xyk-pool-trait>) (e <xyk-pool-trait>)))\n    )\n    (let (\n    ;; Assert that swap-status is true and amount is greater than 0\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n\n    ;; Perform each swap\n    (swap-a (try! (xyk-sa amount (get a xyk-tokens) (get b xyk-tokens) (get a xyk-pools))))\n    (swap-b (try! (xyk-sa swap-a (get c xyk-tokens) (get d xyk-tokens) (get b xyk-pools))))\n    (swap-c (try! (xyk-sa swap-b (get e xyk-tokens) (get f xyk-tokens) (get c xyk-pools))))\n    (swap-d (try! (xyk-sa swap-c (get g xyk-tokens) (get h xyk-tokens) (get d xyk-pools))))\n    (swap-e (try! (xyk-sa swap-d (get i xyk-tokens) (get j xyk-tokens) (get e xyk-pools))))\n    )\n    (begin\n        ;; Assert that swap-e is greater than or equal to min-received\n        (asserts! (>= swap-e min-received) ERR_MINIMUM_RECEIVED)\n\n        ;; Print swap data and return number of j tokens the caller received\n        (print {\n        action: \"swap-helper-e\",\n        caller: tx-sender, \n        data: {\n            amount: amount,\n            min-received: min-received,\n            received: swap-e,\n            xyk-data: {\n            xyk-tokens: xyk-tokens,\n            xyk-pools: xyk-pools,\n            xyk-swaps: {\n                a: swap-a,\n                b: swap-b,\n                c: swap-c,\n                d: swap-d,\n                e: swap-e\n            }\n            }\n        }\n        })\n        (ok swap-e)\n    )\n    )\n)\n\n;; Helper function for removing an admin\n(define-private (admin-not-removable (admin principal))\n    (not (is-eq admin (var-get admin-helper)))\n)\n\n;; Check if input and output tokens are swapped relative to the pool's x and y tokens\n(define-private (is-xyk-path-reversed\n    (token-in <xyk-ft-trait>) (token-out <xyk-ft-trait>)\n    (pool-contract <xyk-pool-trait>)\n    )\n    (let (\n    (pool-data (unwrap-panic (contract-call? pool-contract get-pool)))\n    )\n    (not \n        (and \n        (is-eq (contract-of token-in) (get x-token pool-data))\n        (is-eq (contract-of token-out) (get y-token pool-data))\n        )\n    )\n    )\n)\n\n;; Get XYK quote using get-dy or get-dx based on token path\n(define-private (xyk-qa\n    (amount uint)\n    (token-in <xyk-ft-trait>) (token-out <xyk-ft-trait>)\n    (pool <xyk-pool-trait>)\n    )\n    (let (\n    ;; Determine if the token path is reversed\n    (is-reversed (is-xyk-path-reversed token-in token-out pool))\n    \n    ;; Get quote based on path\n    (quote-a (if (is-eq is-reversed false)\n                    (try! (contract-call?\n                    .xyk-core-v-1-2 get-dy\n                    pool\n                    token-in token-out\n                    amount))\n                    (try! (contract-call?\n                    .xyk-core-v-1-2 get-dx\n                    pool\n                    token-out token-in\n                    amount))))\n    )\n    (ok quote-a)\n    )\n)\n\n;; Perform XYK swap using swap-x-for-y or swap-y-for-x based on token path\n(define-private (xyk-sa\n    (amount uint)\n    (token-in <xyk-ft-trait>) (token-out <xyk-ft-trait>)\n    (pool <xyk-pool-trait>)\n    )\n    (let (\n    ;; Determine if the token path is reversed\n    (is-reversed (is-xyk-path-reversed token-in token-out pool))\n    \n    ;; Perform swap based on path\n    (swap-a (if (is-eq is-reversed false)\n                (try! (contract-call?\n                        .xyk-core-v-1-2 swap-x-for-y\n                        pool\n                        token-in token-out\n                        amount u1))\n                (try! (contract-call?\n                        .xyk-core-v-1-2 swap-y-for-x\n                        pool\n                        token-out token-in\n                        amount u1))))\n    )\n    (ok swap-a)\n    )\n)",
    "analysis": {
      "summary": "This contract facilitates multi-step swaps across XYK pools on the Stacks blockchain, managing swap logic, admin roles, and swap status.",
      "explanation": "The contract integrates with the SIP-010 fungible token standard and a custom XYK pool trait to perform swaps across multiple liquidity pools. It includes mechanisms for managing administrators, enabling/disabling swaps, and calculating quotes for swaps involving up to five different pools.\n\n1. Data vars and constants:\n- Error constants <L9-17> define various error codes for handling failures.\n- CONTRACT_DEPLOYER <L20> stores the address of the contract deployer.\n- Admins list <L23> and admin-helper <L24> manage administrative privileges.\n- Swap-status <L27> enables or disables the ability to perform swaps.\n\n2. Functions:\n- get-admins <L29-32>, get-admin-helper <L34-37>, and get-swap-status <L39-42> are read-only functions that return the current state of their respective data variables.\n- add-admin <L44-61> and remove-admin <L63-84> manage the list of administrators, ensuring only current admins can add or remove others and enforcing a maximum of five admins.\n- set-swap-status <L86-103> allows admins to enable or disable swap functionality.\n- get-quote-a <L105-122> through get-quote-e <L187-208> calculate quotes for swaps involving different numbers of pools, ensuring swaps are only performed when enabled and the amount is greater than zero.\n- swap-helper-a <L210-248> through swap-helper-e <L382-428> perform the actual swaps, verifying minimum received amounts and printing swap details.\n- admin-not-removable <L430-433> and is-xyk-path-reversed <L435-450> are helper functions for admin management and determining the direction of swaps, respectively.\n- xyk-qa <L452-477> and xyk-sa <L479-504> abstract the logic for getting quotes and performing swaps, handling reversed token paths.\n\nNotable qualities:\n- The contract enforces administrative control over critical functionalities.\n- It supports complex swap operations across multiple liquidity pools with safeguards like minimum received checks.\n- The use of traits for fungible tokens and pools demonstrates a modular approach to smart contract design on Stacks.",
      "tags": ["DeFi", "DEX", "swap", "utility"]
    }
  },
  {
    "rank": 42,
    "contract": "SPAG3YDTNKR58Z6X1RK74N861MXJ8RCRRE80A11W.balancer-v2-4",
    "calls": 790,
    "source": "(define-constant ONE_6 u1000000)\n(define-constant ONE_8 u100000000)\n(define-constant ERR-NO-PR (err u400))\n\n(define-read-only (six-to-eight (n uint))\n    (/ (* n ONE_8) ONE_6)\n)\n\n;; not_alex->velar\n(define-public (balancer1_i (in uint) (mrc uint))\n    (begin \n        (try! (contract-call? \n            'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper-a \n            'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2 \n            'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex \n            'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnot \n            u100000000 u100000000 (six-to-eight in) none))\n        (let \n            (\n                (bb (stx-get-balance tx-sender))\n            )            \n            (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens  \n                u16 \n                'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx \n                'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope   \n                'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope  \n                'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx  \n                'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to \n                (unwrap-panic (contract-call? 'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope get-balance tx-sender)) \n                u1\n            ))\n            (let \n                (\n                    (ba (stx-get-balance tx-sender))\n                    (rc (- ba bb))\n                )\n                (asserts! (>= rc mrc) ERR-NO-PR)\n                (ok (list bb ba))\n            ) \n        )\n    )\n)\n\n(define-public (balancer1 (dd uint) (mr uint) (ta uint))\n    (let (\n            (r (list \n                (balancer1_i dd mr)\n            ))\n        )\n        (and (> (stx-get-balance tx-sender) ta) (try! (stx-transfer? (- (stx-get-balance tx-sender) ta) tx-sender 'SPAG3YDTNKR58Z6X1RK74N861MXJ8RCRRE80A11W)))\n        (ok r)\n    )\n)\n\n;; not_velar->alex\n\n(define-public (balancer2_i (in uint) (mout uint))\n    (begin\n        (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens  \n                u16 \n                'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx \n                'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope \n                'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx \n                'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope \n                'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to \n                in \n                u1\n            ))\n        (let\n            (\n                (bb (stx-get-balance tx-sender))\n            )\n            (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper-a \n                'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wnot  \n                'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex \n                'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2   \n                u100000000 u100000000  \n                (* u100000000 (unwrap-panic (contract-call? 'SP32AEEF6WW5Y0NMJ1S8SBSZDAY8R5J32NBZFPKKZ.nope get-balance tx-sender)))\n                none\n            ))\n            (let \n                (\n                    (ba (stx-get-balance tx-sender))\n                    (rc (- ba bb))\n                )\n                (asserts! (>= rc mout) (err u400))\n                (ok (list bb ba))\n            ) \n        )\n    )\n)\n\n(define-public (balancer2 (dd uint) (mr uint) (ta uint))\n    (let (\n            (r (list \n                (balancer2_i dd mr)\n            ))\n        )\n        (and (> (stx-get-balance tx-sender) ta) (try! (stx-transfer? (- (stx-get-balance tx-sender) ta) tx-sender 'SPAG3YDTNKR58Z6X1RK74N861MXJ8RCRRE80A11W)))\n        (ok r)\n    )\n)\n\n(define-public (balancer (dd uint) (mr uint) (ta uint))\n    (let (\n            (r (list \n                (balancer1_i dd mr)\n                (balancer2_i dd mr)\n            ))\n        )\n        (and (> (stx-get-balance tx-sender) ta) (try! (stx-transfer? (- (stx-get-balance tx-sender) ta) tx-sender 'SPAG3YDTNKR58Z6X1RK74N861MXJ8RCRRE80A11W)))\n        (ok r)\n    )\n)",
    "analysis": {
      "summary": "This contract performs token swaps and balance checks across different protocols within the Stacks blockchain.",
      "explanation": "This Clarity smart contract is designed to interact with multiple decentralized finance (DeFi) protocols on the Stacks blockchain to perform token swaps and ensure balance requirements are met post-transaction. It leverages the composability of smart contracts to integrate functionalities from different DeFi platforms. The contract contains constants for unit conversion, error codes, and three main public functions that facilitate the swapping process and balance verification. Each function is designed to interact with external contracts, execute token swaps, and validate the outcome against predefined criteria. The contract's architecture emphasizes interoperability within the Stacks ecosystem, showcasing how contracts can work together to create complex DeFi operations. \n\n1. Constants and Error Codes: \n- `ONE_6` and `ONE_8` <L1-2> are used for decimal precision adjustments. \n- `ERR-NO-PR` <L3> is an error code used to indicate insufficient post-transaction balance. \n\n2. Utility Function: \n- `six-to-eight` <L5-7> converts a uint with 6 decimal places to 8 decimal places by multiplying by `ONE_8` and dividing by `ONE_6`. This is crucial for maintaining precision when dealing with different token decimal standards. \n\n3. Main Functions: \n- `balancer1_i` <L10-42> and `balancer2_i` <L57-91> are internal functions that perform token swaps through external contract calls to AMM pools and other routers, adjusting for decimal precision as needed. They check the balance before and after the swap to ensure a minimum return criterion is met. \n- `balancer1` <L44-53>, `balancer2` <L93-102>, and `balancer` <L104-114> are public functions that wrap the internal swap functions. They perform additional STX balance checks and execute a final STX transfer based on the transaction amount parameter. These functions demonstrate the contract's capability to bundle multiple operations (swaps and transfers) into single transactions. \n\nEach function meticulously interacts with external contracts and handles errors gracefully, ensuring that operations either complete successfully or revert to avoid partial state changes. The use of `try!` and `asserts!` statements <L12, L22, L37, L59, L73, L86> ensures that any operation failing to meet the specified criteria results in transaction failure, enhancing the contract's security and reliability. \n\nNotable Qualities: \n- Demonstrates advanced Clarity features like contract calls, error handling, and atomic transactions. \n- Highlights the composability of DeFi protocols on the Stacks blockchain. \n- Uses precise arithmetic operations to handle token decimal differences, ensuring accuracy in swaps and balance calculations.",
      "tags": ["DeFi", "DEX", "utility", "protocol"]
    }
  },
  {
    "rank": 43,
    "contract": "SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.router-xyk-velar-v-1-1",
    "calls": 776,
    "source": ";; router-xyk-velar-v-1-1\n\n(use-trait ft-trait 'SP2AKWJYC7BNY18W1XXKPGP0YVEK63QJG4793Z2D4.sip-010-trait-ft-standard.sip-010-trait)\n(use-trait xyk-pool-trait 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-trait-v-1-1.xyk-pool-trait)\n(use-trait share-fee-to-trait 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-share-fee-to-trait.share-fee-to-trait)\n\n(define-constant ERR_NOT_AUTHORIZED (err u1001))\n(define-constant ERR_INVALID_AMOUNT (err u1002))\n(define-constant ERR_INVALID_PRINCIPAL (err u1003))\n(define-constant ERR_ALREADY_ADMIN (err u2001))\n(define-constant ERR_ADMIN_LIMIT_REACHED (err u2002))\n(define-constant ERR_ADMIN_NOT_IN_LIST (err u2003))\n(define-constant ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER (err u2004))\n(define-constant ERR_SWAP_STATUS (err u4001))\n(define-constant ERR_MINIMUM_RECEIVED (err u4002))\n(define-constant ERR_SWAP_A (err u5001))\n(define-constant ERR_SWAP_B (err u5002))\n\n(define-constant CONTRACT_DEPLOYER tx-sender)\n\n(define-data-var admins (list 5 principal) (list tx-sender))\n(define-data-var admin-helper principal tx-sender)\n\n(define-data-var swap-status bool true)\n\n(define-read-only (get-admins)\n  (ok (var-get admins))\n)\n\n(define-read-only (get-admin-helper)\n  (ok (var-get admin-helper))\n)\n\n(define-read-only (get-swap-status)\n  (ok (var-get swap-status))\n)\n\n(define-public (get-quote-a\n    (amount uint)\n    (pool-trait <xyk-pool-trait>)\n    (xyk-reversed bool)\n    (id uint)\n    (swap-fee (tuple (num uint) (den uint)))\n    (velar-reversed bool)\n  )\n  (let (\n    (quote-a (if (is-eq xyk-reversed false)\n                 (try! (contract-call? pool-trait get-dy amount))\n                 (try! (contract-call? pool-trait get-dx amount))))\n    (velar-pool (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-core do-get-pool id))\n    (r0 (if (is-eq velar-reversed false)\n            (get reserve0 velar-pool)\n            (get reserve1 velar-pool)))\n    (r1 (if (is-eq velar-reversed false)\n            (get reserve1 velar-pool)\n            (get reserve0 velar-pool)))\n    (quote-b (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-library get-amount-out\n                   quote-a\n                   r0 r1\n                   swap-fee)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-b\n    (amount uint)\n    (pool-trait <xyk-pool-trait>)\n    (xyk-reversed bool)\n    (id uint)\n    (swap-fee (tuple (num uint) (den uint)))\n    (velar-reversed bool)\n  )\n  (let (\n    (velar-pool (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-core do-get-pool id))\n    (r0 (if (is-eq velar-reversed false)\n            (get reserve0 velar-pool)\n            (get reserve1 velar-pool)))\n    (r1 (if (is-eq velar-reversed false)\n            (get reserve1 velar-pool)\n            (get reserve0 velar-pool)))\n    (quote-a (try! (contract-call? 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-library get-amount-out\n                   amount\n                   r0 r1\n                   swap-fee)))\n    (quote-b (if (is-eq xyk-reversed false)\n                 (try! (contract-call? pool-trait get-dy quote-a))\n                 (try! (contract-call? pool-trait get-dx quote-a))))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (set-swap-status (status bool))\n  (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n      (var-set swap-status status)\n      (print {action: \"set-swap-status\", caller: caller, data: {status: status}})\n      (ok true)\n    )\n  )\n)\n\n(define-public (add-admin (admin principal))\n  (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n  )\n    (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n    (asserts! (is-none (index-of admins-list admin)) ERR_ALREADY_ADMIN)\n    (asserts! (is-standard admin) ERR_INVALID_PRINCIPAL)\n    (var-set admins (unwrap! (as-max-len? (append admins-list admin) u5) ERR_ADMIN_LIMIT_REACHED))\n    (print {action: \"add-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n  )\n)\n\n(define-public (remove-admin (admin principal))\n  (let (\n    (admins-list (var-get admins))\n    (caller-in-list (index-of admins-list tx-sender))\n    (admin-to-remove-in-list (index-of admins-list admin))\n    (caller tx-sender)\n  )\n    (asserts! (is-some caller-in-list) ERR_NOT_AUTHORIZED)\n    (asserts! (is-some admin-to-remove-in-list) ERR_ADMIN_NOT_IN_LIST)\n    (asserts! (not (is-eq admin CONTRACT_DEPLOYER)) ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER)\n    (asserts! (is-standard admin) ERR_INVALID_PRINCIPAL)\n    (var-set admin-helper admin)\n    (var-set admins (filter admin-not-removeable admins-list))\n    (print {action: \"remove-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n  )\n)\n\n(define-public (swap-helper-a\n    (amount uint) (min-received uint)\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <ft-trait>) (y-token-trait <ft-trait>)\n    (xyk-reversed bool)\n    (id uint)\n    (token0 <ft-trait>) (token1 <ft-trait>)\n    (token-in <ft-trait>) (token-out <ft-trait>)\n    (share-fee-to <share-fee-to-trait>)\n  )\n  (let (\n    (swap-a (if (is-eq xyk-reversed false)\n                (unwrap! (xyk-a pool-trait x-token-trait y-token-trait amount) ERR_SWAP_A)\n                (unwrap! (xyk-b pool-trait x-token-trait y-token-trait amount) ERR_SWAP_A)))\n    (swap-b (unwrap! (velar-a id token0 token1 token-in token-out share-fee-to swap-a) ERR_SWAP_B))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-a\",\n        caller: caller, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          pool-trait: (contract-of pool-trait),\n          x-token-trait: (contract-of x-token-trait),\n          y-token-trait: (contract-of y-token-trait),\n          xyk-reversed: xyk-reversed,\n          id: id,\n          token0: (contract-of token0),\n          token1: (contract-of token1),\n          token-in: (contract-of token-in),\n          token-out: (contract-of token-out),\n          share-fee-to: (contract-of share-fee-to)\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-b\n    (amount uint) (min-received uint)\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <ft-trait>) (y-token-trait <ft-trait>)\n    (xyk-reversed bool)\n    (id uint)\n    (token0 <ft-trait>) (token1 <ft-trait>)\n    (token-in <ft-trait>) (token-out <ft-trait>)\n    (share-fee-to <share-fee-to-trait>)\n  )\n  (let (\n    (swap-a (unwrap! (velar-a id token0 token1 token-in token-out share-fee-to amount) ERR_SWAP_A))\n    (swap-b (if (is-eq xyk-reversed false)\n                (unwrap! (xyk-a pool-trait x-token-trait y-token-trait swap-a) ERR_SWAP_B)\n                (unwrap! (xyk-b pool-trait x-token-trait y-token-trait swap-a) ERR_SWAP_B)))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS)\n      (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-b\",\n        caller: caller, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          pool-trait: (contract-of pool-trait),\n          x-token-trait: (contract-of x-token-trait),\n          y-token-trait: (contract-of y-token-trait),\n          xyk-reversed: xyk-reversed,\n          id: id,\n          token0: (contract-of token0),\n          token1: (contract-of token1),\n          token-in: (contract-of token-in),\n          token-out: (contract-of token-out),\n          share-fee-to: (contract-of share-fee-to)\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-private (xyk-a\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <ft-trait>) (y-token-trait <ft-trait>)\n    (x-amount uint)\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-x-for-y\n                  pool-trait\n                  x-token-trait y-token-trait\n                  x-amount u1)))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-private (xyk-b\n    (pool-trait <xyk-pool-trait>)\n    (x-token-trait <ft-trait>) (y-token-trait <ft-trait>)\n    (y-amount uint)\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-core-v-1-1 swap-y-for-x\n                  pool-trait\n                  x-token-trait y-token-trait\n                  y-amount u1)))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-private (velar-a\n    (id uint)\n    (token0 <ft-trait>) (token1 <ft-trait>)\n    (token-in <ft-trait>) (token-out <ft-trait>)\n    (share-fee-to <share-fee-to-trait>)\n    (amt-in uint)\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router swap-exact-tokens-for-tokens\n                  id \n                  token0 token1\n                  token-in token-out\n                  share-fee-to\n                  amt-in u1)))\n  )\n    (ok (get amt-out swap-a))\n  )\n)\n\n(define-private (admin-not-removeable (admin principal))\n  (not (is-eq admin (var-get admin-helper)))\n)",
    "analysis": {
      "summary": "This contract facilitates token swaps using an XYK model and integrates with a Velar liquidity pool for additional swap capabilities.",
      "explanation": "The contract is designed to interact with external liquidity pools for token swaps, allowing users to get quotes and perform swaps while managing administrative privileges and swap status. It utilizes traits from other contracts to ensure compatibility and standard functionality across different token types and pool mechanisms.\n\n1. Constants and Data Variables:\n- Error codes <L7-17> define various failure states for contract operations.\n- `CONTRACT_DEPLOYER` <L19> stores the address of the contract's deployer.\n- `admins` <L21>, a list of principals with administrative privileges, initially includes the contract deployer.\n- `admin-helper` <L22> is used temporarily to assist in admin removal operations.\n- `swap-status` <L24> is a boolean indicating whether swaps are currently allowed.\n\n2. Functions:\n- `get-admins` <L26-28> returns the list of admins.\n- `get-admin-helper` <L30-32> returns the `admin-helper` value.\n- `get-swap-status` <L34-36> returns the current swap status.\n- `get-quote-a` <L38-63> and `get-quote-b` <L66-91> calculate swap quotes through a combination of XYK model calculations and interactions with a Velar liquidity pool, differing in the order of operations.\n- `set-swap-status` <L94-106> allows admins to enable or disable swapping.\n- `add-admin` <L108-120> and `remove-admin` <L122-138> manage the list of admins, with checks for authorization and list limits.\n- `swap-helper-a` <L140-183> and `swap-helper-b` <L185-228> perform token swaps with input validation and logging, differing in the initial swap direction.\n- `xyk-a` <L230-244>, `xyk-b` <L246-260>, and `velar-a` <L262-280> are private functions that interact with external contracts to execute swaps.\n- `admin-not-removeable` <L282-284> is a utility function for filtering the admin list.\n\nEach function includes safety checks for authorization, input validity, and swap conditions, ensuring secure and intended contract operation. The contract's integration with both XYK and Velar pool models, along with its administrative controls, highlights its flexibility and security in managing token swaps.",
      "tags": ["DEX", "swap", "liquidity-pool", "utility"]
    }
  },
  {
    "rank": 44,
    "contract": "SP1E0XBN9T4B10E9QMR7XMFJPMA19D77WY3KP2QKC.farming-campaign-v2-02",
    "calls": 742,
    "source": ";; SPDX-License-Identifier: BUSL-1.1\n\n(use-trait ft-trait 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.trait-sip-010.sip-010-trait) \n\n(define-constant err-not-authorized (err u1000))\n(define-constant err-get-block-info (err u1001))\n(define-constant err-invalid-campaign-registration (err u1002))\n(define-constant err-invalid-campaign-id (err u1003))\n(define-constant err-registration-cutoff-passed (err u1004))\n(define-constant err-stake-cutoff-passed (err u1005))\n(define-constant err-campaign-not-ended (err u1006))\n(define-constant err-token-mismatch (err u1007))\n(define-constant err-invalid-input (err u1008))\n(define-constant err-invalid-reward-token (err u1010))\n(define-constant err-already-claimed (err u1011))\n(define-constant err-stake-end-passed (err u1005))\n(define-constant err-not-registered (err u1013))\n(define-constant err-revoke-disabled (err u1014))\n(define-constant err-registration-cutoff-not-passed (err u1015))\n(define-constant err-voting-cutoff-passed (err u1016))\n(define-constant err-pool-not-registered (err u1017))\n(define-constant err-pool-already-registered (err u1018))\n\n(define-constant ONE_8 u100000000)\n\n(define-data-var campaign-nonce uint u1) ;; the old version already used u0\n(define-data-var revoke-enabled bool false)\n(define-data-var whitelisted-pools (list 1000 uint) (list))\n(define-data-var project-reward-ignore-list (list 1000 principal) (list))\n\n(define-map campaigns uint { registration-cutoff: uint, voting-cutoff: uint, stake-cutoff: uint, stake-end: uint, reward-amount: uint, snapshot-block: uint }) ;; Campaign data.\n(define-map campaign-registrations { campaign-id: uint, pool-id: uint } { reward-amount-x: uint, reward-amount-y: uint, total-staked: uint }) ;; Registration data of particular pool.\n(define-map campaign-stakers { campaign-id: uint, pool-id: uint, staker: principal } { amount: uint, claimed: bool }) ;; Staker data of particular pool.\n(define-map campaign-total-vote uint uint) ;; campaign-id -> total-votes\n(define-map campaign-registered-pools uint (list 1000 uint)) ;; campaign-id -> pool-ids\n(define-map campaign-registrants { campaign-id: uint, pool-id: uint, registrant: principal } { token-x-amount: uint, token-y-amount: uint }) ;; Needed for revoke adding rewards\n(define-map campaign-voter-votes { campaign-id: uint, voter: principal } uint) ;; Tracks how much voting power a voter has spent across all pools in a campaign\n(define-map campaign-pool-votes-by-voter { campaign-id: uint, pool-id: uint, voter: principal } uint) ;; Tracks votes per pool per voter - used for project reward calculation\n(define-map campaign-pool-votes-for-project-reward { campaign-id: uint, pool-id: uint } uint) ;; Tracks total votes per pool for project reward distribution\n(define-map campaign-pool-votes-for-alex-reward { campaign-id: uint, pool-id: uint } uint) ;; Tracks total votes per pool for ALEX reward distribution\n(define-map campaign-vote-rewards-claimed { campaign-id: uint, pool-id: uint, voter: principal } bool) ;; Add new map for tracking claimed vote rewards\n\n;; read-only functions\n\n;; __IF_MAINNET__\t\t\t\t\n(define-read-only (block-timestamp)\n  (ok (unwrap! (get-stacks-block-info? time (- stacks-block-height u1)) err-get-block-info)))\n;; (define-data-var custom-timestamp (optional uint) none)\n;; (define-public (set-custom-timestamp (new-timestamp (optional uint)))\n;;     (begin\n;;         (try! (is-dao-or-extension))\n;;         (var-set custom-timestamp new-timestamp)\n;;         (ok true)))\n;; (define-read-only (block-timestamp)\n;;     (match (var-get custom-timestamp)\n;;         timestamp (ok timestamp)\n;;         (ok (unwrap! (get-stacks-block-info? time (- stacks-block-height u1)) err-get-block-info))))\n;; __ENDIF__\n(define-read-only (is-dao-or-extension) (ok (asserts! (or (is-eq tx-sender 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.executor-dao) (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.executor-dao is-extension contract-caller)) err-not-authorized)))\n(define-read-only (get-campaign-nonce) (var-get campaign-nonce))\n(define-read-only (get-campaign-or-fail (campaign-id uint)) (ok (unwrap! (map-get? campaigns campaign-id) err-invalid-campaign-id)))\n(define-read-only (get-campaigns-or-fail-many (campaign-ids (list 200 uint))) (map get-campaign-or-fail campaign-ids))\n(define-read-only (get-campaign-registration-by-id-or-fail (campaign-id uint) (pool-id uint)) (ok (unwrap! (map-get? campaign-registrations { campaign-id: campaign-id, pool-id: pool-id }) err-invalid-campaign-registration)))\n(define-read-only (get-campaign-registration-by-id-or-fail-many (campaign-ids (list 200 uint)) (pool-ids (list 200 uint))) (map get-campaign-registration-by-id-or-fail campaign-ids pool-ids))\n(define-read-only (get-campaign-staker-or-default (campaign-id uint) (pool-id uint) (staker principal)) (default-to { amount: u0, claimed: false } (map-get? campaign-stakers { campaign-id: campaign-id, pool-id: pool-id, staker: staker })))\n(define-read-only (get-campaign-staker-or-default-many (campaign-ids (list 200 uint)) (pool-ids (list 200 uint)) (stakers (list 200 principal))) (map get-campaign-staker-or-default campaign-ids pool-ids stakers))\n(define-read-only (get-pool-whitelisted (pool-id uint)) (is-some (index-of (var-get whitelisted-pools) pool-id)))\n(define-read-only (get-whitelisted-pools) (var-get whitelisted-pools))\n\n(define-read-only (voting-power (campaign-id uint) (address principal) (lp-pools (list 200 uint)))\n  (let ((campaign (unwrap! (map-get? campaigns campaign-id) err-invalid-campaign-id))\n        (snapshot-block (get snapshot-block campaign))\n        (snapshot-block-id (unwrap-panic (get-stacks-block-info? id-header-hash snapshot-block)))\n        (snapshot-data (at-block snapshot-block-id\n          (let ((alex-balance (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex get-balance-fixed address)))\n                (auto-alex-balance (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wlialex get-balance-fixed address)))\n                (wrapped-auto-alex-balance \n\t\t\t\t\t\t\t\t\t(let ((bal-base (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.auto-alex-v3-wrapped get-shares-to-tokens (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.auto-alex-v3-wrapped get-balance address))))\n\t\t\t\t\t\t\t\t\t\t\t(decimals-base (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.auto-alex-v3-wrapped get-decimals))))\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t(if (is-eq decimals-base u8) bal-base (/ (* bal-base ONE_8) (pow u10 decimals-base)))))\t\t\t\t\t\t\t\t\t\n                (manual-balance (match (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.alex-staking-v2 get-user-id address)\n                  some-value (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.alex-staking-v2 get-staker-at-cycle-or-default (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.alex-staking-v2 get-reward-cycle tenure-height)) some-value)\n                  { amount-staked: u0, to-return: u0 }))\n\t\t\t\t\t\t\t\t(lp-voting-power (fold calculate-lp-voting-power lp-pools { address: address, total: u0 })))\n            { alex: alex-balance, auto-alex: auto-alex-balance, manual-alex: (+ (get amount-staked manual-balance) (get to-return manual-balance)), lp-power: (get total lp-voting-power), wrapped: wrapped-auto-alex-balance })))\n        (total-voting-power (+ (get alex snapshot-data) (get auto-alex snapshot-data) (get manual-alex snapshot-data) (get lp-power snapshot-data) (get wrapped snapshot-data)))\n        (voted-amount (default-to u0 (map-get? campaign-voter-votes { campaign-id: campaign-id, voter: address }))))\n    (ok { voting-power: total-voting-power, voted: voted-amount, snapshot-data: snapshot-data })))\n\n(define-read-only (get-campaign-registered-pools (campaign-id uint)) (ok (default-to (list) (map-get? campaign-registered-pools campaign-id))))\n\n(define-read-only (get-campaign-summary (campaign-id uint))\n  (let ((campaign (unwrap! (map-get? campaigns campaign-id) (err err-invalid-campaign-id)))\n        (registered-pool-ids (default-to (list) (map-get? campaign-registered-pools campaign-id)))\n        (pool-summaries-result (fold get-pool-summary-fold registered-pool-ids { campaign-id: campaign-id, summaries: (list) }))\n        (total-votes (default-to u0 (map-get? campaign-total-vote campaign-id))))\n    (ok (merge campaign { pool-summaries: (get summaries pool-summaries-result), total-votes: total-votes }))))\n\n(define-read-only (get-campaign-staker-history-many (address principal) (campaign-ids (list 200 uint)))\n  (get history (fold get-campaign-staker-history campaign-ids { address: address, history: (list) })))\n\n(define-read-only (get-registration-or-default (campaign-id uint) (pool-id uint) (registrant principal))\n  (default-to { token-x-amount: u0, token-y-amount: u0 } (map-get? campaign-registrants { campaign-id: campaign-id, pool-id: pool-id, registrant: registrant })))\n\n(define-read-only (get-registration-or-default-many (campaign-id uint) (pool-ids (list 1000 uint)) (registrant principal))\n  (fold get-registration-fold pool-ids { campaign-id: campaign-id, registrant: registrant, registrations: (list) }))\n\n(define-read-only (get-revoke-enabled) (var-get revoke-enabled))\n\n(define-read-only (get-project-reward-ignore-list) (var-get project-reward-ignore-list))\n\n;; public functions\n\n(define-public (stake (pool-id uint) (campaign-id uint) (amount uint))\n  (let ((current-timestamp (try! (block-timestamp)))\n        (campaign-details (try! (get-campaign-or-fail campaign-id)))\n        (campaign-registration-details (try! (get-campaign-registration-by-id-or-fail campaign-id pool-id)))\n        (staker-info (get-campaign-staker-or-default campaign-id pool-id tx-sender))\n        (updated-staker-stake (+ (get amount staker-info) amount))\n        (updated-total-stake (+ (get total-staked campaign-registration-details) amount)))\n    (asserts! (> current-timestamp (get registration-cutoff campaign-details)) err-registration-cutoff-not-passed)\n    (asserts! (< current-timestamp (get stake-cutoff campaign-details)) err-stake-cutoff-passed)\n    (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-amm-pool-v2-01 transfer-fixed pool-id amount tx-sender (as-contract tx-sender)))\n    (map-set campaign-registrations { campaign-id: campaign-id, pool-id: pool-id } (merge campaign-registration-details { total-staked: updated-total-stake }))\n    (map-set campaign-stakers { campaign-id: campaign-id, pool-id: pool-id, staker: tx-sender } { amount: updated-staker-stake, claimed: false })\n    (print { notification: \"stake\", payload: { sender: tx-sender, campaign-id: campaign-id, pool-id: pool-id, total-stake: updated-total-stake, staker-stake: updated-staker-stake, amount: amount }})\n    (ok true)))\n\n(define-public (unstake (pool-id uint) (campaign-id uint))\n  (let ((sender tx-sender)\n        (current-timestamp (try! (block-timestamp)))\n        (campaign-details (try! (get-campaign-or-fail campaign-id)))\n        (campaign-registration-details (try! (get-campaign-registration-by-id-or-fail campaign-id pool-id)))\n        (staker-info (get-campaign-staker-or-default campaign-id pool-id sender))\n        (staker-stake (get amount staker-info))\n        (pool-votes (default-to u0 (map-get? campaign-pool-votes-for-alex-reward { campaign-id: campaign-id, pool-id: pool-id })))\n        (total-votes (default-to u0 (map-get? campaign-total-vote campaign-id)))\n        (total-alex-reward-for-pool (if (is-eq total-votes u0) u0 (div-down (mul-down (get reward-amount campaign-details) pool-votes) total-votes)))\n        (alex-reward (div-down (mul-down total-alex-reward-for-pool staker-stake) (get total-staked campaign-registration-details))))\n    (asserts! (< (get stake-end campaign-details) current-timestamp) err-campaign-not-ended)\n    (asserts! (not (get claimed staker-info)) err-already-claimed)\n    (and (> alex-reward u0) (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex mint-fixed alex-reward sender)))\n    (map-set campaign-stakers { campaign-id: campaign-id, pool-id: pool-id, staker: sender } { amount: staker-stake, claimed: true })\n    (as-contract (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-amm-pool-v2-01 transfer-fixed pool-id staker-stake tx-sender sender)))\n    (print { notification: \"unstake\", payload: { sender: tx-sender, campaign-id: campaign-id, pool-id: pool-id, alex-reward: alex-reward, staker-stake: staker-stake }})\n    (ok true)))\n\n(define-public (register-for-campaign (pool-id uint) (campaign-id uint))\n  (let ((current-timestamp (try! (block-timestamp)))\n        (campaign-details (try! (get-campaign-or-fail campaign-id)))\n        (registered-pools (default-to (list) (map-get? campaign-registered-pools campaign-id)))\n        (existing-registration (map-get? campaign-registrations { campaign-id: campaign-id, pool-id: pool-id })))\n    (asserts! (get-pool-whitelisted pool-id) err-not-authorized)\n    (asserts! (< current-timestamp (get registration-cutoff campaign-details)) err-registration-cutoff-passed)\n    (asserts! (is-none existing-registration) err-pool-already-registered)\n    (map-set campaign-registrations { campaign-id: campaign-id, pool-id: pool-id } { reward-amount-x: u0, reward-amount-y: u0, total-staked: u0 })\n    (and (is-none (index-of registered-pools pool-id)) (map-set campaign-registered-pools campaign-id (unwrap! (as-max-len? (append registered-pools pool-id) u1000) err-invalid-input)))\n    (print { notification: \"register-for-campaign\", payload: { sender: tx-sender, campaign-id: campaign-id, pool-id: pool-id }})\n    (ok true)))\n\n(define-public (add-reward-for-campaign (pool-id uint) (campaign-id uint) (reward-token-trait <ft-trait>) (reward-amount uint))\n  (let ((reward-token (contract-of reward-token-trait))\n        (current-timestamp (try! (block-timestamp)))\n        (campaign-details (try! (get-campaign-or-fail campaign-id)))\n        (current-registration (get-registration-or-default campaign-id pool-id tx-sender))\n        (pool-details (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-pool-details-by-id pool-id)))\n        (is-token-x (is-eq reward-token (get token-x pool-details)))\n        (is-token-y (is-eq reward-token (get token-y pool-details))))\n    (asserts! (is-ok (get-campaign-registration-by-id-or-fail campaign-id pool-id)) err-pool-not-registered)\n    (asserts! (< current-timestamp (get voting-cutoff campaign-details)) err-voting-cutoff-passed)\n    (asserts! (or is-token-x is-token-y) err-invalid-reward-token)\n    (and (> reward-amount u0) (try! (contract-call? reward-token-trait transfer-fixed reward-amount tx-sender (as-contract tx-sender) none)))\n    (let ((registration (unwrap! (get-campaign-registration-by-id-or-fail campaign-id pool-id) err-pool-not-registered)))\n      (map-set campaign-registrations { campaign-id: campaign-id, pool-id: pool-id } (merge registration { reward-amount-x: (if is-token-x (+ (get reward-amount-x registration) reward-amount) (get reward-amount-x registration)), reward-amount-y: (if is-token-y (+ (get reward-amount-y registration) reward-amount) (get reward-amount-y registration)) })))\n    (map-set campaign-registrants { campaign-id: campaign-id, pool-id: pool-id, registrant: tx-sender } { token-x-amount: (if is-token-x (+ (get token-x-amount current-registration) reward-amount) (get token-x-amount current-registration)), token-y-amount: (if is-token-y (+ (get token-y-amount current-registration) reward-amount) (get token-y-amount current-registration)) })\n    (print { notification: \"add-reward-for-campaign\", payload: { sender: tx-sender, campaign-id: campaign-id, pool-id: pool-id, reward-token: reward-token, reward-amount-added: reward-amount }})\n    (ok true)))\n\n(define-public (vote-campaign (campaign-id uint) (votes (list 1000 { pool-id: uint, votes: uint })) (lp-pools (list 200 uint)))\n  (let ((campaign (unwrap! (map-get? campaigns campaign-id) err-invalid-campaign-id))\n        (current-timestamp (unwrap! (block-timestamp) err-get-block-info))\n        (voter-power (unwrap! (voting-power campaign-id tx-sender lp-pools) err-invalid-input))\n        (total-new-votes (fold + (map get-votes votes) u0))\n        (previous-votes (default-to u0 (map-get? campaign-voter-votes { campaign-id: campaign-id, voter: tx-sender })))\n        (total-votes-after (+ previous-votes total-new-votes)))\n    (asserts! (> current-timestamp (get registration-cutoff campaign)) err-registration-cutoff-not-passed)\n    (asserts! (< current-timestamp (get voting-cutoff campaign)) err-voting-cutoff-passed)\n    (asserts! (<= total-votes-after (get voting-power voter-power)) err-invalid-input)\n    (fold update-pool-votes votes { campaign-id: campaign-id, voter: tx-sender })\n    (map-set campaign-voter-votes { campaign-id: campaign-id, voter: tx-sender } total-votes-after)\n    (map-set campaign-total-vote campaign-id (+ (default-to u0 (map-get? campaign-total-vote campaign-id)) total-new-votes))\n    (print { notification: \"vote-campaign\", payload: { campaign-id: campaign-id, voter: tx-sender, votes: votes, total-new-votes: total-new-votes, total-votes-after: total-votes-after }})\n    (ok true)))\n\n(define-public (claim-vote-reward (pool-id uint) (campaign-id uint) (reward-token-x-trait <ft-trait>) (reward-token-y-trait <ft-trait>))\n  (let ((sender tx-sender)\n        (current-timestamp (try! (block-timestamp)))\n        (campaign-details (try! (get-campaign-or-fail campaign-id)))\n        (campaign-registration-details (try! (get-campaign-registration-by-id-or-fail campaign-id pool-id)))\n        (pool-details (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-pool-details-by-id pool-id)))\n        (voter-pool-votes (default-to u0 (map-get? campaign-pool-votes-by-voter { campaign-id: campaign-id, pool-id: pool-id, voter: sender })))\n        (pool-total-votes (default-to u0 (map-get? campaign-pool-votes-for-project-reward { campaign-id: campaign-id, pool-id: pool-id })))\n        (already-claimed (default-to false (map-get? campaign-vote-rewards-claimed { campaign-id: campaign-id, pool-id: pool-id, voter: sender })))\n        (is-ignored (is-some (index-of (var-get project-reward-ignore-list) sender)))\n\t\t\t\t(reward-x (div-down (mul-down (get reward-amount-x campaign-registration-details) voter-pool-votes) pool-total-votes))\n\t\t\t\t(reward-y (div-down (mul-down (get reward-amount-y campaign-registration-details) voter-pool-votes) pool-total-votes)))\n    (asserts! (> current-timestamp (get voting-cutoff campaign-details)) err-campaign-not-ended)\n    (asserts! (not already-claimed) err-already-claimed)\n    (asserts! (is-eq (contract-of reward-token-x-trait) (get token-x pool-details)) err-token-mismatch)\n    (asserts! (is-eq (contract-of reward-token-y-trait) (get token-y pool-details)) err-token-mismatch)\n    (asserts! (and (> voter-pool-votes u0) (not is-ignored)) err-invalid-input)\n    (and (> reward-x u0) (as-contract (try! (contract-call? reward-token-x-trait transfer-fixed reward-x tx-sender sender none))))\n    (and (> reward-y u0) (as-contract (try! (contract-call? reward-token-y-trait transfer-fixed reward-y tx-sender sender none))))\n    (map-set campaign-vote-rewards-claimed { campaign-id: campaign-id, pool-id: pool-id, voter: sender } true)\n    (print { notification: \"claim-vote-reward\", payload: { sender: tx-sender, campaign-id: campaign-id, pool-id: pool-id, voter-pool-votes: voter-pool-votes, pool-total-votes: pool-total-votes, reward-x: reward-x, reward-y: reward-y }})\n    (ok { reward-x: reward-x, reward-y: reward-y })))\n\n(define-public (claim-vote-reward-many (pool-ids (list 100 uint)) (campaign-ids (list 100 uint)) (reward-token-x-traits (list 100 <ft-trait>)) (reward-token-y-traits (list 100 <ft-trait>)))\n  (ok (map claim-vote-reward pool-ids campaign-ids reward-token-x-traits reward-token-y-traits)))\n\n;; privileged functions\n\n(define-public (revoke-registration (pool-id uint) (campaign-id uint) (registrant principal) (reward-token-x-trait <ft-trait>) (reward-token-y-trait <ft-trait>))\n  (let ((current-timestamp (try! (block-timestamp)))\n        (campaign-details (try! (get-campaign-or-fail campaign-id)))\n        (current-registration (get-registration-or-default campaign-id pool-id registrant))\n        (campaign-registration (try! (get-campaign-registration-by-id-or-fail campaign-id pool-id)))\n        (pool-details (try! (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-pool-details-by-id pool-id)))\n        (token-x-amount (get token-x-amount current-registration))\n        (token-y-amount (get token-y-amount current-registration)))    \n    (asserts! (or (and (get-revoke-enabled) (is-eq tx-sender registrant)) (is-ok (is-dao-or-extension))) err-not-authorized)\n    (asserts! (or (> token-x-amount u0) (> token-y-amount u0)) err-not-registered)\n    (asserts! (< current-timestamp (get registration-cutoff campaign-details)) err-registration-cutoff-passed)\n    (asserts! (is-eq (contract-of reward-token-x-trait) (get token-x pool-details)) err-token-mismatch)\n    (asserts! (is-eq (contract-of reward-token-y-trait) (get token-y pool-details)) err-token-mismatch)\n    (map-set campaign-registrations { campaign-id: campaign-id, pool-id: pool-id } (merge campaign-registration { reward-amount-x: (- (get reward-amount-x campaign-registration) token-x-amount), reward-amount-y: (- (get reward-amount-y campaign-registration) token-y-amount) }))\n    (map-set campaign-registrants { campaign-id: campaign-id, pool-id: pool-id, registrant: registrant } { token-x-amount: u0, token-y-amount: u0 })\n    (and (> token-x-amount u0) (as-contract (try! (contract-call? reward-token-x-trait transfer-fixed token-x-amount tx-sender registrant none))))\n    (and (> token-y-amount u0) (as-contract (try! (contract-call? reward-token-y-trait transfer-fixed token-y-amount tx-sender registrant none))))\n    (print { notification: \"revoke-registration\", payload: { campaign-id: campaign-id, pool-id: pool-id, registrant: registrant, token-x-amount-refunded: token-x-amount, token-y-amount-refunded: token-y-amount }})\n    (ok true)))\n\n;; governance functions\n\n(define-public (set-campaign-nonce (new-nonce uint))\n  (begin (try! (is-dao-or-extension)) (var-set campaign-nonce new-nonce) (ok true)))\n\n(define-public (set-revoke-enabled (enabled bool))\n  (begin (try! (is-dao-or-extension)) (ok (var-set revoke-enabled enabled))))\n\n(define-public (whitelist-pools (pools (list 1000 uint)))\n  (begin (try! (is-dao-or-extension)) (var-set whitelisted-pools pools) (ok true)))\n\n(define-public (create-campaign (registration-cutoff uint) (voting-cutoff uint) (stake-cutoff uint) (stake-end uint) (reward-amount uint) (snapshot-block uint))\n  (let ((campaign-id (+ (var-get campaign-nonce) u1)))\n    (try! (is-dao-or-extension))\n    (asserts! (< registration-cutoff voting-cutoff) err-invalid-input)\n    (asserts! (<= voting-cutoff stake-cutoff) err-invalid-input)\n    (asserts! (< stake-cutoff stake-end) err-invalid-input)\n    (map-set campaigns campaign-id { registration-cutoff: registration-cutoff, voting-cutoff: voting-cutoff, stake-cutoff: stake-cutoff, stake-end: stake-end, reward-amount: reward-amount, snapshot-block: snapshot-block })\n    (print { notification: \"create-campaign\", payload: { campaign-id: campaign-id, registration-cutoff: registration-cutoff, voting-cutoff: voting-cutoff, stake-cutoff: stake-cutoff, stake-end: stake-end, reward-amount: reward-amount, snapshot-block: snapshot-block }})\n    (var-set campaign-nonce campaign-id)\n    (ok campaign-id)))\n\n(define-public (transfer-token (token-trait <ft-trait>) (amount uint) (recipient principal))\n  (begin (try! (is-dao-or-extension)) (as-contract (contract-call? token-trait transfer-fixed amount tx-sender recipient none))))\n\n(define-public (update-campaign (campaign-id uint) (details { registration-cutoff: uint, voting-cutoff: uint, stake-cutoff: uint, stake-end: uint, reward-amount: uint, snapshot-block: uint }))\n  (let ((campaign-details (try! (get-campaign-or-fail campaign-id))))\n    (try! (is-dao-or-extension))\n    (asserts! (< (get registration-cutoff details) (get voting-cutoff details)) err-invalid-input)\n    (asserts! (<= (get voting-cutoff details) (get stake-cutoff details)) err-invalid-input)\n    (asserts! (< (get stake-cutoff details) (get stake-end details)) err-invalid-input)      \n    (map-set campaigns campaign-id details)\n    (print { notification: \"update-campaign\", payload: { campaign-id: campaign-id, details: details }})\n    (ok true)))\n\n(define-public (update-campaign-registrations (campaign-id uint) (pool-id uint) (reward-amount-x uint) (reward-amount-y uint) (total-staked uint))\n  (let ((registered-pools (default-to (list) (map-get? campaign-registered-pools campaign-id))))\n    (try! (is-dao-or-extension))\n    (map-set campaign-registrations { campaign-id: campaign-id, pool-id: pool-id } { reward-amount-x: reward-amount-x, reward-amount-y: reward-amount-y, total-staked: total-staked })\n    (and (is-none (index-of registered-pools pool-id)) (map-set campaign-registered-pools campaign-id (unwrap! (as-max-len? (append registered-pools pool-id) u1000) err-invalid-input)))\n    (print { notification: \"update-campaign-registrations\", payload: { campaign-id: campaign-id, pool-id: pool-id, reward-amount-x: reward-amount-x, reward-amount-y: reward-amount-y, total-staked: total-staked }})\n    (ok true)))\n\n(define-public (update-campaign-stakers (campaign-id uint) (pool-id uint) (staker principal) (amount uint) (claimed bool))\n  (begin\n    (try! (is-dao-or-extension))\n    (map-set campaign-stakers { campaign-id: campaign-id, pool-id: pool-id, staker: staker } { amount: amount, claimed: claimed })\n    (print { notification: \"update-campaign-stakers\", payload: { campaign-id: campaign-id, pool-id: pool-id, staker: staker, amount: amount, claimed: claimed }})\n    (ok true)))\n\n(define-public (update-campaign-registrants (campaign-id uint) (pool-id uint) (registrant principal) (token-x-amount uint) (token-y-amount uint))\n  (begin\n    (try! (is-dao-or-extension))\n    (map-set campaign-registrants { campaign-id: campaign-id, pool-id: pool-id, registrant: registrant } { token-x-amount: token-x-amount, token-y-amount: token-y-amount })\n    (print { notification: \"update-campaign-registrants\", payload: { campaign-id: campaign-id, pool-id: pool-id, registrant: registrant, token-x-amount: token-x-amount, token-y-amount: token-y-amount }})\n    (ok true)))\n\n(define-public (set-project-reward-ignore-list (addresses (list 1000 principal)))\n  (begin (try! (is-dao-or-extension)) (ok (var-set project-reward-ignore-list addresses))))\n\n;; private functions\n\n(define-private (check-err (result (response bool uint)) (prior (response bool uint)))\n  (match prior ok-value result err-value (err err-value)))\n\n(define-private (mul-down (a uint) (b uint)) (/ (* a b) ONE_8))\n\n(define-private (div-down (a uint) (b uint)) (if (is-eq a u0) u0 (/ (* a ONE_8) b)))\n\n(define-private (min (a uint) (b uint)) (if (<= a b) a b))\n\n(define-private (max (a uint) (b uint)) (if (>= a b) a b))\n\n(define-private (get-votes (entry { pool-id: uint, votes: uint })) (get votes entry))\n\n(define-private (update-pool-votes (vote { pool-id: uint, votes: uint }) (context { campaign-id: uint, voter: principal }))\n  (let ((campaign-id (get campaign-id context))\n        (voter (get voter context))\n        (pool-id (get pool-id vote))\n        (vote-amount (get votes vote))\n        (current-pool-votes-project (default-to u0 (map-get? campaign-pool-votes-for-project-reward { campaign-id: campaign-id, pool-id: pool-id })))\n        (current-pool-votes-alex (default-to u0 (map-get? campaign-pool-votes-for-alex-reward { campaign-id: campaign-id, pool-id: pool-id })))\n        (current-voter-pool-votes (default-to u0 (map-get? campaign-pool-votes-by-voter { campaign-id: campaign-id, pool-id: pool-id, voter: voter })))\n        (is-ignored (is-some (index-of (var-get project-reward-ignore-list) voter))))\n    (and (not is-ignored) (map-set campaign-pool-votes-for-project-reward { campaign-id: campaign-id, pool-id: pool-id } (+ current-pool-votes-project vote-amount)))\n    (map-set campaign-pool-votes-for-alex-reward { campaign-id: campaign-id, pool-id: pool-id } (+ current-pool-votes-alex vote-amount))\n    (map-set campaign-pool-votes-by-voter { campaign-id: campaign-id, pool-id: pool-id, voter: voter } (+ current-voter-pool-votes vote-amount))\n    context))\n\n(define-private (calculate-lp-voting-power (pool-id uint) (acc { address: principal, total: uint }))\n  (let ((pool-tokens (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-registry-v2-01 get-pool-details-by-id pool-id)))\n        (pool-details (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-pool-details (get token-x pool-tokens) (get token-y pool-tokens) (get factor pool-tokens))))\n        (total-supply (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-amm-pool-v2-01 get-total-supply pool-id)))\n        (user-farm-details (match (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.alex-farming get-user-id 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-amm-pool-v2-01 pool-id (get address acc))\n          some-value (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.alex-farming get-staker-at-cycle-or-default 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-amm-pool-v2-01 pool-id (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.alex-farming get-reward-cycle 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-amm-pool-v2-01 pool-id tenure-height)) some-value)\n          { amount-staked: u0, to-return: u0 }))\n        (user-lp-balance (+ (unwrap-panic (contract-call? 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-amm-pool-v2-01 get-balance pool-id (get address acc))) (get amount-staked user-farm-details) (get to-return user-farm-details)))\n        (alex-from-x (if (or (is-eq (get token-x pool-tokens) 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex) (is-eq (get token-x pool-tokens) 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.auto-alex-v3)) (/ (* user-lp-balance (get balance-x pool-details)) total-supply) u0))\n        (alex-from-y (if (or (is-eq (get token-y pool-tokens) 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-alex) (is-eq (get token-y pool-tokens) 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.auto-alex-v3)) (/ (* user-lp-balance (get balance-y pool-details)) total-supply) u0)))\n    (merge acc { total: (+ (get total acc) alex-from-x alex-from-y) })))\n\n(define-private (get-pool-summary-fold (pool-id uint) (acc { campaign-id: uint, summaries: (list 1000 { pool-id: uint, votes: uint, project-reward-votes: uint, reward-amount-x: uint, reward-amount-y: uint, total-staked: uint })}))\n  (let ((campaign-id (get campaign-id acc))\n        (registration (unwrap-panic (map-get? campaign-registrations { campaign-id: campaign-id, pool-id: pool-id })))\n        (votes (default-to u0 (map-get? campaign-pool-votes-for-alex-reward { campaign-id: campaign-id, pool-id: pool-id })))\n        (project-reward-votes (default-to u0 (map-get? campaign-pool-votes-for-project-reward { campaign-id: campaign-id, pool-id: pool-id })))\n        (summary { pool-id: pool-id, votes: votes, project-reward-votes: project-reward-votes, reward-amount-x: (get reward-amount-x registration), reward-amount-y: (get reward-amount-y registration), total-staked: (get total-staked registration) }))\n    (merge acc { summaries: (unwrap-panic (as-max-len? (append (get summaries acc) summary) u1000)) })))\n\n(define-private (get-campaign-staker-history (campaign-id uint) (acc { address: principal, history: (list 1000 { campaign-id: uint, pool-id: uint, staker-info: { amount: uint, claimed: bool } }) }))\n  (let ((address (get address acc))\n        (registered-pools (default-to (list) (map-get? campaign-registered-pools campaign-id)))\n        (campaign-history (fold get-pool-staker-history registered-pools { campaign-id: campaign-id, address: address, history: (list) })))\n    (merge acc { history: (unwrap-panic (as-max-len? (concat (get history acc) (get history campaign-history)) u1000)) })))\n\n(define-private (get-pool-staker-history (pool-id uint) (acc { campaign-id: uint, address: principal, history: (list 1000 { campaign-id: uint, pool-id: uint, staker-info: { amount: uint, claimed: bool } }) }))\n  (let ((campaign-id (get campaign-id acc))\n        (address (get address acc))\n        (staker-info (get-campaign-staker-or-default campaign-id pool-id address))\n        (staker-record { campaign-id: campaign-id, pool-id: pool-id, staker-info: staker-info })\n        (updated-history (if (> (get amount (get staker-info staker-record)) u0) (unwrap-panic (as-max-len? (append (get history acc) staker-record) u1000)) (get history acc))))\n    (merge acc { history: updated-history })))\n\n(define-private (get-registration-fold (pool-id uint) (acc { campaign-id: uint, registrant: principal, registrations: (list 1000 { pool-id: uint, token-x-amount: uint, token-y-amount: uint }) }))\n  (let ((campaign-id (get campaign-id acc))\n        (registrant (get registrant acc))\n        (registration-info (get-registration-or-default campaign-id pool-id registrant))\n        (registration { pool-id: pool-id, token-x-amount: (get token-x-amount registration-info), token-y-amount: (get token-y-amount registration-info) }))\n    (merge acc { registrations: (unwrap-panic (as-max-len? (append (get registrations acc) registration) u1000)) })))\n",
    "analysis": {
      "summary": "This contract manages campaigns where users can stake tokens, vote, and claim rewards based on their participation.",
      "explanation": "The contract is designed to facilitate a voting and rewards system for campaigns, allowing users to stake tokens, vote, and claim rewards. It interacts with external contracts for token transfers and balances, and maintains detailed records of campaigns, registrations, stakes, and votes to calculate rewards accurately.\n\n1. Data variables and constants:\n- Error codes <L5-24> define various error conditions.\n- Constants like `ONE_8` <L24> are used for decimal precision.\n- Data variables <L26-30> track campaign nonces, revocation settings, whitelisted pools, and project reward ignore lists.\n- Maps <L31-41> store comprehensive details about campaigns, registrations, stakers, votes, and claimed rewards.\n\n2. Functions analysis:\n- `stake` <L114-127> allows users to stake tokens in a campaign, checking cutoff times and updating staked amounts.\n- `unstake` <L129-146> enables users to unstake and claim rewards after a campaign ends, based on their stake and the total votes.\n- `register-for-campaign` <L148-159> lets pools register for a campaign before the registration cutoff.\n- `add-reward-for-campaign` <L161-177> allows adding rewards to a campaign, verifying token eligibility and updating reward amounts.\n- `vote-campaign` <L179-193> enables voting in campaigns, with checks for voting power and cutoff times.\n- `claim-vote-reward` <L195-216> and `claim-vote-reward-many` <L218-219> allow users to claim their voting rewards, ensuring they haven't already claimed and that the campaign has ended.\n- Privileged functions <L223-301> like `revoke-registration`, `set-campaign-nonce`, and `whitelist-pools` are controlled by governance, allowing for campaign and registration management.\n\nNotable qualities:\n- The contract integrates with external token contracts for balance checks and transfers, requiring adherence to the SIP-010 trait.\n- It uses a detailed mapping system to track and manage campaigns, registrations, stakes, votes, and rewards, ensuring accurate reward distribution.\n- Governance functions provide control over campaign parameters, revocation settings, and whitelisting pools, indicating a centralized control mechanism for campaign management.",
      "tags": ["voting", "staking", "governance", "rewards"]
    }
  },
  {
    "rank": 45,
    "contract": "SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.hoot-dex",
    "calls": 730,
    "source": ";; Index Contract - Combined LP Token and AMM implementation\n\n;; Implement SIP-010 trait\n(impl-trait .charisma-traits-v1.sip010-ft-trait)\n\n;; Define the LP token\n(define-fungible-token index)\n\n;; Constants\n(define-constant DEPLOYER tx-sender)\n(define-constant CONTRACT (as-contract tx-sender))\n(define-constant ERR_UNAUTHORIZED (err u401))\n(define-constant MAX_SWAP_FEE u50000) ;; 5%\n(define-constant FEE_DENOMINATION u1000000)\n(define-constant ERR_INVALID_FEE (err u402))\n(define-constant PRECISION u1000000)\n(define-constant MAX_ALPHA u1000000) ;; 1.0 in fixed point\n(define-constant MIN_ALPHA u0)       ;; 0.0 = constant sum (stableswap)\n                                     ;; 1.0 = constant product\n\n;; Storage\n(define-data-var owner principal DEPLOYER)\n(define-data-var alpha uint u1000000) ;; Default to constant product\n(define-data-var token-name (string-ascii 32) \"HooterDex\")\n(define-data-var token-symbol (string-ascii 10) \"HDX\")\n(define-data-var token-uri (optional (string-utf8 256)) \n  (some u\"https://charisma.rocks/sip10/hooter/metadata.json\"))\n(define-data-var contract-uri (optional (string-utf8 256)) \n  (some u\"https://charisma.rocks/api/v0/interactions/engines/hooterdex\"))\n(define-data-var swap-fee uint u4000) ;; Default 0.4%\n(define-data-var first-start-block uint stacks-block-height)\n\n(define-map last-tap-block principal uint)\n\n;; Configuration functions\n\n(define-public (set-owner (new-owner principal))\n  (begin\n    (asserts! (is-eq contract-caller (var-get owner)) ERR_UNAUTHORIZED)\n    (ok (var-set owner new-owner))))\n\n(define-public (set-alpha (new-alpha uint))\n  (begin\n    (asserts! (is-eq contract-caller (var-get owner)) ERR_UNAUTHORIZED)\n    (asserts! (<= new-alpha MAX_ALPHA) ERR_UNAUTHORIZED)\n    (ok (var-set alpha new-alpha))))\n\n(define-public (set-swap-fee (new-fee uint))\n  (begin\n    (asserts! (is-eq contract-caller (var-get owner)) ERR_UNAUTHORIZED)\n    (asserts! (<= new-fee MAX_SWAP_FEE) ERR_UNAUTHORIZED)\n    (ok (var-set swap-fee new-fee))))\n\n(define-public (set-token-uri (value (string-utf8 256)))\n  (if (is-eq contract-caller (var-get owner))\n    (ok (var-set token-uri (some value))) \n    ERR_UNAUTHORIZED))\n\n(define-public (set-contract-uri (new-uri (optional (string-utf8 256))))\n  (begin\n    (asserts! (is-eq contract-caller (var-get owner)) ERR_UNAUTHORIZED)\n    (ok (var-set contract-uri new-uri))))\n\n;; Core AMM operations\n\n(define-private (calculate-output-amount \n    (x uint)     ;; reserve in\n    (y uint)     ;; reserve out\n    (dx uint)    ;; amount in\n    (amp uint))  ;; alpha parameter\n  (let (\n    ;; Constant sum portion (better for similar values)\n    (sum-term (/ (* dx y) x))\n    \n    ;; Constant product portion (better for different values)\n    (product-term (/ (* dx y) (+ x dx)))\n    \n    ;; Weighted sum of both terms\n    (weighted-output (+ (* (- PRECISION amp) sum-term)\n                       (* amp product-term)))\n  )\n    (/ weighted-output PRECISION)))\n\n(define-public (swap (forward bool) (amt-in uint))\n  (let (\n    (sender tx-sender)\n    (reserve-in (unwrap-panic (if forward (contract-call? 'SP2D5BGGJ956A635JG7CJQ59FTRFRB0893514EZPJ.dme000-governance-token get-balance CONTRACT) \n      (contract-call? .hooter-the-owl get-balance CONTRACT))))\n    (reserve-out (unwrap-panic (if forward (contract-call? .hooter-the-owl get-balance CONTRACT) \n      (contract-call? 'SP2D5BGGJ956A635JG7CJQ59FTRFRB0893514EZPJ.dme000-governance-token get-balance CONTRACT))))\n    (paid-energy (match (contract-call? .charisma-rulebook-v0 exhaust u10000000 sender) success true error false))\n    ;; Calculate effective input amount\n    (effective-in (if paid-energy amt-in (/ (* amt-in (- FEE_DENOMINATION (var-get swap-fee))) FEE_DENOMINATION)))\n    ;; Calculate output with hybrid curve\n    (amt-out (calculate-output-amount \n               reserve-in \n               reserve-out \n               effective-in\n               (var-get alpha)))\n  )\n    (try! (if forward (contract-call? 'SP2D5BGGJ956A635JG7CJQ59FTRFRB0893514EZPJ.dme000-governance-token transfer amt-in sender CONTRACT none) \n      (contract-call? .hooter-the-owl transfer amt-in sender CONTRACT none)))\n    (try! (as-contract (if forward (contract-call? .hooter-the-owl transfer amt-out CONTRACT sender none)\n      (contract-call? 'SP2D5BGGJ956A635JG7CJQ59FTRFRB0893514EZPJ.dme000-governance-token transfer amt-out CONTRACT sender none))))\n    \n    (ok {amt-in: amt-in, amt-out: amt-out})))\n\n(define-public (mint (who principal) (amount uint))\n  (let (\n    (reserve0 (unwrap-panic (contract-call? 'SP2D5BGGJ956A635JG7CJQ59FTRFRB0893514EZPJ.dme000-governance-token get-balance CONTRACT)))\n    (reserve1 (unwrap-panic (contract-call? .hooter-the-owl get-balance CONTRACT)))\n    (total-supply (ft-get-supply index))\n    (token0-amount (if (is-eq total-supply u0)\n                      amount\n                      (/ (* amount reserve0) total-supply)))\n    (token1-amount (if (is-eq total-supply u0)\n                      amount\n                      (/ (* amount reserve1) total-supply)))\n  )\n    (asserts! (is-eq tx-sender who) ERR_UNAUTHORIZED)\n    (try! (contract-call? 'SP2D5BGGJ956A635JG7CJQ59FTRFRB0893514EZPJ.dme000-governance-token transfer token0-amount who CONTRACT none))\n    (try! (contract-call? .hooter-the-owl transfer token1-amount who CONTRACT none))\n    (try! (ft-mint? index amount who))\n    \n    (ok {token0-amount: token0-amount, \n         token1-amount: token1-amount, \n         lp-amount: amount})))\n\n(define-public (burn (who principal) (amount uint))\n  (let (\n    (reserve0 (unwrap-panic (contract-call? 'SP2D5BGGJ956A635JG7CJQ59FTRFRB0893514EZPJ.dme000-governance-token get-balance CONTRACT)))\n    (reserve1 (unwrap-panic (contract-call? .hooter-the-owl get-balance CONTRACT)))\n    (total-supply (ft-get-supply index))\n    (token0-amount (/ (* amount reserve0) total-supply))\n    (token1-amount (/ (* amount reserve1) total-supply))\n  )\n    (asserts! (is-eq tx-sender who) ERR_UNAUTHORIZED)\n    (try! (ft-burn? index amount who))\n    (try! (as-contract (contract-call? 'SP2D5BGGJ956A635JG7CJQ59FTRFRB0893514EZPJ.dme000-governance-token transfer token0-amount CONTRACT who none)))\n    (try! (as-contract (contract-call? .hooter-the-owl transfer token1-amount CONTRACT who none)))\n    \n    (ok {token0-amount: token0-amount, \n         token1-amount: token1-amount, \n         lp-amount: amount})))\n\n;; Read functions\n\n(define-read-only (get-owner)\n  (ok (var-get owner)))\n\n(define-read-only (get-alpha)\n  (ok (var-get alpha)))\n\n(define-read-only (get-tokens)\n  (ok {token0: 'SP2D5BGGJ956A635JG7CJQ59FTRFRB0893514EZPJ.dme000-governance-token, token1: .hooter-the-owl}))\n\n(define-read-only (get-swap-fee)\n  (ok (var-get swap-fee)))\n\n(define-read-only (get-reserves)\n  (ok {\n    token0: (unwrap-panic (contract-call? 'SP2D5BGGJ956A635JG7CJQ59FTRFRB0893514EZPJ.dme000-governance-token get-balance CONTRACT)),\n    token1: (unwrap-panic (contract-call? .hooter-the-owl get-balance CONTRACT))\n  }))\n\n(define-read-only (get-quote (forward bool) (amt-in uint) (apply-fee bool))\n  (let (\n    (reserve-in (unwrap-panic (if forward (contract-call? 'SP2D5BGGJ956A635JG7CJQ59FTRFRB0893514EZPJ.dme000-governance-token get-balance CONTRACT) \n      (contract-call? .hooter-the-owl get-balance CONTRACT))))\n    (reserve-out (unwrap-panic (if forward (contract-call? .hooter-the-owl get-balance CONTRACT) \n      (contract-call? 'SP2D5BGGJ956A635JG7CJQ59FTRFRB0893514EZPJ.dme000-governance-token get-balance CONTRACT))))\n    ;; Apply fee if requested\n    (effective-in (if apply-fee\n                     (/ (* amt-in (- FEE_DENOMINATION (var-get swap-fee))) \n                        FEE_DENOMINATION)\n                     amt-in))\n  )\n    (ok (calculate-output-amount \n          reserve-in \n          reserve-out \n          effective-in \n          (var-get alpha)))))\n\n;; SIP-010 Implementation\n(define-read-only (get-name)\n  (ok (var-get token-name)))\n\n(define-read-only (get-symbol)\n  (ok (var-get token-symbol)))\n\n(define-read-only (get-decimals)\n  (ok u6))\n\n(define-read-only (get-balance (who principal))\n  (ok (ft-get-balance index who)))\n\n(define-read-only (get-total-supply)\n  (ok (ft-get-supply index)))\n\n(define-read-only (get-token-uri)\n  (ok (var-get token-uri)))\n\n(define-public (transfer (amount uint) (from principal) (to principal) (memo (optional (buff 34))))\n  (begin\n    (asserts! (is-eq tx-sender from) ERR_UNAUTHORIZED)\n    (ft-transfer? index amount from to)))\n\n\n;; Hold-to-Earn functions\n\n(define-private (get-balance-at (data { address: principal, block: uint }))\n    (let ((target-block (get block data)))\n        (if (< target-block stacks-block-height)\n            (let ((block-hash (unwrap-panic (get-stacks-block-info? id-header-hash target-block))))\n                (at-block block-hash (unwrap-panic (get-balance (get address data)))))\n                (unwrap-panic (get-balance (get address data))))))\n\n(define-private (calculate-trapezoid-areas-39 (balances (list 39 uint)) (dx uint))\n    (list\n        (/ (* (+ (unwrap-panic (element-at balances u0)) (unwrap-panic (element-at balances u1))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u1)) (unwrap-panic (element-at balances u2))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u2)) (unwrap-panic (element-at balances u3))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u3)) (unwrap-panic (element-at balances u4))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u4)) (unwrap-panic (element-at balances u5))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u5)) (unwrap-panic (element-at balances u6))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u6)) (unwrap-panic (element-at balances u7))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u7)) (unwrap-panic (element-at balances u8))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u8)) (unwrap-panic (element-at balances u9))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u9)) (unwrap-panic (element-at balances u10))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u10)) (unwrap-panic (element-at balances u11))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u11)) (unwrap-panic (element-at balances u12))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u12)) (unwrap-panic (element-at balances u13))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u13)) (unwrap-panic (element-at balances u14))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u14)) (unwrap-panic (element-at balances u15))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u15)) (unwrap-panic (element-at balances u16))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u16)) (unwrap-panic (element-at balances u17))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u17)) (unwrap-panic (element-at balances u18))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u18)) (unwrap-panic (element-at balances u19))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u19)) (unwrap-panic (element-at balances u20))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u20)) (unwrap-panic (element-at balances u21))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u21)) (unwrap-panic (element-at balances u22))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u22)) (unwrap-panic (element-at balances u23))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u23)) (unwrap-panic (element-at balances u24))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u24)) (unwrap-panic (element-at balances u25))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u25)) (unwrap-panic (element-at balances u26))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u26)) (unwrap-panic (element-at balances u27))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u27)) (unwrap-panic (element-at balances u28))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u28)) (unwrap-panic (element-at balances u29))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u29)) (unwrap-panic (element-at balances u30))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u30)) (unwrap-panic (element-at balances u31))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u31)) (unwrap-panic (element-at balances u32))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u32)) (unwrap-panic (element-at balances u33))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u33)) (unwrap-panic (element-at balances u34))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u34)) (unwrap-panic (element-at balances u35))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u35)) (unwrap-panic (element-at balances u36))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u36)) (unwrap-panic (element-at balances u37))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u37)) (unwrap-panic (element-at balances u38))) dx) u2)))\n\n(define-private (calculate-trapezoid-areas-19 (balances (list 19 uint)) (dx uint))\n    (list\n        (/ (* (+ (unwrap-panic (element-at balances u0)) (unwrap-panic (element-at balances u1))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u1)) (unwrap-panic (element-at balances u2))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u2)) (unwrap-panic (element-at balances u3))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u3)) (unwrap-panic (element-at balances u4))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u4)) (unwrap-panic (element-at balances u5))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u5)) (unwrap-panic (element-at balances u6))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u6)) (unwrap-panic (element-at balances u7))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u7)) (unwrap-panic (element-at balances u8))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u8)) (unwrap-panic (element-at balances u9))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u9)) (unwrap-panic (element-at balances u10))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u10)) (unwrap-panic (element-at balances u11))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u11)) (unwrap-panic (element-at balances u12))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u12)) (unwrap-panic (element-at balances u13))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u13)) (unwrap-panic (element-at balances u14))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u14)) (unwrap-panic (element-at balances u15))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u15)) (unwrap-panic (element-at balances u16))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u16)) (unwrap-panic (element-at balances u17))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u17)) (unwrap-panic (element-at balances u18))) dx) u2)))\n\n(define-private (calculate-trapezoid-areas-9 (balances (list 9 uint)) (dx uint))\n    (list\n        (/ (* (+ (unwrap-panic (element-at balances u0)) (unwrap-panic (element-at balances u1))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u1)) (unwrap-panic (element-at balances u2))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u2)) (unwrap-panic (element-at balances u3))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u3)) (unwrap-panic (element-at balances u4))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u4)) (unwrap-panic (element-at balances u5))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u5)) (unwrap-panic (element-at balances u6))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u6)) (unwrap-panic (element-at balances u7))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u7)) (unwrap-panic (element-at balances u8))) dx) u2)))\n\n(define-private (calculate-trapezoid-areas-5 (balances (list 5 uint)) (dx uint))\n    (list\n        (/ (* (+ (unwrap-panic (element-at balances u0)) (unwrap-panic (element-at balances u1))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u1)) (unwrap-panic (element-at balances u2))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u2)) (unwrap-panic (element-at balances u3))) dx) u2)\n        (/ (* (+ (unwrap-panic (element-at balances u3)) (unwrap-panic (element-at balances u4))) dx) u2)))\n\n(define-private (calculate-trapezoid-areas-2 (balances (list 2 uint)) (dx uint))\n    (list\n        (/ (* (+ (unwrap-panic (element-at balances u0)) (unwrap-panic (element-at balances u1))) dx) u2)))\n\n(define-private (calculate-balance-integral-39 (address principal) (start-block uint) (end-block uint))\n    (let (\n        (sample-points (contract-call? .meme-engine-manager-rc2 generate-sample-points-39 address start-block end-block))\n        (balances (map get-balance-at sample-points))\n        (dx (/ (- end-block start-block) u38))\n        (areas (calculate-trapezoid-areas-39 balances dx)))\n        (fold + areas u0)))\n\n(define-private (calculate-balance-integral-19 (address principal) (start-block uint) (end-block uint))\n    (let (\n        (sample-points (contract-call? .meme-engine-manager-rc2 generate-sample-points-19 address start-block end-block))\n        (balances (map get-balance-at sample-points))\n        (dx (/ (- end-block start-block) u18))\n        (areas (calculate-trapezoid-areas-19 balances dx)))\n        (fold + areas u0)))\n\n(define-private (calculate-balance-integral-9 (address principal) (start-block uint) (end-block uint))\n    (let (\n        (sample-points (contract-call? .meme-engine-manager-rc2 generate-sample-points-9 address start-block end-block))\n        (balances (map get-balance-at sample-points))\n        (dx (/ (- end-block start-block) u8))\n        (areas (calculate-trapezoid-areas-9 balances dx)))\n        (fold + areas u0)))\n\n(define-private (calculate-balance-integral-5 (address principal) (start-block uint) (end-block uint))\n    (let (\n        (sample-points (contract-call? .meme-engine-manager-rc2 generate-sample-points-5 address start-block end-block))\n        (balances (map get-balance-at sample-points))\n        (dx (/ (- end-block start-block) u4))\n        (areas (calculate-trapezoid-areas-5 balances dx)))\n        (fold + areas u0)))\n\n(define-private (calculate-balance-integral-2 (address principal) (start-block uint) (end-block uint))\n    (let (\n        (sample-points (contract-call? .meme-engine-manager-rc2 generate-sample-points-2 address start-block end-block))\n        (balances (map get-balance-at sample-points))\n        (dx (/ (- end-block start-block) u1))\n        (areas (calculate-trapezoid-areas-2 balances dx)))\n        (fold + areas u0)))\n\n(define-private (calculate-balance-integral (address principal) (start-block uint) (end-block uint))\n    (let (\n        (block-difference (- end-block start-block))\n        (thresholds (unwrap-panic (contract-call? .meme-engine-manager-rc2 get-thresholds))))\n        (if (>= block-difference (get threshold-39-point thresholds)) (calculate-balance-integral-39 address start-block end-block)\n        (if (>= block-difference (get threshold-19-point thresholds)) (calculate-balance-integral-19 address start-block end-block)\n        (if (>= block-difference (get threshold-9-point thresholds)) (calculate-balance-integral-9 address start-block end-block)\n        (if (>= block-difference (get threshold-5-point thresholds)) (calculate-balance-integral-5 address start-block end-block)\n        (calculate-balance-integral-2 address start-block end-block)))))))\n\n(define-read-only (get-last-tap-block (address principal))\n    (default-to (var-get first-start-block) (map-get? last-tap-block address)))\n\n(define-read-only (get-contract-uri)\n  (ok (var-get contract-uri)))\n\n(define-public (tap)\n  (let (\n    (sender tx-sender)\n    (end-block stacks-block-height)\n    (start-block (get-last-tap-block sender))\n    (balance-integral (calculate-balance-integral sender start-block end-block))\n    (incentive-score (contract-call? .aura get-incentive-score CONTRACT))\n    (circulating-supply (unwrap-panic (get-total-supply)))\n    (potential-energy (/ (* balance-integral incentive-score) circulating-supply)))\n    (map-set last-tap-block sender end-block)\n    (contract-call? .charisma-rulebook-v0 energize potential-energy sender)))",
    "analysis": {
      "summary": "This contract combines an Automated Market Maker (AMM) with a Liquidity Provider (LP) token, implementing the SIP-010 standard for fungible tokens.",
      "explanation": "The contract begins by implementing the SIP-010 trait for fungible tokens, establishing itself as a compliant Stacks blockchain token contract <L4>. It defines a fungible token named 'index' <L7>, which serves as the LP token for participants in the AMM pool.\n\n1. The contract's data variables and constants include:\n- The `DEPLOYER` constant <L10> stores the contract's deployer address.\n- `CONTRACT` <L11> represents the contract's own principal, used for internal calls.\n- Error messages such as `ERR_UNAUTHORIZED` <L12> and `ERR_INVALID_FEE` <L15> are defined for handling unauthorized access and invalid fee inputs, respectively.\n- Fee-related constants like `MAX_SWAP_FEE` <L13> and `FEE_DENOMINATION` <L14> are set to manage swap fees within the AMM functionality.\n- The `alpha` variable <L23> controls the AMM curve, balancing between constant product and constant sum formulas.\n- Metadata variables like `token-name` <L24> and `token-uri` <L26> store information about the LP token.\n\n2. Configuration functions such as `set-owner` <L37-40> and `set-alpha` <L42-46> allow the contract owner to update critical parameters, ensuring that only the owner can modify these settings.\n\n3. The core AMM operation `swap` <L84-106> enables users to exchange tokens with the pool, adjusting for fees and using a hybrid curve for price calculation.\n\n4. Liquidity operations `mint` <L108-127> and `burn` <L129-144> allow users to add or remove liquidity from the pool, receiving or surrendering LP tokens in proportion to their share.\n\n5. Read-only functions provide information about the contract state, such as `get-owner` <L148-149> and `get-reserves` <L160-164>, which are essential for users to interact with the contract effectively.\n\n6. The `tap` function <L358-368> introduces a unique mechanism for users to claim rewards based on their participation and the time their liquidity is active within the pool, calculated through a series of complex integral calculations <L302-350>.\n\n7. The contract includes several private functions for calculating balance integrals <L302-350>, which are used to determine user rewards based on their liquidity provision over time.",
      "tags": ["AMM", "LP-token", "SIP-010", "DeFi"]
    }
  },
  {
    "rank": 46,
    "contract": "SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.stableswap-core-v-1-2",
    "calls": 730,
    "source": "\n;; stableswap-core-v-1-2\n\n;; Use Stableswap pool trait and SIP 010 trait\n(use-trait stableswap-pool-trait .stableswap-pool-trait-v-1-2.stableswap-pool-trait)\n(use-trait sip-010-trait .sip-010-trait-ft-standard-v-1-1.sip-010-trait)\n\n;; Error constants\n(define-constant ERR_NOT_AUTHORIZED (err u1001))\n(define-constant ERR_INVALID_AMOUNT (err u1002))\n(define-constant ERR_INVALID_PRINCIPAL (err u1003))\n(define-constant ERR_ALREADY_ADMIN (err u1004))\n(define-constant ERR_ADMIN_LIMIT_REACHED (err u1005))\n(define-constant ERR_ADMIN_NOT_IN_LIST (err u1006))\n(define-constant ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER (err u1007))\n(define-constant ERR_NO_POOL_DATA (err u1008))\n(define-constant ERR_POOL_NOT_CREATED (err u1009))\n(define-constant ERR_POOL_DISABLED (err u1010))\n(define-constant ERR_POOL_ALREADY_CREATED (err u1011))\n(define-constant ERR_INVALID_POOL (err u1012))\n(define-constant ERR_INVALID_POOL_URI (err u1013))\n(define-constant ERR_INVALID_POOL_SYMBOL (err u1014))\n(define-constant ERR_INVALID_POOL_NAME (err u1015))\n(define-constant ERR_MATCHING_TOKEN_CONTRACTS (err u1016))\n(define-constant ERR_INVALID_X_TOKEN (err u1017))\n(define-constant ERR_INVALID_Y_TOKEN (err u1018))\n(define-constant ERR_MINIMUM_X_AMOUNT (err u1019))\n(define-constant ERR_MINIMUM_Y_AMOUNT (err u1020))\n(define-constant ERR_MINIMUM_LP_AMOUNT (err u1021))\n(define-constant ERR_UNEQUAL_POOL_BALANCES (err u1022))\n(define-constant ERR_MINIMUM_D_VALUE (err u1023))\n(define-constant ERR_INVALID_FEE (err u1024))\n(define-constant ERR_MINIMUM_BURN_AMOUNT (err u1025))\n(define-constant ERR_INVALID_MIN_BURNT_SHARES (err u1026))\n\n;; Contract deployer address\n(define-constant CONTRACT_DEPLOYER tx-sender)\n\n;; Number of tokens per pair\n(define-constant NUM_OF_TOKENS u2)\n\n;; Multiplier used in swaps to check if amount is less than x10 of balance\n(define-constant MAX_AMOUNT_PER_BALANCE_MULTIPLIER u10)\n\n;; Maximum BPS\n(define-constant BPS u10000)\n\n;; Index loop for using Newton-Raphson method to converge square root that goes up to u384\n(define-constant index-list (list u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13 u14 u15 u16 u17 u18 u19 u20 u21 u22 u23 u24 u25 u26 u27 u28 u29 u30 u31 u32 u33 u34 u35 u36 u37 u38 u39 u40 u41 u42 u43 u44 u45 u46 u47 u48 u49 u50 u51 u52 u53 u54 u55 u56 u57 u58 u59 u60 u61 u62 u63 u64 u65 u66 u67 u68 u69 u70 u71 u72 u73 u74 u75 u76 u77 u78 u79 u80 u81 u82 u83 u84 u85 u86 u87 u88 u89 u90 u91 u92 u93 u94 u95 u96 u97 u98 u99 u100 u101 u102 u103 u104 u105 u106 u107 u108 u109 u110 u111 u112 u113 u114 u115 u116 u117 u118 u119 u120 u121 u122 u123 u124 u125 u126 u127 u128 u129 u130 u131 u132 u133 u134 u135 u136 u137 u138 u139 u140 u141 u142 u143 u144 u145 u146 u147 u148 u149 u150 u151 u152 u153 u154 u155 u156 u157 u158 u159 u160 u161 u162 u163 u164 u165 u166 u167 u168 u169 u170 u171 u172 u173 u174 u175 u176 u177 u178 u179 u180 u181 u182 u183 u184 u185 u186 u187 u188 u189 u190 u191 u192 u193 u194 u195 u196 u197 u198 u199 u200 u201 u202 u203 u204 u205 u206 u207 u208 u209 u210 u211 u212 u213 u214 u215 u216 u217 u218 u219 u220 u221 u222 u223 u224 u225 u226 u227 u228 u229 u230 u231 u232 u233 u234 u235 u236 u237 u238 u239 u240 u241 u242 u243 u244 u245 u246 u247 u248 u249 u250 u251 u252 u253 u254 u255 u256 u257 u258 u259 u260 u261 u262 u263 u264 u265 u266 u267 u268 u269 u270 u271 u272 u273 u274 u275 u276 u277 u278 u279 u280 u281 u282 u283 u284 u285 u286 u287 u288 u289 u290 u291 u292 u293 u294 u295 u296 u297 u298 u299 u300 u301 u302 u303 u304 u305 u306 u307 u308 u309 u310 u311 u312 u313 u314 u315 u316 u317 u318 u319 u320 u321 u322 u323 u324 u325 u326 u327 u328 u329 u330 u331 u332 u333 u334 u335 u336 u337 u338 u339 u340 u341 u342 u343 u344 u345 u346 u347 u348 u349 u350 u351 u352 u353 u354 u355 u356 u357 u358 u359 u360 u361 u362 u363 u364 u365 u366 u367 u368 u369 u370 u371 u372 u373 u374 u375 u376 u377 u378 u379 u380 u381 u382 u383 u384))\n\n;; Admins list and helper var used to remove admins\n(define-data-var admins (list 5 principal) (list tx-sender))\n(define-data-var admin-helper principal tx-sender)\n\n;; ID of last created pool\n(define-data-var last-pool-id uint u0)\n\n;; Minimum shares required to mint when creating a pool\n(define-data-var minimum-total-shares uint u10000)\n\n;; Minimum shares required to burn when creating a pool\n(define-data-var minimum-burnt-shares uint u1000)\n\n;; Data var used to enable or disable pool creation by anyone\n(define-data-var public-pool-creation bool false)\n\n;; Define pools map\n(define-map pools uint {\n    id: uint,\n    name: (string-ascii 32),\n    symbol: (string-ascii 32),\n    pool-contract: principal\n})\n\n;; Get admins list\n(define-read-only (get-admins)\n    (ok (var-get admins))\n)\n\n;; Get admin helper var\n(define-read-only (get-admin-helper)\n    (ok (var-get admin-helper))\n)\n\n;; Get ID of last created pool\n(define-read-only (get-last-pool-id)\n    (ok (var-get last-pool-id))\n)\n\n;; Get a pool by pool ID\n(define-read-only (get-pool-by-id (id uint))\n    (ok (map-get? pools id))\n)\n\n;; Get minimum shares required to mint when creating a pool\n(define-read-only (get-minimum-total-shares)\n    (ok (var-get minimum-total-shares))\n)\n\n;; Get minimum shares required to burn when creating a pool\n(define-read-only (get-minimum-burnt-shares)\n    (ok (var-get minimum-burnt-shares))\n)\n\n;; Get public pool creation status\n(define-read-only (get-public-pool-creation)\n    (ok (var-get public-pool-creation))\n)\n\n;; Get DY\n(define-public (get-dy\n    (pool-trait <stableswap-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (x-amount uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (protocol-fee (get x-protocol-fee pool-data))\n    (provider-fee (get x-provider-fee pool-data))\n    (convergence-threshold (get convergence-threshold pool-data))\n    (amplification-coefficient (get amplification-coefficient pool-data))\n    \n    ;; Scale up pool balances and swap amounts to perform AMM calculations with get-y\n    (pool-balances-scaled (scale-up-amounts x-balance y-balance x-token-trait y-token-trait))\n    (x-balance-scaled (get x-amount pool-balances-scaled))\n    (y-balance-scaled (get y-amount pool-balances-scaled))\n    (swap-amounts-scaled (scale-up-amounts x-amount u0 x-token-trait y-token-trait))\n    (x-amount-scaled (get x-amount swap-amounts-scaled))\n    (x-amount-fees-protocol-scaled (/ (* x-amount-scaled protocol-fee) BPS))\n    (x-amount-fees-provider-scaled (/ (* x-amount-scaled provider-fee) BPS))\n    (x-amount-fees-total-scaled (+ x-amount-fees-protocol-scaled x-amount-fees-provider-scaled))\n    (dx-scaled (- x-amount-scaled x-amount-fees-total-scaled))\n    (updated-y-balance-scaled (get-y dx-scaled x-balance-scaled y-balance-scaled amplification-coefficient convergence-threshold))\n    \n    ;; Scale down to precise amounts for y and dy\n    (updated-y-balance (get y-amount (scale-down-amounts u0 updated-y-balance-scaled x-token-trait y-token-trait)))\n    (dy (- y-balance updated-y-balance))\n    )\n    ;; Assert that pool-status is true and correct token traits are used\n    (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n    (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n    (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n\n    ;; Assert that x-amount is greater than 0 and less than x10 of x-balance\n    (asserts! (and (> x-amount u0) (< x-amount (* x-balance MAX_AMOUNT_PER_BALANCE_MULTIPLIER))) ERR_INVALID_AMOUNT)\n    \n    ;; Return number of y tokens the caller would receive\n    (ok dy)\n    )\n)\n\n;; Get DX\n(define-public (get-dx\n    (pool-trait <stableswap-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (y-amount uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (protocol-fee (get y-protocol-fee pool-data))\n    (provider-fee (get y-provider-fee pool-data))\n    (convergence-threshold (get convergence-threshold pool-data))\n    (amplification-coefficient (get amplification-coefficient pool-data))\n    \n    ;; Scale up pool balances and swap amounts to perform AMM calculations with get-x\n    (pool-balances-scaled (scale-up-amounts x-balance y-balance x-token-trait y-token-trait))\n    (x-balance-scaled (get x-amount pool-balances-scaled))\n    (y-balance-scaled (get y-amount pool-balances-scaled))\n    (swap-amounts-scaled (scale-up-amounts u0 y-amount x-token-trait y-token-trait))\n    (y-amount-scaled (get y-amount swap-amounts-scaled))\n    (y-amount-fees-protocol-scaled (/ (* y-amount-scaled protocol-fee) BPS))\n    (y-amount-fees-provider-scaled (/ (* y-amount-scaled provider-fee) BPS))\n    (y-amount-fees-total-scaled (+ y-amount-fees-protocol-scaled y-amount-fees-provider-scaled))\n    (dy-scaled (- y-amount-scaled y-amount-fees-total-scaled))\n    (updated-x-balance-scaled (get-x dy-scaled y-balance-scaled x-balance-scaled amplification-coefficient convergence-threshold))\n    \n    ;; Scale down to precise amounts for x and dx\n    (updated-x-balance (get x-amount (scale-down-amounts updated-x-balance-scaled u0 x-token-trait y-token-trait)))\n    (dx (- x-balance updated-x-balance))\n    )\n    ;; Assert that pool-status is true and correct token traits are used\n    (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n    (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n    (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n\n    ;; Assert that y-amount is greater than 0 and less than x10 of y-balance\n    (asserts! (and (> y-amount u0) (< y-amount (* y-balance MAX_AMOUNT_PER_BALANCE_MULTIPLIER))) ERR_INVALID_AMOUNT)\n    \n    ;; Return number of x tokens the caller would receive\n    (ok dx)\n    )\n)\n\n;; Get DLP\n(define-public (get-dlp\n    (pool-trait <stableswap-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (x-amount uint) (y-amount uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (total-shares (get total-shares pool-data))\n    (liquidity-fee (get liquidity-fee pool-data))\n    (convergence-threshold (get convergence-threshold pool-data))\n    (amplification-coefficient (get amplification-coefficient pool-data))\n    (updated-x-balance (+ x-balance x-amount))\n    (updated-y-balance (+ y-balance y-amount))\n    \n    ;; Scale up for AMM calculations depending on decimal places assigned to tokens\n    (amounts-added-scaled (scale-up-amounts x-amount y-amount x-token-trait y-token-trait))\n    (x-amount-scaled (get x-amount amounts-added-scaled))\n    (y-amount-scaled (get y-amount amounts-added-scaled))\n    (pool-balances-scaled (scale-up-amounts x-balance y-balance x-token-trait y-token-trait))\n    (x-balance-scaled (get x-amount pool-balances-scaled))\n    (y-balance-scaled (get y-amount pool-balances-scaled))\n    (updated-pool-balances-scaled (scale-up-amounts updated-x-balance updated-y-balance x-token-trait y-token-trait))\n    (updated-x-balance-scaled (get x-amount updated-pool-balances-scaled))\n    (updated-y-balance-scaled (get y-amount updated-pool-balances-scaled))\n    \n    ;; Calculate ideal pool balance\n    (d-a (get-d x-balance-scaled y-balance-scaled amplification-coefficient convergence-threshold))\n    (d-b (get-d updated-x-balance-scaled updated-y-balance-scaled amplification-coefficient convergence-threshold))\n    (ideal-x-balance-scaled (/ (* d-b x-balance-scaled) d-a))\n    (ideal-y-balance-scaled (/ (* d-b y-balance-scaled) d-a))\n    (x-difference (if (> ideal-x-balance-scaled updated-x-balance-scaled) (- ideal-x-balance-scaled updated-x-balance-scaled) (- updated-x-balance-scaled ideal-x-balance-scaled)))\n    (y-difference (if (> ideal-y-balance-scaled updated-y-balance-scaled) (- ideal-y-balance-scaled updated-y-balance-scaled) (- updated-y-balance-scaled ideal-y-balance-scaled)))\n    \n    ;; Calculate fees to apply if adding imbalanced liquidity\n    (ideal-x-amount-fee-liquidity-scaled (/ (* x-difference liquidity-fee) BPS))\n    (ideal-y-amount-fee-liquidity-scaled (/ (* y-difference liquidity-fee) BPS))\n    (x-amount-fee-liquidity-scaled (if (> x-amount-scaled ideal-x-amount-fee-liquidity-scaled) ideal-x-amount-fee-liquidity-scaled x-amount-scaled))\n    (y-amount-fee-liquidity-scaled (if (> y-amount-scaled ideal-y-amount-fee-liquidity-scaled) ideal-y-amount-fee-liquidity-scaled y-amount-scaled))\n    (updated-x-amount-scaled (- x-amount-scaled x-amount-fee-liquidity-scaled))\n    (updated-y-amount-scaled (- y-amount-scaled y-amount-fee-liquidity-scaled))\n    (updated-balance-x-post-fee-scaled (+ x-balance-scaled updated-x-amount-scaled))\n    (updated-balance-y-post-fee-scaled (+ y-balance-scaled updated-y-amount-scaled))\n    (updated-d (get-d updated-balance-x-post-fee-scaled updated-balance-y-post-fee-scaled amplification-coefficient convergence-threshold))\n    \n    ;; Scale down for precise token balance updates and transfers\n    (precise-fees-liquidity (scale-down-amounts x-amount-fee-liquidity-scaled y-amount-fee-liquidity-scaled x-token-trait y-token-trait))\n    (x-amount-fees-liquidity (get x-amount precise-fees-liquidity))\n    (y-amount-fees-liquidity (get y-amount precise-fees-liquidity))\n    (amounts-added (scale-down-amounts updated-x-amount-scaled updated-y-amount-scaled x-token-trait y-token-trait))\n    (updated-x-amount (get x-amount amounts-added))\n    (updated-y-amount (get y-amount amounts-added))\n    (updated-pool-balances-post-fee (scale-down-amounts updated-balance-x-post-fee-scaled updated-balance-y-post-fee-scaled x-token-trait y-token-trait))\n    (updated-x-balance-post-fee (get x-amount updated-pool-balances-post-fee))\n    (updated-y-balance-post-fee (get y-amount updated-pool-balances-post-fee))\n    \n    ;; Check that updated-d is greater than d-a and calculate dlp\n    (minimum-d-check (asserts! (> updated-d d-a) ERR_MINIMUM_D_VALUE))\n    (dlp (/ (* total-shares (- updated-d d-a)) d-a))\n    )\n    ;; Assert that pool-status is true and correct token traits are used\n    (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n    (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n    (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n\n    ;; Assert that x-amount + y-amount is greater than 0\n    (asserts! (> (+ x-amount y-amount) u0) ERR_INVALID_AMOUNT)\n    \n    ;; Return number of LP tokens caller would receive\n    (ok dlp)\n    )\n)\n\n;; Get x using fold-x-for-loop\n(define-read-only (get-x (y-amount uint) (y-bal uint) (x-bal uint) (amp uint) (threshold uint))\n    (let (\n    (an (* amp NUM_OF_TOKENS))\n    (updated-y-balance (+ y-bal y-amount))\n    (current-d (get-d x-bal y-bal amp threshold))\n    (c-a current-d)\n    (c-b (/ (* c-a current-d) (* NUM_OF_TOKENS updated-y-balance)))\n    (c-c (/ (* c-b current-d) (* an NUM_OF_TOKENS)))\n    (b (+ updated-y-balance (/ current-d an)))\n    )\n    (get converged (fold fold-x-for-loop index-list {x: current-d, c: c-c, b: b, d: current-d, threshold: threshold, converged: u0}))\n    )\n)\n\n;; Get y using fold-y-for-loop\n(define-read-only (get-y (x-amount uint) (x-bal uint) (y-bal uint) (amp uint) (threshold uint))\n    (let (\n    (an (* amp NUM_OF_TOKENS))\n    (updated-x-balance (+ x-bal x-amount))\n    (current-d (get-d x-bal y-bal amp threshold))\n    (c-a current-d)\n    (c-b (/ (* c-a current-d) (* NUM_OF_TOKENS updated-x-balance)))\n    (c-c (/ (* c-b current-d) (* an NUM_OF_TOKENS)))\n    (b (+ updated-x-balance (/ current-d an)))\n    )\n    (get converged (fold fold-y-for-loop index-list {y: current-d, c: c-c, b: b, d: current-d, threshold: threshold, converged: u0}))\n    )\n)\n\n;; Get d using fold-d-for-loop\n(define-read-only (get-d (x-bal uint) (y-bal uint) (amp uint) (threshold uint))\n    (get converged (fold fold-d-for-loop index-list {x-bal: x-bal, y-bal: y-bal, d: (+ x-bal y-bal), an: (* amp NUM_OF_TOKENS), threshold: threshold, converged: u0}))\n)\n\n;; Set minimum shares required to mint and burn when creating a pool\n(define-public (set-minimum-shares (min-total uint) (min-burnt uint))\n    (let (\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and amounts are greater than 0\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (and (> min-total u0) (> min-burnt u0)) ERR_INVALID_AMOUNT)\n        \n        ;; Assert that min-total is greater than min-burnt\n        (asserts! (> min-total min-burnt) ERR_INVALID_MIN_BURNT_SHARES)\n\n        ;; Update minimum-total-shares and minimum-burnt-shares\n        (var-set minimum-total-shares min-total)\n        (var-set minimum-burnt-shares min-burnt)\n\n        ;; Print function data and return true\n        (print {\n        action: \"set-minimum-shares\",\n        caller: caller,\n        data: {\n            min-total: min-total,\n            min-burnt: min-burnt\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Enable or disable public pool creation\n(define-public (set-public-pool-creation (status bool))\n    (let (\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n\n        ;; Set public-pool-creation to status\n        (var-set public-pool-creation status)\n        \n        ;; Print function data and return true\n        (print {action: \"set-public-pool-creation\", caller: caller, data: {status: status}})\n        (ok true)\n    )\n    )\n)\n\n;; Set pool uri for a pool\n(define-public (set-pool-uri (pool-trait <stableswap-pool-trait>) (uri (string-utf8 256)))\n    (let (\n    ;; Gather all pool data\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and pool is created and valid\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n        (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n        \n        ;; Assert that uri length is greater than 0\n        (asserts! (> (len uri) u0) ERR_INVALID_POOL_URI)\n        \n        ;; Set pool uri for pool\n        (try! (contract-call? pool-trait set-pool-uri uri))\n        \n        ;; Print function data and return true\n        (print {\n        action: \"set-pool-uri\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            uri: uri\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Set pool status for a pool\n(define-public (set-pool-status (pool-trait <stableswap-pool-trait>) (status bool))\n    (let (\n    ;; Gather all pool data\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and pool is created and valid\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n        (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n        \n        ;; Set pool status for pool\n        (try! (contract-call? pool-trait set-pool-status status))\n        \n        ;; Print function data and return true\n        (print {\n        action: \"set-pool-status\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            status: status\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Set fee address for a pool\n(define-public (set-fee-address (pool-trait <stableswap-pool-trait>) (address principal))\n    (let (\n    ;; Gather all pool data\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and pool is created and valid\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n        (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n        \n        ;; Assert that address is standard principal\n        (asserts! (is-standard address) ERR_INVALID_PRINCIPAL)\n        \n        ;; Set fee address for pool\n        (try! (contract-call? pool-trait set-fee-address address))\n        \n        ;; Print function data and return true\n        (print {\n        action: \"set-fee-address\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            address: address\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Set x fees for a pool\n(define-public (set-x-fees (pool-trait <stableswap-pool-trait>) (protocol-fee uint) (provider-fee uint))\n    (let (\n    ;; Gather all pool data\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and pool is created and valid\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n        (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n        \n        ;; Assert protocol-fee and provider-fee is less than maximum BPS\n        (asserts! (< (+ protocol-fee provider-fee) BPS) ERR_INVALID_FEE)\n        \n        ;; Assert protocol-fee and provider-fee is less than maximum BPS\n        (try! (contract-call? pool-trait set-x-fees protocol-fee provider-fee))\n        \n        ;; Print function data and return true\n        (print {\n        action: \"set-x-fees\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            protocol-fee: protocol-fee,\n            provider-fee: provider-fee\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Set y fees for a pool\n(define-public (set-y-fees (pool-trait <stableswap-pool-trait>) (protocol-fee uint) (provider-fee uint))\n    (let (\n    ;; Gather all pool data\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and pool is created and valid\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n        (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n        \n        ;; Assert protocol-fee and provider-fee is less than maximum BPS\n        (asserts! (< (+ protocol-fee provider-fee) BPS) ERR_INVALID_FEE)\n        \n        ;; Set y fees for pool\n        (try! (contract-call? pool-trait set-y-fees protocol-fee provider-fee))\n        \n        ;; Print function data and return true\n        (print {\n        action: \"set-y-fees\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            protocol-fee: protocol-fee,\n            provider-fee: provider-fee\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Set liquidity fee for a pool\n(define-public (set-liquidity-fee (pool-trait <stableswap-pool-trait>) (fee uint))\n    (let (\n    ;; Gather all pool data\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and pool is created and valid\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n        (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n\n        ;; Assert fee is less than maximum BPS\n        (asserts! (< fee BPS) ERR_INVALID_FEE)\n\n        ;; Set liquidity fee for pool\n        (try! (contract-call? pool-trait set-liquidity-fee fee))\n\n        ;; Print function data and return true\n        (print {\n        action: \"set-liquidity-fee\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            fee: fee\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Set amplification coefficient for a pool\n(define-public (set-amplification-coefficient (pool-trait <stableswap-pool-trait>) (coefficient uint))\n    (let (\n    ;; Gather all pool data\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and pool is created and valid\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n        (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n\n        ;; Set amplification coefficient for pool\n        (try! (contract-call? pool-trait set-amplification-coefficient coefficient))\n\n        ;; Print function data and return true\n        (print {\n        action: \"set-amplification-coefficient\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            coefficient: coefficient\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Set convergence threshold for a pool\n(define-public (set-convergence-threshold (pool-trait <stableswap-pool-trait>) (threshold uint))\n    (let (\n    ;; Gather all pool data\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert caller is an admin and pool is created and valid\n        (asserts! (is-some (index-of (var-get admins) caller)) ERR_NOT_AUTHORIZED)\n        (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL)\n        (asserts! (is-eq (get pool-created pool-data) true) ERR_POOL_NOT_CREATED)\n\n        ;; Set convergence threshold for pool\n        (try! (contract-call? pool-trait set-convergence-threshold threshold))\n\n        ;; Print function data and return true\n        (print {\n        action: \"set-convergence-threshold\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            threshold: threshold\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Create a new pool\n(define-public (create-pool \n    (pool-trait <stableswap-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (x-amount uint) (y-amount uint)\n    (burn-amount uint)\n    (x-protocol-fee uint) (x-provider-fee uint)\n    (y-protocol-fee uint) (y-provider-fee uint)\n    (liquidity-fee uint)\n    (amplification-coefficient uint)\n    (convergence-threshold uint)\n    (fee-address principal) (uri (string-utf8 256)) (status bool)\n    )\n    (let (\n    ;; Gather all pool data and pool contract\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-contract (contract-of pool-trait))\n    \n    ;; Get pool ID and create pool symbol and name \n    (new-pool-id (+ (var-get last-pool-id) u1))\n    (symbol (unwrap! (create-symbol x-token-trait y-token-trait) ERR_INVALID_POOL_SYMBOL))\n    (name (concat symbol \"-LP\"))\n    (x-token-contract (contract-of x-token-trait))\n    (y-token-contract (contract-of y-token-trait))\n    \n    ;; Scale up pool balances and calculate total shares\n    (pool-balances-scaled (scale-up-amounts x-amount y-amount x-token-trait y-token-trait))\n    (x-balance-scaled (get x-amount pool-balances-scaled))\n    (y-balance-scaled (get y-amount pool-balances-scaled))\n    (total-shares (+ x-balance-scaled y-balance-scaled))\n    (min-burnt-shares (var-get minimum-burnt-shares))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert that caller is an admin or public-pool-creation is true\n        (asserts! (or (is-some (index-of (var-get admins) caller)) (var-get public-pool-creation)) ERR_NOT_AUTHORIZED)\n        \n        ;; Assert that pool is not created\n        (asserts! (is-eq (get pool-created pool-data) false) ERR_POOL_ALREADY_CREATED)\n\n        ;; Assert that x-token-contract and y-token-contract are not matching\n        (asserts! (not (is-eq x-token-contract y-token-contract)) ERR_MATCHING_TOKEN_CONTRACTS)\n\n        ;; Assert that addresses are standard principals\n        (asserts! (is-standard x-token-contract) ERR_INVALID_PRINCIPAL)\n        (asserts! (is-standard y-token-contract) ERR_INVALID_PRINCIPAL)\n        (asserts! (is-standard fee-address) ERR_INVALID_PRINCIPAL)\n        \n        ;; Assert that x and y amount is greater than 0\n        (asserts! (and (> x-amount u0) (> y-amount u0)) ERR_INVALID_AMOUNT)\n\n        ;; Assert that balances are equal\n        (asserts! (is-eq x-balance-scaled y-balance-scaled) ERR_UNEQUAL_POOL_BALANCES)\n\n        ;; Assert that total shares minted meets minimum total shares required\n        (asserts! (>= total-shares (var-get minimum-total-shares)) ERR_MINIMUM_LP_AMOUNT)\n\n        ;; Assert that burn amount meets minimum shares required to burn\n        (asserts! (>= burn-amount min-burnt-shares) ERR_MINIMUM_BURN_AMOUNT)\n        \n        ;; Assert that total shares is greater than or equal to 0 after subtracting burn amount\n        (asserts! (>= (- total-shares burn-amount) u0) ERR_MINIMUM_LP_AMOUNT)\n\n        ;; Assert that length of pool uri, symbol, and name is greater than 0\n        (asserts! (> (len uri) u0) ERR_INVALID_POOL_URI)\n        (asserts! (> (len symbol) u0) ERR_INVALID_POOL_SYMBOL)\n        (asserts! (> (len name) u0) ERR_INVALID_POOL_NAME)\n\n        ;; Assert that fees are less than maximum BPS\n        (asserts! (< (+ x-protocol-fee x-provider-fee) BPS) ERR_INVALID_FEE)\n        (asserts! (< (+ y-protocol-fee y-provider-fee) BPS) ERR_INVALID_FEE)\n        (asserts! (< liquidity-fee BPS) ERR_INVALID_FEE)\n\n        ;; Create pool and set fees\n        (try! (contract-call? pool-trait create-pool x-token-contract y-token-contract fee-address contract-caller amplification-coefficient convergence-threshold new-pool-id name symbol uri status))\n        (try! (contract-call? pool-trait set-x-fees x-protocol-fee x-provider-fee))\n        (try! (contract-call? pool-trait set-y-fees y-protocol-fee y-provider-fee))\n        (try! (contract-call? pool-trait set-liquidity-fee liquidity-fee))\n        \n        ;; Update ID of last created pool and add pool to pools map\n        (var-set last-pool-id new-pool-id)\n        (map-set pools new-pool-id {id: new-pool-id, name: name, symbol: symbol, pool-contract: pool-contract})\n        \n        ;; Transfer x-amount x tokens and y-amount y tokens from caller to pool-contract\n        (try! (contract-call? x-token-trait transfer x-amount caller pool-contract none))\n        (try! (contract-call? y-token-trait transfer y-amount caller pool-contract none))\n\n        ;; Update pool balances and d value\n        (try! (contract-call? pool-trait update-pool-balances x-amount y-amount total-shares))\n\n        ;; Mint LP tokens to caller \n        (try! (contract-call? pool-trait pool-mint (- total-shares burn-amount) caller))\n        \n        ;; Mint burn amount LP token to pool-contract\n        (try! (contract-call? pool-trait pool-mint burn-amount pool-contract))\n        \n        ;; Print create pool data and return true\n        (print {\n        action: \"create-pool\",\n        caller: caller,\n        data: {\n            pool-id: new-pool-id,\n            pool-name: name,\n            pool-contract: pool-contract,\n            x-token: x-token-contract,\n            y-token: y-token-contract,\n            x-protocol-fee: x-protocol-fee,\n            x-provider-fee: x-provider-fee,\n            y-protocol-fee: y-protocol-fee,\n            y-provider-fee: y-provider-fee,\n            liquidity-fee: liquidity-fee,\n            x-amount: x-amount,\n            y-amount: y-amount,\n            burn-amount: burn-amount,\n            total-shares: total-shares,\n            pool-symbol: symbol,\n            pool-uri: uri,\n            pool-status: status,\n            creation-height: burn-block-height,\n            fee-address: fee-address,\n            amplification-coefficient: amplification-coefficient,\n            convergence-threshold: convergence-threshold\n        }\n        })\n        (ok true)\n    )\n    )\n)\n\n;; Swap x token for y token via a pool\n(define-public (swap-x-for-y\n    (pool-trait <stableswap-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (x-amount uint) (min-dy uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (pool-contract (contract-of pool-trait))\n    (fee-address (get fee-address pool-data))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (protocol-fee (get x-protocol-fee pool-data))\n    (provider-fee (get x-provider-fee pool-data))\n    (convergence-threshold (get convergence-threshold pool-data))\n    (amplification-coefficient (get amplification-coefficient pool-data))\n    \n    ;; Scale up pool balances and swap amounts to perform AMM calculations with get-y\n    (pool-balances-scaled (scale-up-amounts x-balance y-balance x-token-trait y-token-trait))\n    (x-balance-scaled (get x-amount pool-balances-scaled))\n    (y-balance-scaled (get y-amount pool-balances-scaled))\n    (swap-amounts-scaled (scale-up-amounts x-amount u0 x-token-trait y-token-trait))\n    (x-amount-scaled (get x-amount swap-amounts-scaled))\n    (x-amount-fees-protocol-scaled (/ (* x-amount-scaled protocol-fee) BPS))\n    (x-amount-fees-provider-scaled (/ (* x-amount-scaled provider-fee) BPS))\n    (x-amount-fees-total-scaled (+ x-amount-fees-protocol-scaled x-amount-fees-provider-scaled))\n    (dx-scaled (- x-amount-scaled x-amount-fees-total-scaled))\n    (updated-x-balance-scaled (+ x-balance-scaled dx-scaled x-amount-fees-provider-scaled))\n    (updated-y-balance-scaled (get-y dx-scaled x-balance-scaled y-balance-scaled amplification-coefficient convergence-threshold))\n    \n    ;; Scale down to precise amounts for y and dy, as well as x-amount-fees-protocol and x-amount-fees-provider\n    (updated-y-balance (get y-amount (scale-down-amounts u0 updated-y-balance-scaled x-token-trait y-token-trait)))\n    (dy (- y-balance updated-y-balance))\n    (x-amount-fees-protocol (get x-amount (scale-down-amounts x-amount-fees-protocol-scaled u0 x-token-trait y-token-trait)))\n    (x-amount-fees-provider (get x-amount (scale-down-amounts x-amount-fees-provider-scaled u0 x-token-trait y-token-trait)))\n    (x-amount-fees-total (+ x-amount-fees-protocol x-amount-fees-provider))\n    (dx (- x-amount x-amount-fees-total))\n    (updated-dx (+ dx x-amount-fees-provider))\n    (updated-d (get-d updated-x-balance-scaled updated-y-balance-scaled amplification-coefficient convergence-threshold))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert that pool-status is true and correct token traits are used\n        (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n        (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n        (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n\n        ;; Assert that x-amount is greater than 0 and less than x10 of x-balance\n        (asserts! (and (> x-amount u0) (< x-amount (* x-balance MAX_AMOUNT_PER_BALANCE_MULTIPLIER))) ERR_INVALID_AMOUNT)\n        \n        ;; Assert that min-dy is greater than 0 and dy is greater than or equal to min-dy\n        (asserts! (> min-dy u0) ERR_INVALID_AMOUNT)\n        (asserts! (>= dy min-dy) ERR_MINIMUM_Y_AMOUNT)\n\n        ;; Transfer updated-dx x tokens from caller to pool-contract\n        (try! (contract-call? x-token-trait transfer updated-dx caller pool-contract none))\n\n        ;; Transfer dy y tokens from pool-contract to caller\n        (try! (contract-call? pool-trait pool-transfer y-token-trait dy caller))\n\n        ;; Transfer x-amount-fees-protocol x tokens from caller to fee-address\n        (if (> x-amount-fees-protocol u0)\n        (try! (contract-call? x-token-trait transfer x-amount-fees-protocol caller fee-address none))\n        false\n        )\n\n        ;; Update pool balances and d value\n        (try! (contract-call? pool-trait update-pool-balances (+ x-balance updated-dx) updated-y-balance updated-d))\n\n        ;; Print swap data and return number of y tokens the caller received\n        (print {\n        action: \"swap-x-for-y\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: pool-contract,\n            x-token: x-token,\n            y-token: y-token,\n            x-amount: x-amount,\n            x-amount-fees-protocol: x-amount-fees-protocol,\n            x-amount-fees-provider: x-amount-fees-provider,\n            dy: dy,\n            min-dy: min-dy\n        }\n        })\n        (ok dy)\n    )\n    )\n)\n\n;; Swap y token for x token via a pool\n(define-public (swap-y-for-x\n    (pool-trait <stableswap-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (y-amount uint) (min-dx uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (pool-contract (contract-of pool-trait))\n    (fee-address (get fee-address pool-data))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (protocol-fee (get y-protocol-fee pool-data))\n    (provider-fee (get y-provider-fee pool-data))\n    (convergence-threshold (get convergence-threshold pool-data))\n    (amplification-coefficient (get amplification-coefficient pool-data))\n    \n    ;; Scale up pool balances and swap amounts to perform AMM calculations with get-x\n    (pool-balances-scaled (scale-up-amounts x-balance y-balance x-token-trait y-token-trait))\n    (x-balance-scaled (get x-amount pool-balances-scaled))\n    (y-balance-scaled (get y-amount pool-balances-scaled))\n    (swap-amounts-scaled (scale-up-amounts u0 y-amount x-token-trait y-token-trait))\n    (y-amount-scaled (get y-amount swap-amounts-scaled))\n    (y-amount-fees-protocol-scaled (/ (* y-amount-scaled protocol-fee) BPS))\n    (y-amount-fees-provider-scaled (/ (* y-amount-scaled provider-fee) BPS))\n    (y-amount-fees-total-scaled (+ y-amount-fees-protocol-scaled y-amount-fees-provider-scaled))\n    (dy-scaled (- y-amount-scaled y-amount-fees-total-scaled))\n    (updated-y-balance-scaled (+ y-balance-scaled dy-scaled y-amount-fees-provider-scaled))\n    (updated-x-balance-scaled (get-x dy-scaled y-balance-scaled x-balance-scaled amplification-coefficient convergence-threshold))\n    \n    ;; Scale down to precise amounts for x and dx, as well as y-amount-fees-protocol and y-amount-fees-provider\n    (updated-x-balance (get x-amount (scale-down-amounts updated-x-balance-scaled u0 x-token-trait y-token-trait)))\n    (dx (- x-balance updated-x-balance))\n    (y-amount-fees-protocol (get y-amount (scale-down-amounts u0 y-amount-fees-protocol-scaled x-token-trait y-token-trait)))\n    (y-amount-fees-provider (get y-amount (scale-down-amounts u0 y-amount-fees-provider-scaled x-token-trait y-token-trait)))\n    (y-amount-fees-total (+ y-amount-fees-protocol y-amount-fees-provider))\n    (dy (- y-amount y-amount-fees-total))\n    (updated-dy (+ dy y-amount-fees-provider))\n    (updated-d (get-d updated-x-balance-scaled updated-y-balance-scaled amplification-coefficient convergence-threshold))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert that pool-status is true and correct token traits are used\n        (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n        (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n        (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n\n        ;; Assert that y-amount is greater than 0 and less than x10 of y-balance\n        (asserts! (and (> y-amount u0) (< y-amount (* y-balance MAX_AMOUNT_PER_BALANCE_MULTIPLIER))) ERR_INVALID_AMOUNT)\n        \n        ;; Assert that min-dx is greater than 0 and dx is greater than or equal to min-dx\n        (asserts! (> min-dx u0) ERR_INVALID_AMOUNT)\n        (asserts! (>= dx min-dx) ERR_MINIMUM_X_AMOUNT)\n\n        ;; Transfer updated-dy y tokens from caller to pool-contract\n        (try! (contract-call? y-token-trait transfer updated-dy caller pool-contract none))\n\n        ;; Transfer dx x tokens from pool-contract to caller\n        (try! (contract-call? pool-trait pool-transfer x-token-trait dx caller))\n\n        ;; Transfer y-amount-fees-protocol y tokens from caller to fee-address\n        (if (> y-amount-fees-protocol u0)\n        (try! (contract-call? y-token-trait transfer y-amount-fees-protocol caller fee-address none))\n        false\n        )\n\n        ;; Update pool balances and d value\n        (try! (contract-call? pool-trait update-pool-balances updated-x-balance (+ y-balance updated-dy) updated-d))\n\n        ;; Print swap data and return number of x tokens the caller received\n        (print {\n        action: \"swap-y-for-x\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: pool-contract,\n            x-token: x-token,\n            y-token: y-token,\n            y-amount: y-amount,\n            y-amount-fees-protocol: y-amount-fees-protocol,\n            y-amount-fees-provider: y-amount-fees-provider,\n            dx: dx,\n            min-dx: min-dx\n        }\n        })\n        (ok dx)\n    )\n    )\n)\n\n;; Add liquidity to a pool\n(define-public (add-liquidity\n    (pool-trait <stableswap-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (x-amount uint) (y-amount uint) (min-dlp uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (pool-contract (contract-of pool-trait))\n    (fee-address (get fee-address pool-data))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (total-shares (get total-shares pool-data))\n    (liquidity-fee (get liquidity-fee pool-data))\n    (convergence-threshold (get convergence-threshold pool-data))\n    (amplification-coefficient (get amplification-coefficient pool-data))\n    (updated-x-balance (+ x-balance x-amount))\n    (updated-y-balance (+ y-balance y-amount))\n\n    ;; Scale up for AMM calculations depending on decimal places assigned to tokens\n    (amounts-added-scaled (scale-up-amounts x-amount y-amount x-token-trait y-token-trait))\n    (x-amount-scaled (get x-amount amounts-added-scaled))\n    (y-amount-scaled (get y-amount amounts-added-scaled))\n    (pool-balances-scaled (scale-up-amounts x-balance y-balance x-token-trait y-token-trait))\n    (x-balance-scaled (get x-amount pool-balances-scaled))\n    (y-balance-scaled (get y-amount pool-balances-scaled))\n    (updated-pool-balances-scaled (scale-up-amounts updated-x-balance updated-y-balance x-token-trait y-token-trait))\n    (updated-x-balance-scaled (get x-amount updated-pool-balances-scaled))\n    (updated-y-balance-scaled (get y-amount updated-pool-balances-scaled))\n    \n    ;; Calculate ideal pool balance\n    (d-a (get-d x-balance-scaled y-balance-scaled amplification-coefficient convergence-threshold))\n    (d-b (get-d updated-x-balance-scaled updated-y-balance-scaled amplification-coefficient convergence-threshold))\n    (ideal-x-balance-scaled (/ (* d-b x-balance-scaled) d-a))\n    (ideal-y-balance-scaled (/ (* d-b y-balance-scaled) d-a))\n    (x-difference (if (> ideal-x-balance-scaled updated-x-balance-scaled) (- ideal-x-balance-scaled updated-x-balance-scaled) (- updated-x-balance-scaled ideal-x-balance-scaled)))\n    (y-difference (if (> ideal-y-balance-scaled updated-y-balance-scaled) (- ideal-y-balance-scaled updated-y-balance-scaled) (- updated-y-balance-scaled ideal-y-balance-scaled)))\n    \n    ;; Calculate fees to apply if adding imbalanced liquidity\n    (ideal-x-amount-fee-liquidity-scaled (/ (* x-difference liquidity-fee) BPS))\n    (ideal-y-amount-fee-liquidity-scaled (/ (* y-difference liquidity-fee) BPS))\n    (x-amount-fee-liquidity-scaled (if (> x-amount-scaled ideal-x-amount-fee-liquidity-scaled) ideal-x-amount-fee-liquidity-scaled x-amount-scaled))\n    (y-amount-fee-liquidity-scaled (if (> y-amount-scaled ideal-y-amount-fee-liquidity-scaled) ideal-y-amount-fee-liquidity-scaled y-amount-scaled))\n    (updated-x-amount-scaled (- x-amount-scaled x-amount-fee-liquidity-scaled))\n    (updated-y-amount-scaled (- y-amount-scaled y-amount-fee-liquidity-scaled))\n    (updated-balance-x-post-fee-scaled (+ x-balance-scaled updated-x-amount-scaled))\n    (updated-balance-y-post-fee-scaled (+ y-balance-scaled updated-y-amount-scaled))\n    (updated-d (get-d updated-balance-x-post-fee-scaled updated-balance-y-post-fee-scaled amplification-coefficient convergence-threshold))\n    \n    ;; Scale down for precise token balance updates and transfers\n    (precise-fees-liquidity (scale-down-amounts x-amount-fee-liquidity-scaled y-amount-fee-liquidity-scaled x-token-trait y-token-trait))\n    (x-amount-fees-liquidity (get x-amount precise-fees-liquidity))\n    (y-amount-fees-liquidity (get y-amount precise-fees-liquidity))\n    (amounts-added (scale-down-amounts updated-x-amount-scaled updated-y-amount-scaled x-token-trait y-token-trait))\n    (updated-x-amount (get x-amount amounts-added))\n    (updated-y-amount (get y-amount amounts-added))\n    (updated-pool-balances-post-fee (scale-down-amounts updated-balance-x-post-fee-scaled updated-balance-y-post-fee-scaled x-token-trait y-token-trait))\n    (updated-x-balance-post-fee (get x-amount updated-pool-balances-post-fee))\n    (updated-y-balance-post-fee (get y-amount updated-pool-balances-post-fee))\n    \n    ;; Check that updated-d is greater than d-a and calculate dlp\n    (minimum-d-check (asserts! (> updated-d d-a) ERR_MINIMUM_D_VALUE))\n    (dlp (/ (* total-shares (- updated-d d-a)) d-a))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert that pool-status is true and correct token traits are used\n        (asserts! (is-eq (get pool-status pool-data) true) ERR_POOL_DISABLED)\n        (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n        (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n\n        ;; Assert that x-amount + y-amount is greater than 0\n        (asserts! (> (+ x-amount y-amount) u0) ERR_INVALID_AMOUNT)\n\n        ;; Assert that min-dlp is greater than 0 and dlp is greater than or equal to min-dlp\n        (asserts! (> min-dlp u0) ERR_INVALID_AMOUNT)\n        (asserts! (>= dlp min-dlp) ERR_MINIMUM_LP_AMOUNT)\n\n        ;; Transfer updated-x-amount x tokens from caller to pool-contract\n        (if (> updated-x-amount u0)\n        (try! (contract-call? x-token-trait transfer updated-x-amount caller pool-contract none))\n        false\n        )\n\n        ;; Transfer updated-y-amount y tokens from caller to pool-contract\n        (if (> updated-y-amount u0)\n        (try! (contract-call? y-token-trait transfer updated-y-amount caller pool-contract none))\n        false\n        )\n\n        ;; Transfer x-amount-fees-liquidity x tokens from caller to fee-address\n        (if (> x-amount-fees-liquidity u0)\n        (try! (contract-call? x-token-trait transfer x-amount-fees-liquidity caller fee-address none))\n        false\n        )\n\n        ;; Transfer y-amount-fees-liquidity y tokens from caller to fee-address\n        (if (> y-amount-fees-liquidity u0)\n        (try! (contract-call? y-token-trait transfer y-amount-fees-liquidity caller fee-address none))\n        false\n        )\n\n        ;; Update pool balances and d value\n        (try! (contract-call? pool-trait update-pool-balances updated-x-balance-post-fee updated-y-balance-post-fee updated-d))\n        \n        ;; Mint LP tokens to caller\n        (try! (contract-call? pool-trait pool-mint dlp caller))\n\n        ;; Print add liquidity data and return number of LP tokens caller received\n        (print {\n        action: \"add-liquidity\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: pool-contract,\n            x-token: x-token,\n            y-token: y-token,\n            x-amount: updated-x-amount,\n            y-amount: updated-y-amount,\n            x-amount-fees-liquidity: x-amount-fees-liquidity,\n            y-amount-fees-liquidity: y-amount-fees-liquidity,\n            dlp: dlp,\n            min-dlp: min-dlp\n        }\n        })\n        (ok dlp)\n    )\n    )\n)\n\n;; Withdraw liquidity from a pool\n(define-public (withdraw-liquidity\n    (pool-trait <stableswap-pool-trait>)\n    (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>)\n    (amount uint) (min-x-amount uint) (min-y-amount uint)\n    )\n    (let (\n    ;; Gather all pool data and check if pool is valid\n    (pool-data (unwrap! (contract-call? pool-trait get-pool) ERR_NO_POOL_DATA))\n    (pool-validity-check (asserts! (is-valid-pool (get pool-id pool-data) (contract-of pool-trait)) ERR_INVALID_POOL))\n    (x-token (get x-token pool-data))\n    (y-token (get y-token pool-data))\n    (x-balance (get x-balance pool-data))\n    (y-balance (get y-balance pool-data))\n    (total-shares (get total-shares pool-data))\n    (convergence-threshold (get convergence-threshold pool-data))\n    (amplification-coefficient (get amplification-coefficient pool-data))\n    \n    ;; Calculate x-amount and y-amount to transfer and updated balances\n    (x-amount (/ (* amount x-balance) total-shares))\n    (y-amount (/ (* amount y-balance) total-shares))\n    (updated-x-balance (- x-balance x-amount))\n    (updated-y-balance (- y-balance y-amount))\n\n    ;; Scale up balances and calculate updated-d\n    (updated-pool-balances-scaled (scale-up-amounts updated-x-balance updated-y-balance x-token-trait y-token-trait))\n    (updated-x-balance-scaled (get x-amount updated-pool-balances-scaled))\n    (updated-y-balance-scaled (get y-amount updated-pool-balances-scaled))\n    (updated-d (get-d updated-x-balance-scaled updated-y-balance-scaled amplification-coefficient convergence-threshold))\n    (caller tx-sender)\n    )\n    (begin\n        ;; Assert that correct token traits are used\n        (asserts! (is-eq (contract-of x-token-trait) x-token) ERR_INVALID_X_TOKEN)\n        (asserts! (is-eq (contract-of y-token-trait) y-token) ERR_INVALID_Y_TOKEN)\n\n        ;; Assert that amount is greater than 0\n        (asserts! (> amount u0) ERR_INVALID_AMOUNT)\n\n        ;; Assert that x-amount + y-amount is greater than 0\n        (asserts! (> (+ x-amount y-amount) u0) ERR_INVALID_AMOUNT)\n\n        ;; Assert that x-amount is greater than or equal to min-x-amount\n        (asserts! (>= x-amount min-x-amount) ERR_MINIMUM_X_AMOUNT)\n\n        ;; Assert that y-amount is greater than or equal to min-y-amount\n        (asserts! (>= y-amount min-y-amount) ERR_MINIMUM_Y_AMOUNT)\n\n        ;; Transfer x-amount x tokens from pool-contract to caller\n        (if (> x-amount u0)\n        (try! (contract-call? pool-trait pool-transfer x-token-trait x-amount caller))\n        false\n        )\n        \n        ;; Transfer y-amount y tokens from pool-contract to caller\n        (if (> y-amount u0)\n        (try! (contract-call? pool-trait pool-transfer y-token-trait y-amount caller))\n        false\n        )\n\n        ;; Update pool balances and d value\n        (try! (contract-call? pool-trait update-pool-balances updated-x-balance updated-y-balance updated-d))\n        \n        ;; Burn LP tokens from caller\n        (try! (contract-call? pool-trait pool-burn amount caller))\n        \n        ;; Print withdraw liquidity data and return number of x and y tokens caller received\n        (print {\n        action: \"withdraw-liquidity\",\n        caller: caller,\n        data: {\n            pool-id: (get pool-id pool-data),\n            pool-name: (get pool-name pool-data),\n            pool-contract: (contract-of pool-trait),\n            x-token: x-token,\n            y-token: y-token,\n            amount: amount,\n            x-amount: x-amount,\n            y-amount: y-amount,\n            min-x-amount: min-x-amount,\n            min-y-amount: min-y-amount\n        }\n        })\n        (ok {x-amount: x-amount, y-amount: y-amount})\n    )\n    )\n)\n\n;; Add an admin to the admins list\n(define-public (add-admin (admin principal))\n    (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n    )\n    ;; Assert caller is an existing admin and new admin is not in admins-list\n    (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n    (asserts! (is-none (index-of admins-list admin)) ERR_ALREADY_ADMIN)\n    \n    ;; Add admin to list with max length of 5\n    (var-set admins (unwrap! (as-max-len? (append admins-list admin) u5) ERR_ADMIN_LIMIT_REACHED))\n    \n    ;; Print add admin data and return true\n    (print {action: \"add-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n    )\n)\n\n;; Remove an admin from the admins list\n(define-public (remove-admin (admin principal))\n    (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n    )\n    ;; Assert caller is an existing admin and admin to remove is in admins-list\n    (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n    (asserts! (is-some (index-of admins-list admin)) ERR_ADMIN_NOT_IN_LIST)\n\n    ;; Assert contract deployer cannot be removed\n    (asserts! (not (is-eq admin CONTRACT_DEPLOYER)) ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER)\n\n    ;; Set admin-helper to admin to remove and filter admins-list to remove admin\n    (var-set admin-helper admin)\n    (var-set admins (filter admin-not-removable admins-list))\n\n    ;; Print remove admin data and return true\n    (print {action: \"remove-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n    )\n)\n\n;; Set pool uri for multiple pools\n(define-public (set-pool-uri-multi\n    (pool-traits (list 120 <stableswap-pool-trait>))\n    (uris (list 120 (string-utf8 256)))\n    )\n    (ok (map set-pool-uri pool-traits uris))\n)\n\n;; Set pool status for multiple pools\n(define-public (set-pool-status-multi\n    (pool-traits (list 120 <stableswap-pool-trait>))\n    (statuses (list 120 bool))\n    )\n    (ok (map set-pool-status pool-traits statuses))\n)\n\n;; Set fee address for multiple pools\n(define-public (set-fee-address-multi\n    (pool-traits (list 120 <stableswap-pool-trait>))\n    (addresses (list 120 principal))\n    )\n    (ok (map set-fee-address pool-traits addresses))\n)\n\n;; Set x fees for multiple pools\n(define-public (set-x-fees-multi\n    (pool-traits (list 120 <stableswap-pool-trait>))\n    (protocol-fees (list 120 uint)) (provider-fees (list 120 uint))\n    )\n    (ok (map set-x-fees pool-traits protocol-fees provider-fees))\n)\n\n;; Set y fees for multiple pools\n(define-public (set-y-fees-multi\n    (pool-traits (list 120 <stableswap-pool-trait>))\n    (protocol-fees (list 120 uint)) (provider-fees (list 120 uint))\n    )\n    (ok (map set-y-fees pool-traits protocol-fees provider-fees))\n)\n\n;; Set liquidity fee for multiple pools\n(define-public (set-liquidity-fee-multi\n    (pool-traits (list 120 <stableswap-pool-trait>))\n    (fees (list 120 uint))\n    )\n    (ok (map set-liquidity-fee pool-traits fees))\n)\n\n;; Set amplification coefficient for multiple pools\n(define-public (set-amplification-coefficient-multi\n    (pool-traits (list 120 <stableswap-pool-trait>))\n    (coefficients (list 120 uint))\n    )\n    (ok (map set-amplification-coefficient pool-traits coefficients))\n)\n\n;; Set convergence threshold for multiple pools\n(define-public (set-convergence-threshold-multi\n    (pool-traits (list 120 <stableswap-pool-trait>))\n    (thresholds (list 120 uint))\n    )\n    (ok (map set-convergence-threshold pool-traits thresholds))\n)\n\n;; Helper function for removing an admin\n(define-private (admin-not-removable (admin principal))\n    (not (is-eq admin (var-get admin-helper)))\n)\n\n;; Create pool symbol using x token and y token symbols\n(define-private (create-symbol (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>))\n    (let (\n    ;; Get x token and y token symbols\n    (x-symbol (unwrap-panic (contract-call? x-token-trait get-symbol)))\n    (y-symbol (unwrap-panic (contract-call? y-token-trait get-symbol)))\n    \n    ;; Truncate symbols if length exceeds 14\n    (x-truncated \n        (if (> (len x-symbol) u14)\n        (unwrap-panic (slice? x-symbol u0 u14))\n        x-symbol\n        )\n    )\n    (y-truncated\n        (if (> (len y-symbol) u14)\n        (unwrap-panic (slice? y-symbol u0 u14))\n        y-symbol\n        )\n    )\n    )\n    ;; Return pool symbol with max length of 29\n    (as-max-len? (concat x-truncated (concat \"-\" y-truncated)) u29)\n    )\n)\n\n;; Check if a pool is valid\n(define-private (is-valid-pool (id uint) (contract principal))\n    (let (\n    (pool-data (unwrap! (map-get? pools id) false))\n    )\n    (is-eq contract (get pool-contract pool-data))\n    )\n)\n\n;; Helper for get x\n(define-private (fold-x-for-loop (n uint) (static-data {x: uint, c: uint, b: uint, d: uint, threshold: uint, converged: uint})) \n    (let (\n    (current-x (get x static-data))\n    (current-c (get c static-data))\n    (current-b (get b static-data))\n    (current-d (get d static-data))\n    (current-threshold (get threshold static-data))\n    (current-converged (get converged static-data))\n    (x-numerator (+ (* current-x current-x) current-c))\n    (x-denominator (- (+ (* NUM_OF_TOKENS current-x) current-b) current-d))\n    (new-x (/ x-numerator x-denominator))\n    )\n    (if (is-eq current-converged u0)\n        (if (> new-x  current-x)\n        (if (<= (- new-x current-x) current-threshold)\n            {x: new-x, c: current-c, b: current-b, d: current-d, threshold: current-threshold, converged: new-x}\n            {x: new-x, c: current-c, b: current-b, d: current-d, threshold: current-threshold, converged: u0}\n        )\n        (if (<= (- current-x new-x) current-threshold)\n            {x: new-x, c: current-c, b: current-b, d: current-d, threshold: current-threshold, converged: new-x}\n            {x: new-x, c: current-c, b: current-b, d: current-d, threshold: current-threshold, converged: u0}\n        )\n        )\n        static-data\n    )\n    )\n)\n\n;; Helper for get y\n(define-private (fold-y-for-loop (n uint) (static-data {y: uint, c: uint, b: uint, d: uint, threshold: uint, converged: uint})) \n    (let (\n    (current-y (get y static-data))\n    (current-c (get c static-data))\n    (current-b (get b static-data))\n    (current-d (get d static-data))\n    (current-threshold (get threshold static-data))\n    (current-converged (get converged static-data))\n    (y-numerator (+ (* current-y current-y) current-c))\n    (y-denominator (- (+ (* NUM_OF_TOKENS current-y) current-b) current-d))\n    (new-y (/ y-numerator y-denominator))\n    )\n    (if (is-eq current-converged u0)\n        (if (> new-y current-y)\n        (if (<= (- new-y current-y) current-threshold)\n            {y: new-y, c: current-c, b: current-b, d: current-d, threshold: current-threshold, converged: new-y}\n            {y: new-y, c: current-c, b: current-b, d: current-d, threshold: current-threshold, converged: u0}\n        )\n        (if (<= (- current-y new-y) current-threshold)\n            {y: new-y, c: current-c, b: current-b, d: current-d, threshold: current-threshold, converged: new-y}\n            {y: new-y, c: current-c, b: current-b, d: current-d, threshold: current-threshold, converged: u0}\n        )\n        )\n        static-data\n    )\n    )\n)\n\n;; Helper for get-d\n(define-private (fold-d-for-loop (n uint) (static-data {x-bal: uint, y-bal: uint, d: uint, an: uint, threshold: uint, converged: uint})) \n    (let (\n    ;; Gather all data from static-data\n    (current-x-balance (get x-bal static-data))\n    (current-y-balance (get y-bal static-data))\n    (current-s (+ current-x-balance current-y-balance))\n    (current-d-partial (get d static-data))\n    (current-d (get d static-data))\n    (current-an (get an static-data))\n    (current-threshold (get threshold static-data))\n    (current-converged (get converged static-data))\n\n    ;; Start logic for calculating new d\n    ;; Calculate new partial d with respect to x\n    (new-d-partial-x (/ (* current-d current-d-partial) (* NUM_OF_TOKENS current-x-balance)))\n    \n    ;; Calculate new partial d with respect to new x and y\n    (new-d-partial (/ (* current-d new-d-partial-x) (* NUM_OF_TOKENS current-y-balance)))\n    (new-numerator (* (+ (* current-an current-s) (* NUM_OF_TOKENS new-d-partial)) current-d))\n    (new-denominator (+ (* (- current-an u1) current-d) (* (+ NUM_OF_TOKENS u1) new-d-partial)))\n    (new-d (/ new-numerator new-denominator))         \n    )\n    ;; Check if converged value or new d was already found\n    (if (is-eq current-converged u0)\n        (if (> new-d current-d)\n        (if (<= (- new-d current-d) current-threshold)\n            {x-bal: current-x-balance, y-bal: current-y-balance, d: new-d, an: current-an, threshold: current-threshold, converged: new-d}\n            {x-bal: current-x-balance, y-bal: current-y-balance, d: new-d, an: current-an, threshold: current-threshold, converged: u0}\n        )\n        (if (<= (- current-d new-d) current-threshold)\n            {x-bal: current-x-balance, y-bal: current-y-balance, d: new-d, an: current-an, threshold: current-threshold, converged: new-d}\n            {x-bal: current-x-balance, y-bal: current-y-balance, d: new-d, an: current-an, threshold: current-threshold, converged: u0}\n        )\n        )\n        static-data\n    )\n    )\n)\n\n;; Scale up token amounts to the same level of precision before performing AMM calculations\n(define-private (scale-up-amounts (x-amount uint) (y-amount uint) (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>))\n    (let (\n    ;; Get decimals for x and y tokens\n    (x-decimals (unwrap-panic (contract-call? x-token-trait get-decimals)))\n    (y-decimals (unwrap-panic (contract-call? y-token-trait get-decimals)))\n\n    ;; Scale x amount and y amounts\n    (x-amount-scaled\n        (if (is-eq x-decimals y-decimals)\n        x-amount\n        (if (> x-decimals y-decimals)\n            x-amount\n            (* x-amount (pow u10 (- y-decimals x-decimals)))\n        )\n        )\n    )\n    (y-amount-scaled\n        (if (is-eq x-decimals y-decimals)\n        y-amount\n        (if (> y-decimals x-decimals)\n            y-amount\n            (* y-amount (pow u10 (- x-decimals y-decimals)))\n        )\n        )\n    )\n    )\n    ;; Return scaled x and y amounts\n    {x-amount: x-amount-scaled, y-amount: y-amount-scaled}\n    )\n)\n\n;; Scale down token amounts to their respective levels of precision before performing any transfers\n(define-private (scale-down-amounts (x-amount uint) (y-amount uint) (x-token-trait <sip-010-trait>) (y-token-trait <sip-010-trait>))\n    (let (\n    ;; Get decimals for x and y tokens\n    (x-decimals (unwrap-panic (contract-call? x-token-trait get-decimals)))\n    (y-decimals (unwrap-panic (contract-call? y-token-trait get-decimals)))\n    \n    ;; Scale x and y amounts\n    (x-amount-scaled\n        (if (is-eq x-decimals y-decimals)\n        x-amount\n        (if (> x-decimals y-decimals)\n            x-amount\n            (/ x-amount (pow u10 (- y-decimals x-decimals)))\n        )\n        )\n    )\n    (y-amount-scaled\n        (if (is-eq x-decimals y-decimals)\n        y-amount\n        (if (> y-decimals x-decimals)\n            y-amount\n            (/ y-amount (pow u10 (- x-decimals y-decimals)))\n        )\n        )\n    )\n    )\n    ;; Return scaled x and y amounts\n    {x-amount: x-amount-scaled, y-amount: y-amount-scaled}\n    )\n)",
    "analysis": {
      "summary": "This contract implements a stableswap pool for the Stacks blockchain, enabling liquidity provision, swaps, and pool management with advanced features like dynamic fees and amplification coefficients.",
      "explanation": "The contract starts by importing necessary traits for stableswap pools and SIP-010 fungible tokens <L5-6>. It defines a comprehensive set of error constants <L8-34> for handling various error states throughout the contract operations. Key constants and data variables are set up to manage pool parameters, admin lists, and pool records <L36-73>. The contract provides a suite of read-only functions <L75-108> to access its state, including admin lists, pool details, and configuration parameters. The core functionality revolves around liquidity management <L643-1095>, swapping mechanisms <L772-960>, and admin management <L1185-1225>, alongside utilities for setting pool parameters <L320-1289>. Each function is meticulously designed to ensure proper validations, error handling, and state updates, adhering to the contract's security and functionality requirements. Notably, the contract employs advanced mathematical models and algorithms <L285-1427> to facilitate efficient and stable token swaps within pools.",
      "tags": ["DeFi", "DEX", "stableswap", "liquidity"]
    }
  },
  {
    "rank": 47,
    "contract": "SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.stableswap-usda-aeusdc-v-1-4",
    "calls": 720,
    "source": ";; Bitflow Stableswap Core Contract - v1.4\n;; This contract handles the core logic of the Stableswap protocol.\n\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;; Cons, Vars, & Maps ;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(use-trait sip-010-trait .sip-010-trait-ft-standard.sip-010-trait)\n(use-trait lp-trait .lp-trait.lp-trait)\n\n;;;;;;;;;;;;;;;\n;; Constants ;;\n;;;;;;;;;;;;;;;\n\n;; This contract address\n(define-constant this-contract (as-contract tx-sender))\n\n;; Deployment height\n(define-constant deployment-height burn-block-height)\n\n;; Cycle length in blocks (1 day = 144 blocks)\n(define-constant cycle-length u144)\n\n;; Index loop for using Newton-Raphson method to converge square root that goes up to u384\n(define-constant index-list (list u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13 u14 u15 u16 u17 u18 u19 u20 u21 u22 u23 u24 u25 u26 u27 u28 u29 u30 u31 u32 u33 u34 u35 u36 u37 u38 u39 u40 u41 u42 u43 u44 u45 u46 u47 u48 u49 u50 u51 u52 u53 u54 u55 u56 u57 u58 u59 u60 u61 u62 u63 u64 u65 u66 u67 u68 u69 u70 u71 u72 u73 u74 u75 u76 u77 u78 u79 u80 u81 u82 u83 u84 u85 u86 u87 u88 u89 u90 u91 u92 u93 u94 u95 u96 u97 u98 u99 u100 u101 u102 u103 u104 u105 u106 u107 u108 u109 u110 u111 u112 u113 u114 u115 u116 u117 u118 u119 u120 u121 u122 u123 u124 u125 u126 u127 u128 u129 u130 u131 u132 u133 u134 u135 u136 u137 u138 u139 u140 u141 u142 u143 u144 u145 u146 u147 u148 u149 u150 u151 u152 u153 u154 u155 u156 u157 u158 u159 u160 u161 u162 u163 u164 u165 u166 u167 u168 u169 u170 u171 u172 u173 u174 u175 u176 u177 u178 u179 u180 u181 u182 u183 u184 u185 u186 u187 u188 u189 u190 u191 u192 u193 u194 u195 u196 u197 u198 u199 u200 u201 u202 u203 u204 u205 u206 u207 u208 u209 u210 u211 u212 u213 u214 u215 u216 u217 u218 u219 u220 u221 u222 u223 u224 u225 u226 u227 u228 u229 u230 u231 u232 u233 u234 u235 u236 u237 u238 u239 u240 u241 u242 u243 u244 u245 u246 u247 u248 u249 u250 u251 u252 u253 u254 u255 u256 u257 u258 u259 u260 u261 u262 u263 u264 u265 u266 u267 u268 u269 u270 u271 u272 u273 u274 u275 u276 u277 u278 u279 u280 u281 u282 u283 u284 u285 u286 u287 u288 u289 u290 u291 u292 u293 u294 u295 u296 u297 u298 u299 u300 u301 u302 u303 u304 u305 u306 u307 u308 u309 u310 u311 u312 u313 u314 u315 u316 u317 u318 u319 u320 u321 u322 u323 u324 u325 u326 u327 u328 u329 u330 u331 u332 u333 u334 u335 u336 u337 u338 u339 u340 u341 u342 u343 u344 u345 u346 u347 u348 u349 u350 u351 u352 u353 u354 u355 u356 u357 u358 u359 u360 u361 u362 u363 u364 u365 u366 u367 u368 u369 u370 u371 u372 u373 u374 u375 u376 u377 u378 u379 u380 u381 u382 u383 u384))\n\n;; Number of tokens per pair\n(define-constant number-of-tokens u2)\n\n;; Contract deployer\n(define-constant contract-deployer tx-sender)\n\n;; Protocol Address\n(define-constant protocol-address 'SP31C60QVZKZ9CMMZX73TQ3F3ZZNS89YX2DCCFT8P)\n\n;; Contract for Stableswap Staking and Rewards\n(define-data-var staking-and-rewards-contract principal tx-sender)\n\n\n;;;;;;;;;;;;\n;; Errors ;;\n;;;;;;;;;;;;\n\n\n;;;;;;;;;;;;;;;\n;; Variables ;;\n;;;;;;;;;;;;;;;\n\n;; Admin Governance List\n(define-data-var admins (list 5 principal) (list tx-sender))\n\n;; Swap Fees (5 total bps initialized, 3 bps to LPs, 2 bps to protocol)\n(define-data-var swap-fees {lps: uint, protocol: uint} {lps: u3, protocol: u2})\n\n;; Liquidity Fees (3 bps initialized, all to protocol)\n(define-data-var liquidity-fees uint u3)\n\n;; Helper var to remove admin\n(define-data-var helper-principal principal tx-sender)\n\n;; Convergence Threshold\n(define-data-var convergence-threshold uint u2)\n\n\n;;;;;;;;;;\n;; Maps ;;\n;;;;;;;;;;\n\n(define-map PairsDataMap {x-token: principal, y-token: principal, lp-token: principal} {\n    approval: bool,\n    total-shares: uint,\n    x-decimals: uint,\n    y-decimals: uint,\n    balance-x: uint,\n    balance-y: uint,\n    d: uint,\n    amplification-coefficient: uint,\n})\n\n(define-map CycleDataMap {x-token: principal, y-token: principal, lp-token: principal, cycle-num: uint} {\n    cycle-fee-balance-x: uint,\n    cycle-fee-balance-y: uint,\n})\n\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Read-Only Functions ;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Get pair data\n(define-read-only (get-pair-data (x-token <sip-010-trait>) (y-token <sip-010-trait>) (lp-token <sip-010-trait>)) \n    (map-get? PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)})\n)\n\n;; Get cycle data\n(define-read-only (get-cycle-data (x-token principal) (y-token principal) (lp-token principal) (cycle-num uint)) \n    (map-get? CycleDataMap {x-token: x-token, y-token: y-token, lp-token: lp-token, cycle-num: cycle-num})\n)\n\n;; Get current cycle\n(define-read-only (get-current-cycle) \n    (/ (- burn-block-height deployment-height) cycle-length)\n)\n\n;; Get cycle from height\n(define-read-only (get-cycle-from-height (height uint)) \n    (/ (- height deployment-height) cycle-length)\n)\n\n;; Get starting height from cycle\n(define-read-only (get-starting-height-from-cycle (cycle uint)) \n    (+ deployment-height (* cycle cycle-length))\n)\n\n;; Get deployment height\n(define-read-only (get-deployment-height) \n    deployment-height\n)\n\n;; Get up to last 120 cycle rewards -> nice to have\n;; (define-read-only (get-cycle-rewards) body)\n\n;; Get DX\n(define-read-only (get-dx (y-token <sip-010-trait>) (x-token <sip-010-trait>) (lp-token <lp-trait>) (y-amount uint))\n    (let \n        (\n            (pair-data (unwrap! (map-get? PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-balance-x (get balance-x pair-data))\n            (current-balance-y (get balance-y pair-data))\n            (x-decimals (get x-decimals pair-data))\n            (y-decimals (get y-decimals pair-data))\n            (swap-fee-lps (get lps (var-get swap-fees)))\n            (swap-fee-protocol (get protocol (var-get swap-fees)))\n            (total-swap-fee (+ swap-fee-lps swap-fee-protocol))\n            (current-amplification-coefficient (get amplification-coefficient pair-data))\n\n            ;; Scale up balances to perform AMM calculations with get-x\n            (scaled-up-balances (get-scaled-up-token-amounts current-balance-x current-balance-y x-decimals y-decimals))\n            (current-balance-x-scaled (get scaled-x scaled-up-balances))\n            (current-balance-y-scaled (get scaled-y scaled-up-balances))\n            (scaled-up-swap-amount (get-scaled-up-token-amounts u0 y-amount x-decimals y-decimals))\n            (y-amount-scaled (get scaled-y scaled-up-swap-amount))\n            (y-amount-fees-lps-scaled (/ (* y-amount-scaled swap-fee-lps) u10000))\n            (y-amount-fees-protocol-scaled (/ (* y-amount-scaled swap-fee-protocol) u10000))\n            (y-amount-total-fees-scaled (/ (* y-amount total-swap-fee) u10000))\n            (updated-y-amount-scaled (- y-amount-scaled y-amount-total-fees-scaled))\n            (updated-y-balance-scaled (+ current-balance-y-scaled updated-y-amount-scaled))\n            (new-x-scaled (get-x current-balance-y-scaled current-balance-x-scaled updated-y-amount-scaled (* current-amplification-coefficient number-of-tokens)))\n\n            ;; Scale down to precise amounts for x and dx, as well as y-amount-fee-lps, and y-amount-fee-protocol\n            (new-x (get scaled-x (get-scaled-down-token-amounts new-x-scaled u0 x-decimals y-decimals)))\n            (dx (- current-balance-x new-x))\n            (y-amount-fee-lps (get scaled-y (get-scaled-down-token-amounts u0 y-amount-fees-lps-scaled x-decimals y-decimals)))\n            (y-amount-fee-protocol (get scaled-y (get-scaled-down-token-amounts u0 y-amount-fees-protocol-scaled x-decimals y-decimals)))\n        )\n        (ok dx)\n    )\n)\n\n;; Get X\n;; Maybe move into get-dx?\n(define-read-only (get-x (y-bal uint) (x-bal uint) (y-amount uint) (ann uint))\n    (let \n        (\n            (y-bal-new (+ y-bal y-amount))\n            (current-D (get-D x-bal y-bal ann))\n            (c0 current-D)\n            (c1 (/ (* c0 current-D) (* number-of-tokens y-bal-new)))\n            (c2 (/ (* c1 current-D) (* ann number-of-tokens)))\n            (b (+ y-bal-new (/ current-D ann)))\n        )\n        (get converged (fold x-for-loop index-list {x: current-D, c: c2, b: b, D: current-D, converged: u0}))\n    )\n)\n\n;; Get X Helper\n(define-private (x-for-loop (n uint) (x-info {x: uint, c: uint, b: uint, D: uint, converged: uint})) \n    (let\n        (\n            (current-x (get x x-info))\n            (current-c (get c x-info))\n            (current-b (get b x-info))\n            (current-D (get D x-info))\n            (current-converged (get converged x-info))\n            (x-numerator (+ (* current-x current-x) current-c))\n            (x-denominator (- (+ (* u2 current-x) current-b) current-D))\n            (new-x (/ x-numerator x-denominator))\n            (threshold (var-get convergence-threshold))\n\n        )\n\n        (if (is-eq current-converged u0)\n            (if (> new-x  current-x)\n                (if (<= (- new-x current-x) threshold)\n                    {x: new-x, c: current-c, b: current-b, D: current-D, converged: new-x}\n                    {x: new-x, c: current-c, b: current-b, D: current-D, converged: u0}\n                )\n                (if (<= (- current-x new-x) threshold)\n                    {x: new-x, c: current-c, b: current-b, D: current-D, converged: new-x}\n                    {x: new-x, c: current-c, b: current-b, D: current-D, converged: u0}\n                )\n            )\n            x-info\n        )\n\n\n    )\n)\n\n;; Get DY\n(define-read-only (get-dy (x-token <sip-010-trait>) (y-token <sip-010-trait>) (lp-token <lp-trait>) (x-amount uint))\n    (let \n        (\n            \n            (pair-data (unwrap! (map-get? PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-balance-x (get balance-x pair-data))\n            (current-balance-y (get balance-y pair-data))\n            (x-decimals (get x-decimals pair-data))\n            (y-decimals (get y-decimals pair-data))\n            (swap-fee-lps (get lps (var-get swap-fees)))\n            (swap-fee-protocol (get protocol (var-get swap-fees)))\n            (total-swap-fee (+ swap-fee-lps swap-fee-protocol))\n            (current-amplification-coefficient (get amplification-coefficient pair-data))\n\n            ;; Scale up balances to perform AMM calculations with get-y\n            (scaled-up-balances (get-scaled-up-token-amounts current-balance-x current-balance-y x-decimals y-decimals))\n            (current-balance-x-scaled (get scaled-x scaled-up-balances))\n            (current-balance-y-scaled (get scaled-y scaled-up-balances))\n            (scaled-up-swap-amount (get-scaled-up-token-amounts x-amount u0 x-decimals y-decimals))\n            (x-amount-scaled (get scaled-x scaled-up-swap-amount))\n            (x-amount-fees-lps-scaled (/ (* x-amount-scaled swap-fee-lps) u10000))\n            (x-amount-fees-protocol-scaled (/ (* x-amount-scaled swap-fee-protocol) u10000))\n            (x-amount-total-fees-scaled (/ (* x-amount total-swap-fee) u10000))\n            (updated-x-amount-scaled (- x-amount-scaled x-amount-total-fees-scaled))\n            (updated-x-balance-scaled (+ current-balance-x-scaled updated-x-amount-scaled))\n            (new-y-scaled (get-y current-balance-x-scaled current-balance-y-scaled updated-x-amount-scaled (* current-amplification-coefficient number-of-tokens)))\n            \n            ;; Scale down to precise amounts for y and dy, as well as x-amount-fee-lps, and x-amount-fee-protocol\n            (new-y (get scaled-y (get-scaled-down-token-amounts u0 new-y-scaled x-decimals y-decimals)))\n            (dy (- current-balance-y new-y))\n            (x-amount-fee-lps (get scaled-x (get-scaled-down-token-amounts x-amount-fees-lps-scaled u0 x-decimals y-decimals)))\n            (x-amount-fee-protocol (get scaled-x (get-scaled-down-token-amounts x-amount-fees-protocol-scaled u0 x-decimals y-decimals)))\n        )\n        (ok dy)\n    )\n)\n\n;; Get Y\n;; Maybe move into get-dy?\n(define-read-only (get-y (x-bal uint) (y-bal uint) (x-amount uint) (ann uint))\n    (let \n        (\n            (x-bal-new (+ x-bal x-amount))\n            (current-D (get-D x-bal y-bal ann))\n            (c0 current-D)\n            (c1 (/ (* c0 current-D) (* number-of-tokens x-bal-new)))\n            (c2 (/ (* c1 current-D) (* ann number-of-tokens)))\n            (b (+ x-bal-new (/ current-D ann)))\n        )\n        (get converged (fold y-for-loop index-list {y: current-D, c: c2, b: b, D: current-D, converged: u0}))\n    )\n)\n\n;; Get Y Helper\n(define-private (y-for-loop (n uint) (y-info {y: uint, c: uint, b: uint, D: uint, converged: uint})) \n    (let\n        (\n            (current-y (get y y-info))\n            (current-c (get c y-info))\n            (current-b (get b y-info))\n            (current-D (get D y-info))\n            (current-converged (get converged y-info))\n            (y-numerator (+ (* current-y current-y) current-c))\n            (y-denominator (- (+ (* u2 current-y) current-b) current-D))\n            (new-y (/ y-numerator y-denominator))\n            (threshold (var-get convergence-threshold))\n\n        )\n\n        (if (is-eq current-converged u0)\n            (if (> new-y  current-y)\n                (if (<= (- new-y current-y) threshold)\n                    {y: new-y, c: current-c, b: current-b, D: current-D, converged: new-y}\n                    {y: new-y, c: current-c, b: current-b, D: current-D, converged: u0}\n                )\n                (if (<= (- current-y new-y) threshold)\n                    {y: new-y, c: current-c, b: current-b, D: current-D, converged: new-y}\n                    {y: new-y, c: current-c, b: current-b, D: current-D, converged: u0}\n                )\n            )\n            y-info\n        )\n\n    )\n)\n\n\n\n;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;\n;;; Swap Functions ;;;\n;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;\n\n;; Swap X -> Y\n;; @desc: Swaps X token for Y token\n;; @params: x-token: principal, y-token: principal, lp-token: principal, x-amount: uint, min-y-amount: uint\n(define-public (swap-x-for-y (x-token <sip-010-trait>) (y-token <sip-010-trait>) (lp-token <lp-trait>) (x-amount uint) (min-y-amount uint)) \n    (let \n        (\n            (swapper tx-sender)\n            (pair-data (unwrap! (map-get? PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-approval (get approval pair-data))\n            (current-balance-x (get balance-x pair-data))\n            (current-balance-y (get balance-y pair-data))\n            (x-decimals (get x-decimals pair-data))\n            (y-decimals (get y-decimals pair-data))\n            (swap-fee-lps (get lps (var-get swap-fees)))\n            (swap-fee-protocol (get protocol (var-get swap-fees)))\n            (total-swap-fee (+ swap-fee-lps swap-fee-protocol))\n            (current-amplification-coefficient (get amplification-coefficient pair-data))\n\n            ;; Scale up balances and the swap amount to perform AMM calculations with get-y\n            (scaled-up-balances (get-scaled-up-token-amounts current-balance-x current-balance-y x-decimals y-decimals))\n            (current-balance-x-scaled (get scaled-x scaled-up-balances))\n            (current-balance-y-scaled (get scaled-y scaled-up-balances))\n            (scaled-up-swap-amount (get-scaled-up-token-amounts x-amount u0 x-decimals y-decimals))\n            (x-amount-scaled (get scaled-x scaled-up-swap-amount))\n            (x-amount-fees-lps-scaled (/ (* x-amount-scaled swap-fee-lps) u10000))\n            (x-amount-fees-protocol-scaled (/ (* x-amount-scaled swap-fee-protocol) u10000))\n            (updated-x-amount-scaled (- x-amount-scaled (+ x-amount-fees-lps-scaled x-amount-fees-protocol-scaled)))\n            (updated-x-balance-scaled (+ current-balance-x-scaled updated-x-amount-scaled))\n            (new-y-scaled (get-y current-balance-x-scaled current-balance-y-scaled updated-x-amount-scaled (* current-amplification-coefficient number-of-tokens)))\n            \n            ;; Scale down to precise amounts for y and dy, as well as x-amount-fee-lps, and x-amount-fee-protocol\n            (new-y (get scaled-y (get-scaled-down-token-amounts u0 new-y-scaled x-decimals y-decimals)))\n            (dy (- current-balance-y new-y))\n            (x-amount-fee-lps (get scaled-x (get-scaled-down-token-amounts x-amount-fees-lps-scaled u0 x-decimals y-decimals)))\n            (x-amount-fee-protocol (get scaled-x (get-scaled-down-token-amounts x-amount-fees-protocol-scaled u0 x-decimals y-decimals)))\n            (updated-x-amount (- x-amount (+ x-amount-fee-lps x-amount-fee-protocol)))\n            (updated-x-balance (+ current-balance-x updated-x-amount))\n        )\n\n        ;; Assert that pair is approved\n        (asserts! current-approval (err \"err-pair-not-approved\"))\n\n        ;; Assert that x-amount is less than x10 of current-balance-x\n        (asserts! (< x-amount (* u10 current-balance-x)) (err \"err-x-amount-too-high\"))\n\n        ;; Assert that dy is greater than min-y-amount\n        (asserts! (> dy min-y-amount) (err \"err-min-y-amount\"))\n\n        ;; Transfer updated-x-balance tokens from tx-sender to this contract\n        (if (> updated-x-amount u0) \n            (unwrap! (contract-call? x-token transfer updated-x-amount swapper (as-contract tx-sender) none) (err \"err-transferring-token-x\"))\n            false\n        )\n\n        ;; Transfer x-amount-fee-lps tokens from tx-sender to staking-and-rewards-contract\n        (if (> x-amount-fee-lps u0) \n            (unwrap! (contract-call? x-token transfer x-amount-fee-lps swapper (var-get staking-and-rewards-contract) none) (err \"err-transferring-token-x-fee\"))\n            false\n        )\n\n        ;; Transfer x-amount-fee-protocol tokens from tx-sender to protocol-address\n        (if (> x-amount-fee-protocol u0) \n            (unwrap! (contract-call? x-token transfer x-amount-fee-protocol swapper protocol-address none) (err \"err-transferring-token-x-fee-protocol\"))\n            false\n        )\n\n        ;; Transfer dy tokens from this contract to tx-sender\n        (if (> dy u0) \n            (unwrap! (as-contract (contract-call? y-token transfer dy tx-sender swapper none)) (err \"err-transferring-token-y\")) \n            false\n        )\n\n        ;; Update all appropriate maps\n        ;; Update PairsDataMap\n        (map-set PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)} (merge \n            pair-data \n            {\n                balance-x: updated-x-balance,\n                balance-y: new-y,\n                d: (get-D updated-x-balance-scaled new-y-scaled (* (get amplification-coefficient pair-data) number-of-tokens))\n            }\n        ))\n\n        ;; Match if map-get? returns some for CycleDataMap\n        (match (map-get? CycleDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle-num: (get-current-cycle)})\n            cycle-data\n                ;; Update CycleDataMap\n                (map-set CycleDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle-num: (get-current-cycle)} (merge \n                    cycle-data \n                    {\n                        cycle-fee-balance-x: (+ (get cycle-fee-balance-x cycle-data) x-amount-fee-lps)\n                    }\n                ))\n                ;; Create new CycleDataMap\n                (map-set CycleDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle-num: (get-current-cycle)} {\n                    cycle-fee-balance-x: x-amount-fee-lps,\n                    cycle-fee-balance-y: u0,\n                }) \n        )\n\n        ;; Return the number of y tokens returned from the swap\n        (ok dy)\n\n    )\n)\n;; Swap Y -> X\n;; @desc: Swaps Y token for X token\n;; @params: y-token: principal, x-token: principal, lp-token: principal, x-amount: uint, min-x-amount: uint\n(define-public (swap-y-for-x (y-token <sip-010-trait>) (x-token <sip-010-trait>) (lp-token <lp-trait>) (y-amount uint) (min-x-amount uint)) \n    (let \n        (\n            (swapper tx-sender)\n            (pair-data (unwrap! (map-get? PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-approval (get approval pair-data))\n            (current-balance-x (get balance-x pair-data))\n            (current-balance-y (get balance-y pair-data))\n            (x-decimals (get x-decimals pair-data))\n            (y-decimals (get y-decimals pair-data))\n            (swap-fee-lps (get lps (var-get swap-fees)))\n            (swap-fee-protocol (get protocol (var-get swap-fees)))\n            (total-swap-fee (+ swap-fee-lps swap-fee-protocol))\n            (current-amplification-coefficient (get amplification-coefficient pair-data))\n\n            ;; Scale up balances and the swap amount to perform AMM calculations with get-x\n            (scaled-up-balances (get-scaled-up-token-amounts current-balance-x current-balance-y x-decimals y-decimals))\n            (current-balance-x-scaled (get scaled-x scaled-up-balances))\n            (current-balance-y-scaled (get scaled-y scaled-up-balances))\n            (scaled-up-swap-amount (get-scaled-up-token-amounts u0 y-amount x-decimals y-decimals))\n            (y-amount-scaled (get scaled-y scaled-up-swap-amount))\n            (y-amount-fees-lps-scaled (/ (* y-amount-scaled swap-fee-lps) u10000))\n            (y-amount-fees-protocol-scaled (/ (* y-amount-scaled swap-fee-protocol) u10000))\n            (updated-y-amount-scaled (- y-amount-scaled (+ y-amount-fees-lps-scaled y-amount-fees-protocol-scaled)))\n            (updated-y-balance-scaled (+ current-balance-y-scaled updated-y-amount-scaled))\n            (new-x-scaled (get-x current-balance-y-scaled current-balance-x-scaled updated-y-amount-scaled (* current-amplification-coefficient number-of-tokens)))\n            \n            ;; Scale down to precise amounts for y and dy, as well as y-amount-fee-lps, and y-amount-fee-protocol\n            (new-x (get scaled-x (get-scaled-down-token-amounts new-x-scaled u0 x-decimals y-decimals)))\n            (dx (- current-balance-x new-x))\n            (y-amount-fee-lps (get scaled-y (get-scaled-down-token-amounts u0 y-amount-fees-lps-scaled x-decimals y-decimals)))\n            (y-amount-fee-protocol (get scaled-y (get-scaled-down-token-amounts u0 y-amount-fees-protocol-scaled x-decimals y-decimals)))\n            (updated-y-amount (- y-amount (+ y-amount-fee-lps y-amount-fee-protocol)))\n            (updated-y-balance (+ current-balance-y updated-y-amount))\n        )\n\n        ;; Assert that pair is approved\n        (asserts! current-approval (err \"err-pair-not-approved\"))\n\n        ;; Assert that y-amount is less than x10 of current-balance-y\n        (asserts! (< y-amount (* u10 current-balance-y)) (err \"err-y-amount-too-high\"))\n\n        ;; Assert that dx is greater than min-x-amount\n        (asserts! (> dx min-x-amount) (err \"err-min-x-amount\"))\n\n        ;; Transfer updated-y-balance tokens from tx-sender to this contract\n        (if (> updated-y-amount u0) \n            (unwrap! (contract-call? y-token transfer updated-y-amount swapper (as-contract tx-sender) none) (err \"err-transferring-token-y\"))\n            false\n        )\n\n        ;; Transfer y-amount-fee-lps tokens from tx-sender to staking-and-rewards-contract\n        (if (> y-amount-fee-lps u0) \n            (unwrap! (contract-call? y-token transfer y-amount-fee-lps swapper (var-get staking-and-rewards-contract) none) (err \"err-transferring-token-y-swap-fee\"))\n            false\n        )\n\n        ;; Transfer y-amount-fee-protocol tokens from tx-sender to protocol-address\n        (if (> y-amount-fee-protocol u0) \n            (unwrap! (contract-call? y-token transfer y-amount-fee-protocol swapper protocol-address none) (err \"err-transferring-token-y-protocol-fee\"))\n            false\n        )\n\n        ;; Transfer dx tokens from this contract to tx-sender\n        (if (> dx u0) \n            (unwrap! (as-contract (contract-call? x-token transfer dx tx-sender swapper none)) (err \"err-transferring-token-x\"))\n            false\n        )\n\n        ;; Update all appropriate maps\n        ;; Update PairsDataMap\n        (map-set PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)} (merge \n            pair-data \n            {\n                balance-x: new-x,\n                balance-y: updated-y-balance,\n                d: (get-D new-x-scaled updated-y-balance-scaled (* (get amplification-coefficient pair-data) number-of-tokens))\n            }\n        ))\n\n        ;; Match if map-get? returns some for CycleDataMap\n        (match (map-get? CycleDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle-num: (get-current-cycle)})\n            cycle-data\n                ;; Update CycleDataMap\n                (map-set CycleDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle-num: (get-current-cycle)} (merge \n                    cycle-data \n                    {\n                        cycle-fee-balance-y: (+ (get cycle-fee-balance-y cycle-data) y-amount-fee-lps)\n                    }\n                ))\n                ;; Create new CycleDataMap\n                (map-set CycleDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token), cycle-num: (get-current-cycle)} {\n                    cycle-fee-balance-x: u0,\n                    cycle-fee-balance-y: y-amount-fee-lps,\n                }) \n        )\n\n        ;; Return the number of x tokens returned from the swap\n        (ok dx)\n\n    )\n)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Liquidity Functions ;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Add Liquidity\n;; @desc: Adds liquidity to a pair, mints the appropriate amount of LP tokens\n;; @params: x-token: principal, y-token: principal, lp-token: principal, x-amount-added: uint, y-amount-added: uint\n(define-public (add-liquidity (x-token <sip-010-trait>) (y-token <sip-010-trait>) (lp-token <lp-trait>) (x-amount-added uint) (y-amount-added uint) (min-lp-amount uint) )\n    (let \n        (\n            ;; Grabbing all data from PairsDataMap\n            (liquidity-provider tx-sender)\n            (current-pair (unwrap! (map-get? PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-approval (get approval current-pair))\n            (x-decimals (get x-decimals current-pair))\n            (y-decimals (get y-decimals current-pair))\n            (current-balance-x (get balance-x current-pair))\n            (new-balance-x (+ current-balance-x x-amount-added))\n            (current-balance-y (get balance-y current-pair))\n            (new-balance-y (+ current-balance-y y-amount-added))\n            (current-total-shares (get total-shares current-pair))\n            (current-amplification-coefficient (get amplification-coefficient current-pair))\n            \n            ;; Scale up for AMM calculations depending on decimal places assigned to tokens\n            (amounts-added-scaled (get-scaled-up-token-amounts x-amount-added y-amount-added x-decimals y-decimals))\n            (x-amount-added-scaled (get scaled-x amounts-added-scaled))\n            (y-amount-added-scaled (get scaled-y amounts-added-scaled))\n            (current-balances-scaled (get-scaled-up-token-amounts current-balance-x current-balance-y x-decimals y-decimals))\n            (current-balance-x-scaled (get scaled-x current-balances-scaled))\n            (current-balance-y-scaled (get scaled-y current-balances-scaled))\n            (new-balances-scaled (get-scaled-up-token-amounts new-balance-x new-balance-y x-decimals y-decimals))\n            (new-balance-x-scaled (get scaled-x new-balances-scaled))\n            (new-balance-y-scaled (get scaled-y new-balances-scaled))\n            \n            ;; Calculating the ideal balance\n            (d0 (get-D current-balance-x-scaled current-balance-y-scaled (* current-amplification-coefficient number-of-tokens)))\n            (d1 (get-D new-balance-x-scaled new-balance-y-scaled (* current-amplification-coefficient number-of-tokens)))\n            (ideal-balance-x-scaled (/ (* d1 current-balance-x-scaled) d0))\n            (ideal-balance-y-scaled (/ (* d1 current-balance-y-scaled) d0))\n            (x-difference (if (> ideal-balance-x-scaled new-balance-x-scaled) (- ideal-balance-x-scaled new-balance-x-scaled) (- new-balance-x-scaled ideal-balance-x-scaled)))\n            (y-difference (if (> ideal-balance-y-scaled new-balance-y-scaled) (- ideal-balance-y-scaled new-balance-y-scaled) (- new-balance-y-scaled ideal-balance-y-scaled)))\n            \n            ;; Fees applied if adding imbalanced liquidity\n            (ideal-x-fee-scaled (/ (* x-difference (var-get liquidity-fees)) u10000))\n            (ideal-y-fee-scaled (/ (* y-difference (var-get liquidity-fees)) u10000))\n            (x-fee-scaled (if (> x-amount-added-scaled ideal-x-fee-scaled) ideal-x-fee-scaled x-amount-added-scaled))\n            (y-fee-scaled (if (> y-amount-added-scaled ideal-y-fee-scaled) ideal-y-fee-scaled y-amount-added-scaled))\n            (x-amount-added-updated-scaled (- x-amount-added-scaled x-fee-scaled))\n            (y-amount-added-updated-scaled (- y-amount-added-scaled y-fee-scaled))\n            (new-balance-x-post-fee-scaled (+ current-balance-x-scaled x-amount-added-updated-scaled))\n            (new-balance-y-post-fee-scaled (+ current-balance-y-scaled y-amount-added-updated-scaled))\n            (d2 (get-D new-balance-x-post-fee-scaled new-balance-y-post-fee-scaled (* current-amplification-coefficient number-of-tokens)))\n\n            ;; Scale down for precise token balance updates and transfers\n            (precise-fees (get-scaled-down-token-amounts x-fee-scaled y-fee-scaled x-decimals y-decimals))\n            (x-fee (get scaled-x precise-fees))\n            (y-fee (get scaled-y precise-fees))\n            (amounts-added-scaled-down (get-scaled-down-token-amounts x-amount-added-updated-scaled y-amount-added-updated-scaled x-decimals y-decimals))\n            (x-amount-added-updated (get scaled-x amounts-added-scaled-down))\n            (y-amount-added-updated (get scaled-y amounts-added-scaled-down))\n            (balances-post-fee-scaled-down (get-scaled-down-token-amounts new-balance-x-post-fee-scaled new-balance-y-post-fee-scaled x-decimals y-decimals))\n            (new-balance-x-post-fee (get scaled-x balances-post-fee-scaled-down))\n            (new-balance-y-post-fee (get scaled-y balances-post-fee-scaled-down))\n        )\n\n        ;; Assert that pair is approved\n        (asserts! current-approval (err \"err-pair-not-approved\"))\n\n        ;; Assert that either x-amount-added or y-amount-added is greater than 0\n        (asserts! (or (> x-amount-added-updated u0) (> y-amount-added-updated u0)) (err \"err-x-or-y-amount-added-zero\"))\n\n        ;; Assert that d2 is greater than d0\n        (asserts! (> d2 d0) (err \"err-d2-less-than-d0\"))\n\n        ;; Assert that derived mint amount is greater than min-lp-amount\n        (asserts! (> (/ (* current-total-shares (- d2 d0)) d0) min-lp-amount) (err \"err-derived-amount-less-than-lp\"))\n\n        ;; ;; Transfer x-amount-added tokens from tx-sender to this contract\n        (if (> x-amount-added-updated u0) \n            (unwrap! (contract-call? x-token transfer x-amount-added-updated liquidity-provider (as-contract tx-sender) none) (err \"err-transferring-token-x-escrow\"))\n            false\n        )\n\n        ;; Transfer y-amount-added tokens from tx-sender to this contract\n        (if (> y-amount-added-updated u0)\n            (unwrap! (contract-call? y-token transfer y-amount-added-updated liquidity-provider (as-contract tx-sender) none) (err \"err-transferring-token-y\"))\n            false\n        )\n        \n        ;; Transfer x-fees tokens from tx-sender to protocol-address\n        (if (> x-fee u0)\n            (unwrap! (contract-call? x-token transfer x-fee liquidity-provider protocol-address none) (err \"err-transferring-token-x-protocol\"))\n            false\n        )\n         ;; Transfer y-fees tokens from tx-sender to protocol-address\n        (if (> y-fee u0)\n            (unwrap! (contract-call? y-token transfer y-fee liquidity-provider protocol-address none) (err \"err-transferring-token-y-protocol\"))\n            false\n        )\n\n        ;; Mint LP tokens to tx-sender\n        (unwrap! (as-contract (contract-call? lp-token mint liquidity-provider (/ (* current-total-shares (- d2 d0)) d0))) (err \"err-minting-lp-tokens\"))\n\n        ;; Update all appropriate maps\n        ;; Update PairsDataMap\n        (map-set PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)} \n            (merge \n                current-pair \n                {\n                    balance-x: new-balance-x-post-fee,\n                    balance-y: new-balance-y-post-fee,\n                    total-shares: (+ current-total-shares (/ (* current-total-shares (- d2 d0)) d0)),\n                    d: d2\n                }\n        ))\n\n        ;; Return the number of LP tokens minted\n        (ok (/ (* current-total-shares (- d2 d0)) d0))\n    )\n)\n\n;; Withdraw Liquidity\n;; @desc: Withdraws liquidity from both pairs & burns the appropriate amount of LP tokens\n;; @params: x-token: principal, y-token: principal, lp-token: principal, lp-amount: uint, min-x-amount: uint, min-y-amount: uint\n(define-public (withdraw-liquidity (x-token <sip-010-trait>) (y-token <sip-010-trait>) (lp-token <lp-trait>) (lp-amount uint) (min-x-amount uint) (min-y-amount uint))\n    (let \n        (\n            ;; Grabbing all data from PairsDataMap\n            (current-pair (unwrap! (map-get? PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-approval (get approval current-pair))\n            (x-decimals (get x-decimals current-pair))\n            (y-decimals (get y-decimals current-pair))\n            (current-balance-x (get balance-x current-pair))\n            (current-balance-y (get balance-y current-pair))\n            (current-total-shares (get total-shares current-pair))\n            (current-amplification-coefficient (get amplification-coefficient current-pair))\n            (withdrawal-balance-x (/ (* current-balance-x lp-amount) current-total-shares))\n            (withdrawal-balance-y (/ (* current-balance-y lp-amount) current-total-shares))\n            (new-balance-x (- current-balance-x withdrawal-balance-x))\n            (new-balance-y (- current-balance-y withdrawal-balance-y))\n            (liquidity-remover tx-sender)\n            ;; get-D using the new-balance-x and new-balance-y\n            (new-balances-scaled (get-scaled-up-token-amounts new-balance-x new-balance-y x-decimals y-decimals))\n            (new-balance-x-scaled (get scaled-x new-balances-scaled))\n            (new-balance-y-scaled (get scaled-y new-balances-scaled))\n            (new-d (get-D new-balance-x-scaled new-balance-y-scaled (* current-amplification-coefficient number-of-tokens)))\n        )\n\n        ;; Assert that withdrawal-balance-x is greater than min-x-amount\n        (asserts! (> withdrawal-balance-x min-x-amount) (err \"err-withdrawal-balance-x-less-than-min-x-amount\"))\n\n        ;; Assert that withdrawal-balance-y is greater than min-y-amount\n        (asserts! (> withdrawal-balance-y min-y-amount) (err \"err-withdrawal-balance-y-less-than-min-y-amount\"))\n\n        ;; Burn LP tokens from tx-sender\n        (unwrap! (contract-call? lp-token burn liquidity-remover lp-amount) (err \"err-burning-lp-tokens\"))\n\n        ;; Transfer withdrawal-balance-x tokens from this contract to liquidity-taker\n        (unwrap! (as-contract (contract-call? x-token transfer withdrawal-balance-x tx-sender liquidity-remover none)) (err \"err-transferring-token-x\"))\n\n        ;; Transfer withdrawal-balance-y tokens from this contract to liquidity-taker\n        (unwrap! (as-contract (contract-call? y-token transfer withdrawal-balance-y tx-sender liquidity-remover none)) (err \"err-transferring-token-y\"))\n\n        ;; Update all appropriate maps\n        ;; Update PairsDataMap\n        (map-set PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)} (merge \n            current-pair \n            {\n                balance-x: new-balance-x,\n                balance-y: new-balance-y,\n                total-shares: (- current-total-shares lp-amount),\n                d: new-d\n            }\n        ))\n\n        ;; Return the number X tokens and Y tokens received after withdrawing from pool\n        (ok {withdrawal-x-balance: withdrawal-balance-x, withdrawal-y-balance: withdrawal-balance-y})\n    )\n)\n\n\n;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;\n;;; AMM Functions ;;;\n;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;\n\n;; D for loop\n;; Get D\n(define-read-only (get-D (x-bal uint) (y-bal uint) (ann uint))\n    (get converged (fold D-for-loop index-list {D: (+ x-bal y-bal), x-bal: x-bal, y-bal: y-bal, ann: ann, converged: u0}))\n)\n\n;; Get D Helper\n(define-private (D-for-loop (n uint) (D-info {D: uint, x-bal: uint, y-bal: uint, ann: uint, converged: uint})) \n    (let \n        (\n            ;; Grabbing everything from D-info\n            (current-D-partial (get D D-info))\n            (current-D (get D D-info))\n            (current-x-bal (get x-bal D-info))\n            (current-y-bal (get y-bal D-info))\n            (current-S (+ current-x-bal current-y-bal))\n            (current-ann (get ann D-info))\n            (current-converged (get converged D-info))\n\n            ;; Start logic for calculating new D\n            ;; Calculate new partial D with respect to x\n            (new-D-partial-x (/ (* current-D current-D-partial) (* u2 current-x-bal)))\n            ;; Calculate new partial D with respect to now x & y\n            (new-D-partial (/ (* current-D new-D-partial-x ) (* u2 current-y-bal)))\n\n            (new-numerator (* (+ (* current-ann current-S) (* number-of-tokens new-D-partial)) current-D))\n            (new-denominator (+ (* (- current-ann u1) current-D) (* (+ number-of-tokens u1 ) new-D-partial)))\n\n            (new-D (/ new-numerator new-denominator))\n            (threshold (var-get convergence-threshold))\n\n            \n        )\n        \n        ;; Check if converged value / new D was already found\n        (if (is-eq current-converged u0)\n            (if (> new-D  current-D)\n                (if (<= (- new-D current-D) threshold)\n                    {D: new-D, x-bal: current-x-bal, y-bal: current-y-bal, ann: current-ann, converged: new-D}\n                    {D: new-D, x-bal: current-x-bal, y-bal: current-y-bal, ann: current-ann, converged: u0}\n                )\n                (if (<= (- current-D new-D) threshold)\n                    {D: new-D, x-bal: current-x-bal, y-bal: current-y-bal, ann: current-ann, converged: new-D}\n                    {D: new-D, x-bal: current-x-bal, y-bal: current-y-bal, ann: current-ann, converged: u0}\n                )\n            )\n            D-info\n        )\n    \n    )\n)\n\n;; Scale up the token amounts to the same level of precision before performing AMM calculations\n;; @params: x-amount-unscaled: uint, y-amount-unscaled:uint, x-num-decimals: uint, y-num-decimals: uint\n(define-private (get-scaled-up-token-amounts (x-amount-unscaled uint) (y-amount-unscaled uint) (x-num-decimals uint) (y-num-decimals uint))\n    (let \n        (\n            (scaled-x \n                ;; if same number of decimals, set to x-amount-unscaled\n                (if (is-eq x-num-decimals y-num-decimals)\n                    x-amount-unscaled\n                    ;; if x has more decimals, set to x-amount-unscaled; otherwise scale up by the difference in decimals\n                    (if (> x-num-decimals y-num-decimals) x-amount-unscaled (* x-amount-unscaled (pow u10 (- y-num-decimals x-num-decimals))))\n                )\n            )\n            (scaled-y \n                ;; if same number of decimals, set to y-amount-unscaled\n                (if (is-eq x-num-decimals y-num-decimals)\n                    y-amount-unscaled\n                    ;; if y has more decimals, set to y-amount-unscaled; otherwise scale up by the difference in decimals\n                    (if (> y-num-decimals x-num-decimals) y-amount-unscaled (* y-amount-unscaled (pow u10 (- x-num-decimals y-num-decimals))))\n                )\n            )\n        )\n        {scaled-x: scaled-x, scaled-y: scaled-y}\n    )\n)\n\n;; Scale down the token amounts to their respective levels of precision before performing any transfers\n;; @params: x-amount-scaled: uint, y-amount-scaled:uint, x-num-decimals: uint, y-num-decimals: uint\n(define-private (get-scaled-down-token-amounts (x-amount-scaled uint) (y-amount-scaled uint) (x-num-decimals uint) (y-num-decimals uint))\n    (let \n        (\n            (scaled-x \n                ;; if same number of decimals, set to x-amount-scaled\n                (if (is-eq x-num-decimals y-num-decimals)\n                    x-amount-scaled\n                    ;; if x has more decimals, set to x-amount-scaled; otherwise scale down by the difference in decimals\n                    (if (> x-num-decimals y-num-decimals) x-amount-scaled (/ x-amount-scaled (pow u10 (- y-num-decimals x-num-decimals))))\n                )\n            )\n            (scaled-y \n                ;; if same number of decimals, set to y-amount-scaled\n                (if (is-eq x-num-decimals y-num-decimals)\n                    y-amount-scaled\n                    ;; if y has more decimals, set to y-amount-scaled; otherwise scale down by the difference in decimals\n                    (if (> y-num-decimals x-num-decimals) y-amount-scaled (/ y-amount-scaled (pow u10 (- x-num-decimals y-num-decimals))))\n                )\n            )\n        )\n        {scaled-x: scaled-x, scaled-y: scaled-y}\n    )\n)\n\n;; @desc - Helper function for removing a admin\n(define-private (is-not-removeable (admin principal))\n  (not (is-eq admin (var-get helper-principal)))\n)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Goverance Functions ;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; Create Pair\n;; @desc: Creates a new pair for trading\n;; @params: x-token: principal, y-token: principal, lp-token: principal, amplification-coefficient: uint, pair-name: string, x-balance: uint, y-balance: uint\n;; initial-balance param is for TOTAL balance of x + y tokens (aka 2x or 2y or (x + y))\n(define-public (create-pair (x-token <sip-010-trait>) (y-token <sip-010-trait>) (lp-token <lp-trait>) (amplification-coefficient uint) (pair-name (string-ascii 32)) (initial-x-bal uint) (initial-y-bal uint))\n    (let \n        (\n            (lp-owner tx-sender)\n            (x-decimals (unwrap! (contract-call? x-token get-decimals) (err \"err-getting-x-decimals\")))\n            (y-decimals (unwrap! (contract-call? y-token get-decimals) (err \"err-getting-y-decimals\")))\n            (scaled-up-balances (get-scaled-up-token-amounts initial-x-bal initial-y-bal x-decimals y-decimals))\n            (initial-x-bal-scaled (get scaled-x scaled-up-balances))\n            (initial-y-bal-scaled (get scaled-y scaled-up-balances))\n        )\n\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of (var-get admins) tx-sender )) (err \"err-not-admin\"))\n\n        ;; Assert using and that the pair does not already exist using is-none & map-get?\n        (asserts! (and \n            (is-none (map-get? PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)}))\n            (is-none (map-get? PairsDataMap {x-token: (contract-of y-token), y-token: (contract-of x-token), lp-token: (contract-of lp-token)}))\n        )  (err \"err-pair-xy-or-yx-exists\"))\n\n        ;; Assert that both initial balances are greater than 0\n        (asserts! (or (> initial-x-bal u0) (> initial-y-bal u0)) (err \"err-initial-bal-zero\"))\n\n        ;; Assert that x & y tokens are the same\n        (asserts! (is-eq initial-x-bal-scaled initial-y-bal-scaled) (err \"err-initial-bal-odd\"))\n\n        ;; Mint LP tokens to tx-sender\n        (unwrap! (as-contract (contract-call? lp-token mint lp-owner (+ initial-x-bal-scaled initial-y-bal-scaled))) (err \"err-minting-lp-tokens\"))\n\n        ;; Transfer token x liquidity to this contract\n        (unwrap! (contract-call? x-token transfer initial-x-bal tx-sender (as-contract tx-sender) none) (err \"err-transferring-token-x\"))\n\n        ;; Transfer token y liquidity to this contract\n        (unwrap! (contract-call? y-token transfer initial-y-bal tx-sender (as-contract tx-sender) none) (err \"err-transferring-token-y\"))\n\n        ;; Update all appropriate maps\n        (ok (map-set PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)} {\n            approval: true,\n            total-shares: (+ initial-x-bal-scaled initial-y-bal-scaled),\n            x-decimals: x-decimals,\n            y-decimals: y-decimals,\n            balance-x: initial-x-bal,\n            balance-y: initial-y-bal,\n            d: (+ initial-x-bal-scaled initial-y-bal-scaled),\n            amplification-coefficient: amplification-coefficient,\n        }))\n    )\n)\n\n\n;; Setting Pair Approval\n;; @desc: Sets the approval of a pair\n;; @params: x-token: principal, y-token: principal, lp-token: principal, approval: bool\n(define-public (set-pair-approval (x-token <sip-010-trait>) (y-token <sip-010-trait>) (lp-token <lp-trait>) (approval bool))\n    (let \n        (\n            (current-pair (unwrap! (map-get? PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n        )\n\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of (var-get admins) tx-sender)) (err \"err-not-admin\"))\n\n        ;; Update all appropriate maps\n        (ok (map-set PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)} (merge \n            current-pair\n            {\n                approval: approval\n            }\n        )))\n    )\n)\n\n;; Add Admin\n;; @desc: Adds an admin to the admins var list\n;; @params: admin: principal\n(define-public (add-admin (admin principal))\n    (let \n        (\n            (current-admins (var-get admins))\n            ;;(new-admins (unwrap! (as-max-len? (append current-admins admin) u5) (\"err-add-admin-overflow\")))\n        )\n\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        ;; Assert that admin is not already an admin using is-none & index-of with the admins var\n        (asserts! (is-none (index-of current-admins admin)) (err \"err-already-admin\"))\n\n        ;; Update all appropriate maps\n        (ok (var-set admins (unwrap! (as-max-len? (append current-admins admin) u5) (err \"err-admin-overflow\"))))\n    )\n)\n\n;; Remove admin\n(define-public (remove-admin (admin principal))\n  (let\n    (\n      (current-admin-list (var-get admins))\n      (caller-principal-position-in-list (index-of current-admin-list tx-sender))\n      (removeable-principal-position-in-list (index-of current-admin-list admin))\n    )\n\n    ;; asserts tx-sender is an existing whitelist address\n    (asserts! (is-some caller-principal-position-in-list) (err \"err-not-auth\"))\n\n    ;; asserts param principal (removeable whitelist) already exist\n    (asserts! (is-some removeable-principal-position-in-list) (err \"err-not-whitelisted\"))\n\n    ;; asserts the initial contract deployer cannot be removed from admin list to protect against rogue admins\n    (asserts! (not (is-eq admin contract-deployer)) (err \"err-cannot-remove-contract-deployer\"))\n\n    ;; temporary var set to help remove param principal\n    (var-set helper-principal admin)\n\n    ;; filter existing whitelist address\n    (ok \n      (var-set admins (filter is-not-removeable current-admin-list))\n    )\n  )\n)\n\n;; Change Swap Fee\n(define-public (change-swap-fee (new-lps-fee uint) (new-protocol-fee uint)) \n    (let \n        (\n            (current-admins (var-get admins))\n        )\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        (ok (var-set swap-fees {lps: new-lps-fee, protocol: new-protocol-fee}))\n    )\n)\n\n;; Change Liquidity Fee\n(define-public (change-liquidity-fee (new-liquidity-fee uint)) \n    (let \n        (\n            (current-admins (var-get admins))\n        )\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        (ok (var-set liquidity-fees new-liquidity-fee))\n    )\n)\n\n;; Admins can change the amplification coefficient in PairsDataMap\n;; @params: x-token: principal, y-token: principal, lp-token: principal, amplification-coefficient: uint\n(define-public (change-amplification-coefficient (x-token <sip-010-trait>) (y-token <sip-010-trait>) (lp-token <lp-trait>) (amplification-coefficient uint))\n    (let \n        (\n            (current-pair (unwrap! (map-get? PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)}) (err \"err-no-pair-data\")))\n            (current-admins (var-get admins))\n        )\n\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        ;; Update all appropriate maps\n        (ok (map-set PairsDataMap {x-token: (contract-of x-token), y-token: (contract-of y-token), lp-token: (contract-of lp-token)} (merge \n            current-pair\n            {\n                amplification-coefficient: amplification-coefficient\n            }\n        )))\n    )\n)\n\n;; Change Convergence Threshold \n(define-public (change-convergence-threshold (new-convergence-threshold uint)) \n    (let \n        (\n            (current-admins (var-get admins))\n        )\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        (ok (var-set convergence-threshold new-convergence-threshold))\n    )\n)\n\n;; Admins can set the contract for handling staking and rewards\n;; @params: staking-contract: principal\n(define-public (set-staking-contract (staking-contract principal))\n    (let \n        (\n            (current-admins (var-get admins))\n        )\n\n        ;; Assert that tx-sender is an admin using is-some & index-of with the admins var\n        (asserts! (is-some (index-of current-admins tx-sender)) (err \"err-not-admin\"))\n\n        ;; Set contract for handling staking and rewards\n        (var-set staking-and-rewards-contract staking-contract)\n        \n        (ok staking-contract)\n    )\n)",
    "analysis": {
      "summary": "This contract implements a decentralized exchange (DEX) protocol for stablecoin swaps, liquidity provision, and governance.",
      "explanation": "The contract starts by importing two traits for fungible tokens and liquidity pool tokens <L12-13>. It then defines constants such as the contract's address, deployment height, cycle length, and parameters for the Newton-Raphson method used in AMM calculations <L19-38>. A data variable for the staking and rewards contract is also declared <L41>. Admins are managed through a list, and fees for swapping and liquidity provision are set as variables <L54-60>. The core of the contract is the management of token pairs, including their approval status, balances, and AMM parameters, stored in a map <L73-82>. Several read-only functions provide data access <L97-125>, and key AMM functions calculate token exchange rates <L130-302>. The contract includes swap functions for exchanging tokens <L312-521>, liquidity functions for adding or withdrawing liquidity <L529-703>, and governance functions for managing pairs, fees, and admins <L827-1029>. Notably, it uses a sophisticated algorithm for price calculation, ensuring stable swaps between tokens.",
      "tags": ["DEX", "stableswap", "liquidity", "governance"],
      "notable_qualities": [
        "Implements a stableswap algorithm for efficient stablecoin trading.",
        "Includes governance features for managing the protocol.",
        "Utilizes the Newton-Raphson method for accurate AMM calculations.",
        "Supports liquidity provision and rewards through staking."
      ]
    }
  },
  {
    "rank": 48,
    "contract": "SPQC38PW542EQJ5M11CR25P7BS1CA6QT4TBXGB3M.router-stableswap-alex-v-1-2",
    "calls": 692,
    "source": ";; router-stableswap-alex-v-1-2\n\n(use-trait stableswap-ft-trait 'SP2AKWJYC7BNY18W1XXKPGP0YVEK63QJG4793Z2D4.sip-010-trait-ft-standard.sip-010-trait)\n(use-trait stableswap-pool-trait 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.stableswap-pool-trait-v-1-2.stableswap-pool-trait)\n(use-trait alex-ft-trait 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.trait-sip-010.sip-010-trait)\n\n(define-constant ERR_NOT_AUTHORIZED (err u6001))\n(define-constant ERR_INVALID_AMOUNT (err u6002))\n(define-constant ERR_INVALID_PRINCIPAL (err u6003))\n(define-constant ERR_ALREADY_ADMIN (err u6004))\n(define-constant ERR_ADMIN_LIMIT_REACHED (err u6005))\n(define-constant ERR_ADMIN_NOT_IN_LIST (err u6006))\n(define-constant ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER (err u6007))\n(define-constant ERR_SWAP_STATUS (err u6008))\n(define-constant ERR_MINIMUM_RECEIVED (err u6009))\n(define-constant ERR_SWAP_A (err u6010))\n(define-constant ERR_SWAP_B (err u6011))\n(define-constant ERR_SCALED_AMOUNT_A (err u6012))\n(define-constant ERR_QUOTE_A (err u6013))\n(define-constant ERR_QUOTE_B (err u6014))\n\n(define-constant CONTRACT_DEPLOYER tx-sender)\n\n(define-data-var admins (list 5 principal) (list tx-sender))\n(define-data-var admin-helper principal tx-sender)\n\n(define-data-var swap-status bool true)\n\n(define-read-only (get-admins)\n  (ok (var-get admins))\n)\n\n(define-read-only (get-admin-helper)\n  (ok (var-get admin-helper))\n)\n\n(define-read-only (get-swap-status)\n  (ok (var-get swap-status))\n)\n\n(define-public (add-admin (admin principal))\n  (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n  )\n    (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n    (asserts! (is-none (index-of admins-list admin)) ERR_ALREADY_ADMIN)\n    (var-set admins (unwrap! (as-max-len? (append admins-list admin) u5) ERR_ADMIN_LIMIT_REACHED))\n    (print {action: \"add-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n  )\n)\n\n(define-public (remove-admin (admin principal))\n  (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n  )\n    (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n    (asserts! (is-some (index-of admins-list admin)) ERR_ADMIN_NOT_IN_LIST)\n    (asserts! (not (is-eq admin CONTRACT_DEPLOYER)) ERR_CANNOT_REMOVE_CONTRACT_DEPLOYER)\n    (var-set admin-helper admin)\n    (var-set admins (filter admin-not-removable admins-list))\n    (print {action: \"remove-admin\", caller: caller, data: {admin: admin}})\n    (ok true)\n  )\n)\n\n(define-public (set-swap-status (status bool))\n  (let (\n    (admins-list (var-get admins))\n    (caller tx-sender)\n  )\n    (begin\n      (asserts! (is-some (index-of admins-list caller)) ERR_NOT_AUTHORIZED)\n      (var-set swap-status status)\n      (print {action: \"set-swap-status\", caller: caller, data: {status: status}})\n      (ok true)\n    )\n  )\n)\n\n(define-public (get-quote-a\n    (amount uint)\n    (swaps-reversed bool)\n    (stableswap-tokens (tuple (a <stableswap-ft-trait>) (b <stableswap-ft-trait>)))\n    (stableswap-pools (tuple (a <stableswap-pool-trait>)))\n    (alex-tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>)))\n    (alex-factors (tuple (a uint)))\n  )\n  (let (\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (stableswap-qa amount stableswap-tokens stableswap-pools) ERR_QUOTE_A)\n                 (unwrap! (alex-qa amount alex-tokens alex-factors) ERR_QUOTE_A)))\n    (scaled-amount-a (if (is-eq swaps-reversed false)\n                         (unwrap! (scale-up-stableswap-amount quote-a (get b stableswap-tokens) (get a alex-tokens)) ERR_SCALED_AMOUNT_A)\n                         (unwrap! (scale-down-alex-amount quote-a (get b alex-tokens) (get a stableswap-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qa scaled-amount-a alex-tokens alex-factors) ERR_QUOTE_B)\n                 (unwrap! (stableswap-qa scaled-amount-a stableswap-tokens stableswap-pools) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-b\n    (amount uint)\n    (swaps-reversed bool)\n    (stableswap-tokens (tuple (a <stableswap-ft-trait>) (b <stableswap-ft-trait>)))\n    (stableswap-pools (tuple (a <stableswap-pool-trait>)))\n    (alex-tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>) (c <alex-ft-trait>)))\n    (alex-factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (stableswap-qa amount stableswap-tokens stableswap-pools) ERR_QUOTE_A)\n                 (unwrap! (alex-qb amount alex-tokens alex-factors) ERR_QUOTE_A)))\n    (scaled-amount-a (if (is-eq swaps-reversed false)\n                         (unwrap! (scale-up-stableswap-amount quote-a (get b stableswap-tokens) (get a alex-tokens)) ERR_SCALED_AMOUNT_A)\n                         (unwrap! (scale-down-alex-amount quote-a (get c alex-tokens) (get a stableswap-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qb scaled-amount-a alex-tokens alex-factors) ERR_QUOTE_B)\n                 (unwrap! (stableswap-qa scaled-amount-a stableswap-tokens stableswap-pools) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-c\n    (amount uint)\n    (swaps-reversed bool)\n    (stableswap-tokens (tuple (a <stableswap-ft-trait>) (b <stableswap-ft-trait>)))\n    (stableswap-pools (tuple (a <stableswap-pool-trait>)))\n    (alex-tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>) (c <alex-ft-trait>) (d <alex-ft-trait>)))\n    (alex-factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (stableswap-qa amount stableswap-tokens stableswap-pools) ERR_QUOTE_A)\n                 (unwrap! (alex-qc amount alex-tokens alex-factors) ERR_QUOTE_A)))\n    (scaled-amount-a (if (is-eq swaps-reversed false)\n                         (unwrap! (scale-up-stableswap-amount quote-a (get b stableswap-tokens) (get a alex-tokens)) ERR_SCALED_AMOUNT_A)\n                         (unwrap! (scale-down-alex-amount quote-a (get d alex-tokens) (get a stableswap-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qc scaled-amount-a alex-tokens alex-factors) ERR_QUOTE_B)\n                 (unwrap! (stableswap-qa scaled-amount-a stableswap-tokens stableswap-pools) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (get-quote-d\n    (amount uint)\n    (swaps-reversed bool)\n    (stableswap-tokens (tuple (a <stableswap-ft-trait>) (b <stableswap-ft-trait>)))\n    (stableswap-pools (tuple (a <stableswap-pool-trait>)))\n    (alex-tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>) (c <alex-ft-trait>) (d <alex-ft-trait>) (e <alex-ft-trait>)))\n    (alex-factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n    (quote-a (if (is-eq swaps-reversed false)\n                 (unwrap! (stableswap-qa amount stableswap-tokens stableswap-pools) ERR_QUOTE_A)\n                 (unwrap! (alex-qd amount alex-tokens alex-factors) ERR_QUOTE_A)))\n    (scaled-amount-a (if (is-eq swaps-reversed false)\n                         (unwrap! (scale-up-stableswap-amount quote-a (get b stableswap-tokens) (get a alex-tokens)) ERR_SCALED_AMOUNT_A)\n                         (unwrap! (scale-down-alex-amount quote-a (get e alex-tokens) (get a stableswap-tokens)) ERR_SCALED_AMOUNT_A)))\n    (quote-b (if (is-eq swaps-reversed false)\n                 (unwrap! (alex-qd scaled-amount-a alex-tokens alex-factors) ERR_QUOTE_B)\n                 (unwrap! (stableswap-qa scaled-amount-a stableswap-tokens stableswap-pools) ERR_QUOTE_B)))\n  )\n    (ok quote-b)\n  )\n)\n\n(define-public (swap-helper-a\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (stableswap-tokens (tuple (a <stableswap-ft-trait>) (b <stableswap-ft-trait>)))\n    (stableswap-pools (tuple (a <stableswap-pool-trait>)))\n    (alex-tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>)))\n    (alex-factors (tuple (a uint)))\n  )\n  (let (\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (stableswap-sa amount stableswap-tokens stableswap-pools) ERR_SWAP_A)\n                (unwrap! (alex-sa amount alex-tokens alex-factors) ERR_SWAP_A)))\n    (scaled-amount-a (if (is-eq swaps-reversed false)\n                         (unwrap! (scale-up-stableswap-amount swap-a (get b stableswap-tokens) (get a alex-tokens)) ERR_SCALED_AMOUNT_A)\n                         (unwrap! (scale-down-alex-amount swap-a (get b alex-tokens) (get a stableswap-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sa scaled-amount-a alex-tokens alex-factors) ERR_SWAP_B)\n                (unwrap! (stableswap-sa scaled-amount-a stableswap-tokens stableswap-pools) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-a\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          stableswap-data: {\n            stableswap-tokens: stableswap-tokens,\n            stableswap-pools: stableswap-pools,\n            stableswap-swaps: {\n             a: (if (is-eq swaps-reversed false) swap-a swap-b)\n            }\n          },\n          alex-data: {\n            alex-tokens: alex-tokens,\n            alex-factors: alex-factors,\n            alex-swaps: {\n              a: (if (is-eq swaps-reversed false) swap-b swap-a)\n            }\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-b\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (stableswap-tokens (tuple (a <stableswap-ft-trait>) (b <stableswap-ft-trait>)))\n    (stableswap-pools (tuple (a <stableswap-pool-trait>)))\n    (alex-tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>) (c <alex-ft-trait>)))\n    (alex-factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (stableswap-sa amount stableswap-tokens stableswap-pools) ERR_SWAP_A)\n                (unwrap! (alex-sb amount alex-tokens alex-factors) ERR_SWAP_A)))\n    (scaled-amount-a (if (is-eq swaps-reversed false)\n                         (unwrap! (scale-up-stableswap-amount swap-a (get b stableswap-tokens) (get a alex-tokens)) ERR_SCALED_AMOUNT_A)\n                         (unwrap! (scale-down-alex-amount swap-a (get c alex-tokens) (get a stableswap-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sb scaled-amount-a alex-tokens alex-factors) ERR_SWAP_B)\n                (unwrap! (stableswap-sa scaled-amount-a stableswap-tokens stableswap-pools) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-b\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          stableswap-data: {\n            stableswap-tokens: stableswap-tokens,\n            stableswap-pools: stableswap-pools,\n            stableswap-swaps: {\n              a: (if (is-eq swaps-reversed false) swap-a swap-b)\n            }\n          },\n          alex-data: {\n            alex-tokens: alex-tokens,\n            alex-factors: alex-factors,\n            alex-swaps: {\n              a: (if (is-eq swaps-reversed false) swap-b swap-a)\n            }\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-c\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (stableswap-tokens (tuple (a <stableswap-ft-trait>) (b <stableswap-ft-trait>)))\n    (stableswap-pools (tuple (a <stableswap-pool-trait>)))\n    (alex-tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>) (c <alex-ft-trait>) (d <alex-ft-trait>)))\n    (alex-factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (stableswap-sa amount stableswap-tokens stableswap-pools) ERR_SWAP_A)\n                (unwrap! (alex-sc amount alex-tokens alex-factors) ERR_SWAP_A)))\n    (scaled-amount-a (if (is-eq swaps-reversed false)\n                         (unwrap! (scale-up-stableswap-amount swap-a (get b stableswap-tokens) (get a alex-tokens)) ERR_SCALED_AMOUNT_A)\n                         (unwrap! (scale-down-alex-amount swap-a (get d alex-tokens) (get a stableswap-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sc scaled-amount-a alex-tokens alex-factors) ERR_SWAP_B)\n                (unwrap! (stableswap-sa scaled-amount-a stableswap-tokens stableswap-pools) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-c\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          stableswap-data: {\n            stableswap-tokens: stableswap-tokens,\n            stableswap-pools: stableswap-pools,\n            stableswap-swaps: {\n              a: (if (is-eq swaps-reversed false) swap-a swap-b)\n            }\n          },\n          alex-data: {\n            alex-tokens: alex-tokens,\n            alex-factors: alex-factors,\n            alex-swaps: {\n              a: (if (is-eq swaps-reversed false) swap-b swap-a)\n            }\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-public (swap-helper-d\n    (amount uint) (min-received uint)\n    (swaps-reversed bool)\n    (stableswap-tokens (tuple (a <stableswap-ft-trait>) (b <stableswap-ft-trait>)))\n    (stableswap-pools (tuple (a <stableswap-pool-trait>)))\n    (alex-tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>) (c <alex-ft-trait>) (d <alex-ft-trait>) (e <alex-ft-trait>)))\n    (alex-factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (swap-status-check (asserts! (is-eq (var-get swap-status) true) ERR_SWAP_STATUS))\n    (amount-check (asserts! (> amount u0) ERR_INVALID_AMOUNT))\n    (swap-a (if (is-eq swaps-reversed false)\n                (unwrap! (stableswap-sa amount stableswap-tokens stableswap-pools) ERR_SWAP_A)\n                (unwrap! (alex-sd amount alex-tokens alex-factors) ERR_SWAP_A)))\n    (scaled-amount-a (if (is-eq swaps-reversed false)\n                         (unwrap! (scale-up-stableswap-amount swap-a (get b stableswap-tokens) (get a alex-tokens)) ERR_SCALED_AMOUNT_A)\n                         (unwrap! (scale-down-alex-amount swap-a (get e alex-tokens) (get a stableswap-tokens)) ERR_SCALED_AMOUNT_A)))\n    (swap-b (if (is-eq swaps-reversed false)\n                (unwrap! (alex-sd scaled-amount-a alex-tokens alex-factors) ERR_SWAP_B)\n                (unwrap! (stableswap-sa scaled-amount-a stableswap-tokens stableswap-pools) ERR_SWAP_B)))\n  )\n    (begin\n      (asserts! (>= swap-b min-received) ERR_MINIMUM_RECEIVED)\n      (print {\n        action: \"swap-helper-d\",\n        caller: tx-sender, \n        data: {\n          amount: amount,\n          min-received: min-received,\n          received: swap-b,\n          swaps-reversed: swaps-reversed,\n          stableswap-data: {\n            stableswap-tokens: stableswap-tokens,\n            stableswap-pools: stableswap-pools,\n            stableswap-swaps: {\n              a: (if (is-eq swaps-reversed false) swap-a swap-b)\n            }\n          },\n          alex-data: {\n            alex-tokens: alex-tokens,\n            alex-factors: alex-factors,\n            alex-swaps: {\n              a: (if (is-eq swaps-reversed false) swap-b swap-a)\n            }\n          }\n        }\n      })\n      (ok swap-b)\n    )\n  )\n)\n\n(define-private (admin-not-removable (admin principal))\n  (not (is-eq admin (var-get admin-helper)))\n)\n\n(define-private (is-stableswap-path-reversed\n    (token-in <stableswap-ft-trait>) (token-out <stableswap-ft-trait>)\n    (pool-contract <stableswap-pool-trait>)\n  )\n  (let (\n    (pool-data (unwrap-panic (contract-call? pool-contract get-pool)))\n  )\n    (not (and (is-eq (contract-of token-in) (get x-token pool-data)) (is-eq (contract-of token-out) (get y-token pool-data))))\n  )\n)\n\n(define-private (scale-up-stableswap-amount\n    (amount uint)\n    (stableswap-token <stableswap-ft-trait>)\n    (alex-token <alex-ft-trait>)\n  )\n  (let (\n    (stableswap-decimals (unwrap-panic (contract-call? stableswap-token get-decimals)))\n    (alex-decimals (unwrap-panic (contract-call? alex-token get-decimals)))\n    (scaled-amount\n      (if (is-eq stableswap-decimals alex-decimals)\n        amount\n        (if (> stableswap-decimals alex-decimals)\n          (/ amount (pow u10 (- stableswap-decimals alex-decimals)))\n          (* amount (pow u10 (- alex-decimals stableswap-decimals)))\n        )\n      )\n    )\n  )\n    (ok scaled-amount)\n  )\n)\n\n(define-private (scale-down-alex-amount\n    (amount uint)\n    (alex-token <alex-ft-trait>)\n    (stableswap-token <stableswap-ft-trait>)\n  )\n  (let (\n    (alex-decimals (unwrap-panic (contract-call? alex-token get-decimals)))\n    (stableswap-decimals (unwrap-panic (contract-call? stableswap-token get-decimals)))\n    (scaled-amount\n      (if (is-eq alex-decimals stableswap-decimals)\n        amount\n        (if (> alex-decimals stableswap-decimals)\n          (/ amount (pow u10 (- alex-decimals stableswap-decimals)))\n          (* amount (pow u10 (- stableswap-decimals alex-decimals)))\n        )\n      )\n    )\n  )\n    (ok scaled-amount)\n  )\n)\n\n(define-private (stableswap-qa\n    (amount uint)\n    (tokens (tuple (a <stableswap-ft-trait>) (b <stableswap-ft-trait>)))\n    (pools (tuple (a <stableswap-pool-trait>)))\n  )\n  (let (\n    (is-reversed (is-stableswap-path-reversed (get a tokens) (get b tokens) (get a pools)))\n    (quote-a (if (is-eq is-reversed false)\n                 (try! (contract-call?\n                 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.stableswap-core-v-1-2 get-dy\n                 (get a pools)\n                 (get a tokens) (get b tokens)\n                 amount))\n                 (try! (contract-call?\n                 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.stableswap-core-v-1-2 get-dx\n                 (get a pools)\n                 (get b tokens) (get a tokens)\n                 amount))))\n  )\n    (ok quote-a)\n  )\n)\n\n(define-private (alex-qa\n    (amount uint)\n    (tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>)))\n    (factors (tuple (a uint)))\n  )\n  (let (\n    (a-token (get a tokens))\n    (b-token (get b tokens))\n    (quote-a (unwrap-panic (contract-call?\n                           'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-helper\n                           (contract-of a-token) (contract-of b-token)\n                           (get a factors)\n                           amount)))\n  )\n    (ok quote-a)\n  )\n)\n\n(define-private (alex-qb\n    (amount uint)\n    (tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>) (c <alex-ft-trait>)))\n    (factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (a-token (get a tokens))\n    (b-token (get b tokens))\n    (c-token (get c tokens))\n    (quote-a (unwrap-panic (contract-call?\n                           'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-helper-a\n                           (contract-of a-token) (contract-of b-token) (contract-of c-token)\n                           (get a factors) (get b factors)\n                           amount)))\n  )\n    (ok quote-a)\n  )\n)\n\n(define-private (alex-qc\n    (amount uint)\n    (tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>) (c <alex-ft-trait>) (d <alex-ft-trait>)))\n    (factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (a-token (get a tokens))\n    (b-token (get b tokens))\n    (c-token (get c tokens))\n    (d-token (get d tokens))\n    (quote-a (unwrap-panic (contract-call?\n                           'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-helper-b\n                           (contract-of a-token) (contract-of b-token) (contract-of c-token)\n                           (contract-of d-token)\n                           (get a factors) (get b factors) (get c factors)\n                           amount)))\n  )\n    (ok quote-a)\n  )\n)\n\n(define-private (alex-qd\n    (amount uint)\n    (tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>) (c <alex-ft-trait>) (d <alex-ft-trait>) (e <alex-ft-trait>)))\n    (factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (a-token (get a tokens))\n    (b-token (get b tokens))\n    (c-token (get c tokens))\n    (d-token (get d tokens))\n    (e-token (get e tokens))\n    (quote-a (unwrap-panic (contract-call?\n                           'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 get-helper-c\n                           (contract-of a-token) (contract-of b-token) (contract-of c-token)\n                           (contract-of d-token) (contract-of e-token)\n                           (get a factors) (get b factors) (get c factors) (get d factors)\n                           amount)))\n  )\n    (ok quote-a)\n  )\n)\n\n(define-private (stableswap-sa\n    (amount uint)\n    (tokens (tuple (a <stableswap-ft-trait>) (b <stableswap-ft-trait>)))\n    (pools (tuple (a <stableswap-pool-trait>)))\n  )\n  (let (\n    (is-reversed (is-stableswap-path-reversed (get a tokens) (get b tokens) (get a pools)))\n    (swap-a (if (is-eq is-reversed false)\n                (try! (contract-call?\n                      'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.stableswap-core-v-1-2 swap-x-for-y\n                      (get a pools)\n                      (get a tokens) (get b tokens)\n                      amount u1))\n                (try! (contract-call?\n                      'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.stableswap-core-v-1-2 swap-y-for-x\n                      (get a pools)\n                      (get b tokens) (get a tokens)\n                      amount u1))))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-private (alex-sa\n    (amount uint)\n    (tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>)))\n    (factors (tuple (a uint)))\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper\n                  (get a tokens) (get b tokens)\n                  (get a factors)\n                  amount (some u1))))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-private (alex-sb\n    (amount uint)\n    (tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>) (c <alex-ft-trait>)))\n    (factors (tuple (a uint) (b uint)))\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper-a\n                  (get a tokens) (get b tokens) (get c tokens)\n                  (get a factors) (get b factors)\n                  amount (some u1))))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-private (alex-sc\n    (amount uint)\n    (tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>) (c <alex-ft-trait>) (d <alex-ft-trait>)))\n    (factors (tuple (a uint) (b uint) (c uint)))\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper-b\n                  (get a tokens) (get b tokens) (get c tokens) (get d tokens)\n                  (get a factors) (get b factors) (get c factors)\n                  amount (some u1))))\n  )\n    (ok swap-a)\n  )\n)\n\n(define-private (alex-sd\n    (amount uint)\n    (tokens (tuple (a <alex-ft-trait>) (b <alex-ft-trait>) (c <alex-ft-trait>) (d <alex-ft-trait>) (e <alex-ft-trait>)))\n    (factors (tuple (a uint) (b uint) (c uint) (d uint)))\n  )\n  (let (\n    (swap-a (try! (contract-call?\n                  'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.amm-pool-v2-01 swap-helper-c\n                  (get a tokens) (get b tokens) (get c tokens) (get d tokens) (get e tokens)\n                  (get a factors) (get b factors) (get c factors) (get d factors)\n                  amount (some u1))))\n  )\n    (ok swap-a)\n  )\n)",
    "analysis": {
      "summary": "This contract facilitates complex swap operations between stableswap and ALEX tokens on the Stacks blockchain.",
      "explanation": "The contract serves as a router to perform swaps involving stableswap pools and ALEX tokens, supporting various swap paths and ensuring that operations adhere to specified conditions. It integrates error handling, admin management, and swap status toggling to maintain operational integrity and flexibility.\n\n1. Constants and Data Variables:\n- Error codes <L7-20> define specific error conditions for contract operations.\n- `CONTRACT_DEPLOYER` <L22> stores the contract deployer's address for admin-related checks.\n- Admins list <L24> and admin helper <L25> manage contract administration roles.\n- Swap status <L27> indicates if swapping is currently enabled or disabled.\n\n2. Functions:\n- `get-admins` <L29-31>, `get-admin-helper` <L33-35>, and `get-swap-status` <L37-39> are read-only functions that return the current state of their respective data variables.\n- `add-admin` <L41-52> and `remove-admin` <L54-67> manage the list of admins, with checks for authorization and list constraints.\n- `set-swap-status` <L69-81> allows admins to enable or disable swap operations.\n- `get-quote-a` <L83-106>, `get-quote-b` <L108-130>, `get-quote-c` <L133-155>, and `get-quote-d` <L158-180> provide quotes for swaps involving different combinations of stableswap and ALEX tokens, with checks for swap status and amount validity.\n- `swap-helper-a` <L183-233>, `swap-helper-b` <L235-285>, `swap-helper-c` <L287-337>, and `swap-helper-d` <L339-388> execute swaps with minimum received checks, supporting various swap paths and token combinations.\n\nEach function includes safety checks for authorization, swap status, and minimum amounts to ensure secure and intended contract operation. The contract leverages Clarity traits for interoperability with stableswap and ALEX token standards, facilitating complex swap logic within a single transaction.\n\nNotable Qualities:\n- Modular design supports multiple swap paths and token combinations.\n- Admin management features enhance contract governance.\n- Comprehensive error handling improves contract reliability and user experience.",
      "tags": ["DeFi", "DEX", "swap", "utility"]
    }
  },
  {
    "rank": 49,
    "contract": "SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.univ2-router-api-v1_0_0",
    "calls": 684,
    "source": ";;; UniswapV2Router02.sol\n\n(use-trait ft-trait 'SP2AKWJYC7BNY18W1XXKPGP0YVEK63QJG4793Z2D4.sip-010-trait-ft-standard.sip-010-trait)\n\n(use-trait pool-trait     .univ2-pool-trait_v1_0_0.univ2-pool-trait)\n(use-trait lp-token-trait .univ2-lp-token-trait_v1_0_0.univ2-lp-token-trait)\n(use-trait fees-trait     .univ2-fees-trait_v1_0_0.univ2-fees-trait)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(define-constant err-router-preconditions  (err u200))\n(define-constant err-router-postconditions (err u201))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; add-liquidity\n(define-private\n  (add-liquidity-calc\n    (pool_        <pool-trait>)\n    (amt0-desired uint)\n    (amt1-desired uint)\n    (amt0-min     uint)\n    (amt1-min     uint))\n  (let ((pool (try! (contract-call? pool_ get-pool)))\n        (r0   (get reserve0 pool))\n        (r1   (get reserve1 pool)))\n    (if (and (is-eq r0 u0) (is-eq r1 u0))\n        (ok {amt0: amt0-desired, amt1: amt1-desired})\n        (let ((amt1-optimal (try! (contract-call? .univ2-library quote amt0-desired r0 r1)))\n              (amt0-optimal (try! (contract-call? .univ2-library quote amt1-desired r1 r0))) )\n            ;; Note we do not use optimal if > desired.\n            (if (<= amt1-optimal amt1-desired)\n                (begin\n                  (asserts! (>= amt1-optimal amt1-min) err-router-preconditions)\n                  (ok {amt0: amt0-desired, amt1: amt1-optimal}))\n                (begin\n                  (asserts!\n                    (and\n                      (<= amt0-optimal amt0-desired)\n                      (>= amt0-optimal amt0-min))\n                    err-router-preconditions)\n                  (ok {amt0: amt0-optimal, amt1: amt1-desired})) )) )))\n\n(define-public\n  (add-liquidity\n    (pool         <pool-trait>)\n    (token0       <ft-trait>)\n    (token1       <ft-trait>)\n    (lp-token     <lp-token-trait>)\n    (amt0-desired uint)\n    (amt1-desired uint)\n    (amt0-min     uint)\n    (amt1-min     uint))\n\n  (let ((amts (try! (add-liquidity-calc\n                pool amt0-desired amt1-desired amt0-min amt1-min))))\n\n    (asserts!\n     (and (<= amt0-min amt0-desired)\n          (<= amt1-min amt1-desired)\n          (>= amt0-min u0)\n          (>= amt1-min u0)\n          (>= amt0-desired u0)\n          (>= amt1-desired u0))\n     err-router-preconditions)\n\n    (contract-call? pool mint\n      token0\n      token1\n      lp-token\n      (get amt0 amts)\n      (get amt1 amts)) ))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; remove-liquidity\n(define-public\n  (remove-liquidity\n    (pool      <pool-trait>)\n    (token0    <ft-trait>)\n    (token1    <ft-trait>)\n    (lp-token  <lp-token-trait>)\n    (liquidity uint)\n    (amt0-min  uint)\n    (amt1-min  uint))\n\n  (let ((event (try! (contract-call? pool burn\n                  token0 token1 lp-token liquidity))))\n\n    (asserts!\n      (and (>= (get amt0 event) amt0-min)\n           (>= (get amt1 event) amt1-min))\n      err-router-postconditions)\n\n    (ok event) ))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; swap\n(define-public\n  (swap-exact-tokens-for-tokens\n    (pool_          <pool-trait>)\n    (token0         <ft-trait>)\n    (token1         <ft-trait>)\n    (token-in       <ft-trait>)\n    (token-out      <ft-trait>)\n    (fees_          <fees-trait>)\n    (amt-in      uint)\n    (amt-out-min uint))\n\n  (let ((pool      (try! (contract-call? pool_ get-pool)))\n        (fees      (try! (contract-call? fees_ get-fees)))\n        (is-token0 (is-eq (contract-of token0) (contract-of token-in)))\n        (amt-out   (try! (contract-call? .univ2-library get-amount-out\n          amt-in\n          (if is-token0 (get reserve0 pool) (get reserve1 pool))\n          (if is-token0 (get reserve1 pool) (get reserve0 pool))\n          (get swap-fee fees) )))\n       (event      (try! (contract-call? pool_ swap\n          token-in\n          token-out\n          fees_\n          amt-in\n          amt-out))) )\n\n    (asserts!\n     (and (is-eq (get token0 pool) (contract-of token0))\n          (is-eq (get token1 pool) (contract-of token1))\n          (> amt-in      u0)\n          (> amt-out-min u0) )\n     err-router-preconditions)\n\n    (asserts!\n      (and (>= (get amt-out event) amt-out-min))\n      err-router-postconditions)\n\n    (ok event) ))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(define-public\n  (swap-tokens-for-exact-tokens\n    (pool_        <pool-trait>)\n    (token0       <ft-trait>)\n    (token1       <ft-trait>)\n    (token-in     <ft-trait>)\n    (token-out    <ft-trait>)\n    (fees_        <fees-trait>)\n    (amt-in-max   uint)\n    (amt-out      uint))\n\n  (let ((pool      (try! (contract-call? pool_ get-pool)))\n        (fees      (try! (contract-call? fees_ get-fees)))\n        (is-token0 (is-eq (contract-of token0) (contract-of token-in)))\n        (amt-in    (try! (contract-call? .univ2-library get-amount-in\n          amt-out\n          (if is-token0 (get reserve0 pool) (get reserve1 pool))\n          (if is-token0 (get reserve1 pool) (get reserve0 pool))\n          (get swap-fee fees) )))\n        (event     (try! (contract-call? pool_ swap\n          token-in\n          token-out\n          fees_\n          amt-in\n          amt-out))) )\n\n  (asserts!\n   (and (is-eq (get token0 pool) (contract-of token0))\n        (is-eq (get token1 pool) (contract-of token1))\n        (> amt-in-max u0)\n        (> amt-out    u0) )\n   err-router-preconditions)\n\n  (asserts!\n    (and (<= (get amt-in event) amt-in-max))\n    err-router-postconditions)\n\n  (ok event) ))\n\n;;; eof\n",
    "analysis": {
      "summary": "This contract acts as a router for adding liquidity, removing liquidity, and swapping tokens in a UniswapV2-like decentralized exchange on the Stacks blockchain.",
      "explanation": "The contract integrates with a decentralized exchange by providing functions to add or remove liquidity from pools and to swap tokens. It uses external pool and token contracts, adhering to specified traits for interoperability.\n\n1. Constants and error codes are defined for signaling errors in router operations <L10-11>.\n\n2. The 'add-liquidity-calc' function <L15-40> calculates the optimal amount of tokens to add to a liquidity pool to maintain price ratios, using the 'quote' function from a library contract for price calculations. It ensures that the amounts added are within user-specified bounds.\n   - 'pool_' is a reference to the liquidity pool contract <L17>.\n   - 'amt0-desired' and 'amt1-desired' are the amounts of the two tokens the user wishes to add <L18-19>.\n   - 'amt0-min' and 'amt1-min' are the minimum amounts of tokens the user is willing to add, for slippage protection <L20-21>.\n\n3. The 'add-liquidity' function <L42-70> allows users to add liquidity to a pool, calling 'add-liquidity-calc' to determine the optimal amounts of tokens to deposit and then interacting with the pool contract to mint liquidity provider tokens.\n\n4. 'remove-liquidity' <L74-92> enables liquidity providers to remove their liquidity from a pool, receiving a proportionate amount of the underlying assets back. It calls the pool's 'burn' function and checks that the amounts received are not less than specified minimums.\n\n5. 'swap-exact-tokens-for-tokens' <L96-133> and 'swap-tokens-for-exact-tokens' <L136-173> are functions for swapping tokens. They calculate the amount of input or output tokens for a swap, ensuring the trade meets the user's constraints on amounts and fees. These functions interact with the pool contract to execute the swap and with a fees contract to apply trading fees.\n\nEach function includes safety checks, such as ensuring the input amounts are positive and that the output amounts meet the user's minimum requirements. The contract interacts with external contracts for pools, tokens, and fees, using Clarity traits to ensure compatibility.",
      "tags": ["DEX", "liquidity", "swap", "DeFi"],
      "notable_qualities": [
        "Uses external contracts through traits for modularity and interoperability.",
        "Includes detailed error handling and pre/post condition checks for robustness.",
        "Employs an external library contract for price calculation, demonstrating how to extend contract functionality.",
        "Designed to support a UniswapV2-like decentralized exchange architecture on the Stacks blockchain, showcasing the potential for complex DeFi applications."
      ]
    }
  },
  {
    "rank": 50,
    "contract": "SP21YTSM60CAY6D011EZVEVNKXVW8FVZE198XEFFP.pox4-fast-pool-v3",
    "calls": 671,
    "source": ";; @contract pox-4 Self-Service Pool\n;; @version 3\n;; Changelog: update to pox-4, introduce commit admin\n\n;; Self-service non-custodial stacking pool\n;; The pool locks for 1 cycle, amount can be increased at each cycle.\n;; Users trust the reward admin that they will receive their share of rewards.\n;; Reward admin can be a contract as well.\n;;\n;;\n;; User calls delegate-stx once.\n;; For next cycles, users can call delegate-stx\n;; or ask automation, friends or family to extend stacking using delegate-stack-stx.\n\n;; Self-service function \"delegate-stx\" does the following:\n;; 1. Revoke delegation if necessary.\n;; 2. Delegates STX.\n;; 3. For first time user, stacks the caller's stx tokens for 1 cycle.\n;;    For stackerd user, extends locking and if needed increases amount.\n;;    The amount is the minimum of the balance and the delegate amount\n;;    minus some STX as buffer.\n;;    The STX buffer is left unlocked for users to call revoke-delegate-stx.\n\n;; Pool operators function \"delegate-stack-stx\" does\n;; step 3. (for stacked users)\n;; This function can be called by anyone when less than 1050 blocks are\n;; left until the cycle start. This gives the stacker 1 week to unlock\n;; the STX if wanted before it can be locked again for friends and family (or enemies).\n\n;; Commit admins are trusted users who can commit the partically stacked STX\n;; at the end of each cycle.\n;; The commit transaction contains a signature from the selected signer node.\n\n;;\n;; Data storage\n;;\n\n;; Map of reward cycle to pox reward set index.\n;; Reward set index gives access to the total locked stx of the pool.\n(define-map pox-addr-indices uint uint)\n;; Map of reward cyle to block height of last commit\n(define-map last-aggregation uint uint)\n;; Map of users to locked amounts with this pool\n;; used to handle pool members swimming in two pools\n(define-map locked-amounts principal {amount-ustx: uint, unlock-height: uint})\n;; Map of admins that can change the pox-address\n(define-map reward-admins principal bool)\n(map-set reward-admins tx-sender true)\n\n(define-data-var active bool false)\n(define-data-var pool-pox-address {hashbytes: (buff 32), version: (buff 1)}\n  {version: 0x,\n   hashbytes: 0x})\n(define-data-var stx-buffer uint u1000000) ;; 1 STX\n\n(define-constant pox-info (unwrap-panic (contract-call? 'SP000000000000000000002Q6VF78.pox-4 get-pox-info)))\n;; Half cycle lenght is 1050 for mainnet\n(define-constant half-cycle-length (/ (get reward-cycle-length pox-info) u2))\n\n(define-constant err-unauthorized (err u401))\n(define-constant err-forbidden (err u403))\n(define-constant err-too-early (err u500))\n(define-constant err-decrease-forbidden (err u503))\n(define-constant err-pox-address-deactivated (err u504))\n;; Error code 3 is used by pox-4 contract for already stacking errors\n(define-constant err-already-stacking (err u603))\n;; Error code 9 is used by pox-4 contract for permission denied errors\n(define-constant err-stacking-permission-denied (err u609))\n;; Allowed contract-callers handling a user's stacking activity.\n(define-map allowance-contract-callers\n  { sender: principal, contract-caller: principal}\n  { until-burn-ht: (optional uint)})\n\n\n;;\n;; Helper functions for pox-4 calls\n;;\n\n;; Revokes and delegates stx\n(define-private (delegate-stx-inner (amount-ustx uint) (delegate-to principal) (until-burn-ht (optional uint)))\n  (let ((result-revoke\n            ;; Calls revoke and ignores result\n          (contract-call? 'SP000000000000000000002Q6VF78.pox-4 revoke-delegate-stx)))\n    ;; Calls delegate-stx, converts any error to uint\n    (match (contract-call? 'SP000000000000000000002Q6VF78.pox-4 delegate-stx amount-ustx delegate-to until-burn-ht none)\n      success (ok success)\n      error (err (* u1000 (to-uint error))))))\n\n;; Tries to lock delegated stx (delegate-stack-stx).\n;; If user already stacked then extend and increase\n(define-private (lock-delegated-stx (user principal))\n  (let ((start-burn-ht (+ burn-block-height u1))\n        (pox-address (var-get pool-pox-address))\n        (buffer-amount (var-get stx-buffer))\n        (user-account (stx-account user))\n        (allowed-amount (min (get-delegated-amount user)\n                             (+ (get locked user-account) (get unlocked user-account))))\n        ;; Amount to lock must be leq allowed-amount and geq locked amount.\n        ;; Increase the locked amount if possible, but leave a buffer for revoke tx fees if possible.\n        ;; Decreasing the locked amount requires a cool down cycle.\n        (amount-ustx (if (> allowed-amount buffer-amount)\n                            (max (get locked user-account) (- allowed-amount buffer-amount))\n                            allowed-amount)))\n    (asserts! (var-get active) err-pox-address-deactivated)\n    (match (contract-call? 'SP000000000000000000002Q6VF78.pox-4 delegate-stack-stx\n             user amount-ustx\n             pox-address start-burn-ht u1)\n      stacker-details  (begin\n                          (map-set locked-amounts user {amount-ustx: amount-ustx, unlock-height: (get unlock-burn-height stacker-details)})\n                          (ok stacker-details))\n      error (if (is-eq error 3) ;; check whether user is already stacked\n              (delegate-stack-extend-increase user amount-ustx pox-address)\n              (err (* u1000 (to-uint error)))))))\n\n(define-private (lock-delegated-stx-fold (user principal) (result (list 30 (response {lock-amount: uint, stacker: principal, unlock-burn-height: uint} uint))))\n  (let ((stack-result (lock-delegated-stx user)))\n    (unwrap-panic (as-max-len? (append result stack-result) u30))))\n\n;; Calls pox-4 delegate-stack-extend and delegate-stack-increase.\n;; parameter amount-ustx must be lower or equal the stx balance and the delegated amount\n(define-private (delegate-stack-extend-increase (user principal)\n                  (amount-ustx uint)\n                  (pox-address {hashbytes: (buff 32), version: (buff 1)}))\n  (let ((status (stx-account user))\n        (locked-amount (get locked status)))\n    (asserts! (>= amount-ustx locked-amount) err-decrease-forbidden)\n    (match (maybe-extend-for-next-cycle user pox-address status)\n      success-extend (let ((unlock-burn-height (get unlock-burn-height success-extend)))\n            (if (is-eq amount-ustx locked-amount)\n                ;; do not increase\n                (begin\n                  ;; update locked-amounts map if necessary\n                  (asserts! (> unlock-burn-height (get unlock-height status)) err-already-stacking)\n                  (map-extend-locked-amount user unlock-burn-height)\n                  (ok {lock-amount: locked-amount,\n                      stacker: user,\n                      unlock-burn-height: unlock-burn-height}))\n                ;; else increase\n                (let ((increase-by (- amount-ustx locked-amount)))\n                  (match (contract-call? 'SP000000000000000000002Q6VF78.pox-4 delegate-stack-increase\n                          user pox-address increase-by)\n                    success-increase (begin\n                                      (map-extend-increase-locked-amount user increase-by unlock-burn-height)\n                                      (ok {lock-amount: (get total-locked success-increase),\n                                          stacker: user,\n                                          unlock-burn-height: unlock-burn-height}))\n                    error-increase (err (* u1000000000 (to-uint error-increase)))))))\n      error (err (* u1000000 (to-uint error))))))\n\n;; Tries to extend the user's locking to the next cycle\n;; if not yet locked until the end of the next cycle.\n(define-private (maybe-extend-for-next-cycle\n                  (user principal)\n                  (pox-address {hashbytes: (buff 32), version: (buff 1)})\n                  (status {locked: uint, unlocked: uint, unlock-height: uint})\n                )\n  (let ((current-cycle (contract-call? 'SP000000000000000000002Q6VF78.pox-4 current-pox-reward-cycle))\n        (unlock-height (get unlock-height status)))\n    (if (not-locked-for-cycle unlock-height (+ u1 current-cycle))\n      (contract-call? 'SP000000000000000000002Q6VF78.pox-4 delegate-stack-extend\n             user pox-address u1) ;; one cycle only\n      (ok {stacker: user, unlock-burn-height: unlock-height}))))\n\n(define-private (map-extend-locked-amount (user principal) (unlock-height uint))\n  (match (map-get? locked-amounts user)\n    locked-amount (map-set locked-amounts user (merge locked-amount {unlock-height: unlock-height}))\n    true))\n\n(define-private (map-extend-increase-locked-amount (user principal) (increase-by uint) (unlock-height uint))\n  (match (map-get? locked-amounts user)\n    locked-amount (map-set locked-amounts user {amount-ustx: (+ (get amount-ustx locked-amount) increase-by), unlock-height: unlock-height})\n    true))\n\n;;\n;; Public functions\n;;\n\n;; @desc User calls this function to delegate and lock their tokens to the self-service pool.\n;; Users can revoke delegation and stx tokens will unlock at the end of the locking period.\n;;\n;; @param amount-ustx; amount to delegate. Can be higher than current stx balance.\n(define-public (delegate-stx (amount-ustx uint))\n  (let ((user tx-sender)\n        (current-cycle (current-pox-reward-cycle)))\n    ;; Must be called directly by the tx-sender or by an allowed contract-caller\n    (asserts! (check-caller-allowed) err-stacking-permission-denied)\n    ;; Do 1. and 2.\n    (try! (delegate-stx-inner amount-ustx (as-contract tx-sender) none))\n    ;; Do 3.\n    (as-contract (lock-delegated-stx user))))\n\n;; Stacks the delegated amount for the given user for the next cycle.\n;; This function can be called by automation, friends or family for user that have delegated once.\n;; This function can be called only after the current cycle is half through\n(define-public (delegate-stack-stx (user principal))\n  (let ((current-cycle (current-pox-reward-cycle)))\n    (asserts! (can-lock-now current-cycle) err-too-early)\n    ;; Do 3.\n    (as-contract (lock-delegated-stx user))))\n\n;; Stacks the delegated amount for the given users for the next cycle.\n;; This function can be called by automation, friends or family for users that have delegated once.\n;; This function can be called only after the current cycle is half through\n(define-public (delegate-stack-stx-many (users (list 30 principal)))\n  (let ((current-cycle (current-pox-reward-cycle))\n        (start-burn-ht (+ burn-block-height u1)))\n    (asserts! (can-lock-now current-cycle) err-too-early)\n    ;; Do 3. for users\n    (ok (as-contract (fold lock-delegated-stx-fold users (list))))))\n\n;; Tries to calls stack aggregation commit. If the minimum is met,\n;; subsequent calls increase the total amount using\n;; the index of the first successful call.\n;; This index gives access to the internal map of the pox-4 contract\n;; that handles the reward addresses.\n(define-public (maybe-stack-aggregation-commit (current-cycle uint)\n                  (signer-sig (optional (buff 65))) (signer-key (buff 33))\n                  (max-amount uint) (auth-id uint))\n  (let ((reward-cycle (+ u1 current-cycle)))\n    (match (map-get? pox-addr-indices reward-cycle)\n            ;; Total stacked already reached minimum.\n            ;; Call stack-aggregate-increase.\n            ;; It might fail because called in the same cycle twice.\n      index (match (as-contract (contract-call? 'SP000000000000000000002Q6VF78.pox-4 stack-aggregation-increase (var-get pool-pox-address) reward-cycle index signer-sig signer-key max-amount auth-id))\n              success (begin (map-set last-aggregation reward-cycle block-height) (ok true))\n              error (begin (print {err-increase-ignored: error}) (ok false)))\n            ;; Total stacked is still below minimum.\n            ;; Just try to commit, it might fail because minimum not yet met\n      (match (as-contract (contract-call? 'SP000000000000000000002Q6VF78.pox-4 stack-aggregation-commit-indexed (var-get pool-pox-address) reward-cycle signer-sig signer-key max-amount auth-id))\n        index (begin\n                (map-set pox-addr-indices reward-cycle index)\n                (map-set last-aggregation reward-cycle block-height)\n                (ok true))\n        error (begin (print {err-commit-ignored: error}) (ok false)))))) ;; ignore errors\n\n;;\n;; Admin functions\n;;\n\n(define-public (set-active (is-active bool))\n  (begin\n    (asserts! (default-to false (map-get? reward-admins contract-caller)) err-unauthorized)\n    (ok (var-set active is-active))))\n\n(define-public (set-pool-pox-address (pox-addr {hashbytes: (buff 32), version: (buff 1)}))\n  (begin\n    (asserts! (default-to false (map-get? reward-admins contract-caller)) err-unauthorized)\n    (ok (var-set pool-pox-address pox-addr))))\n\n(define-public (set-pool-pox-address-active (pox-addr {hashbytes: (buff 32), version: (buff 1)}))\n  (begin\n    (asserts! (default-to false (map-get? reward-admins contract-caller)) err-unauthorized)\n    (var-set pool-pox-address pox-addr)\n    (ok (var-set active true))))\n\n(define-public (set-stx-buffer (amount-ustx uint))\n  (begin\n    (asserts! (default-to false (map-get? reward-admins contract-caller)) err-unauthorized)\n    (ok (var-set stx-buffer amount-ustx))))\n\n(define-public (set-reward-admin (new-admin principal) (enable bool))\n  (begin\n    (asserts! (default-to false (map-get? reward-admins contract-caller)) err-unauthorized)\n    (asserts! (not (is-eq contract-caller new-admin)) err-forbidden)\n    (ok (map-set reward-admins new-admin enable))))\n\n;;\n;; Read-only functions\n;;\n\n;; What's the reward cycle number of the burnchain block height?\n;; Will runtime-abort if height is less than the first burnchain block (this is intentional)\n(define-read-only (burn-height-to-reward-cycle (height uint))\n    (/ (- height (get first-burnchain-block-height pox-info)) (get reward-cycle-length pox-info)))\n\n;; What's the block height at the start of a given reward cycle?\n(define-read-only (reward-cycle-to-burn-height (cycle uint))\n    (+ (get first-burnchain-block-height pox-info) (* cycle (get reward-cycle-length pox-info))))\n\n;; What's the current PoX reward cycle?\n(define-read-only (current-pox-reward-cycle)\n    (burn-height-to-reward-cycle burn-block-height))\n\n;; Total of locked stacked by cycle.\n;; Function get-reward-set-pox-address contains the information but\n;; is deleted when stx unlock.\n;; Therefore, we look at the value at the end of that cycle, more\n;; precisely at the last stack-aggregation-* call for the next cycle (that happens\n;; during the request cycle).\n(define-read-only (get-reward-set (reward-cycle uint))\n  (match (print (map-get? last-aggregation (+ reward-cycle u1)))\n    stacks-height (get-reward-set-at-block reward-cycle stacks-height)\n    none))\n\n(define-read-only (get-reward-set-at-block (reward-cycle uint) (stacks-height uint))\n  (at-block (unwrap! (get-block-info? id-header-hash stacks-height) none)\n    (get-reward-set-from-pox reward-cycle)))\n\n(define-read-only (get-reward-set-from-pox (reward-cycle uint))\n  (match (map-get? pox-addr-indices reward-cycle)\n      index (contract-call? 'SP000000000000000000002Q6VF78.pox-4 get-reward-set-pox-address reward-cycle index)\n      none))\n\n;; Returns currently delegated amount for a given user\n(define-read-only (get-delegated-amount (user principal))\n  (default-to u0 (get amount-ustx (contract-call? 'SP000000000000000000002Q6VF78.pox-4 get-delegation-info user))))\n\n(define-read-only (get-pox-addr-index (cycle uint))\n  (map-get? pox-addr-indices cycle))\n\n(define-read-only (not-locked-for-cycle (unlock-burn-height uint) (cycle uint))\n  (<= unlock-burn-height (reward-cycle-to-burn-height cycle)))\n\n(define-read-only (get-last-aggregation (cycle uint))\n  (map-get? last-aggregation cycle))\n\n(define-read-only (is-admin-enabled (admin principal))\n  (map-get? reward-admins admin))\n\n(define-read-only (get-pool-pox-address)\n  (var-get pool-pox-address))\n\n(define-read-only (can-lock-now (cycle uint))\n  (> burn-block-height (+ (reward-cycle-to-burn-height cycle) half-cycle-length)))\n\n;; Returns minimum\n(define-private (min (amount-1 uint) (amount-2 uint))\n  (if (< amount-1 amount-2)\n    amount-1\n    amount-2))\n\n;; Returns maximum\n(define-private (max (amount-1 uint) (amount-2 uint))\n  (if (> amount-1 amount-2)\n    amount-1\n    amount-2))\n\n;;\n;; Functions about allowance of delegation/stacking contract calls\n;;\n\n;; Give a contract-caller authorization to call stacking methods\n;;  normally, stacking methods may only be invoked by _direct_ transactions\n;;   (i.e., the tx-sender issues a direct contract-call to the stacking methods)\n;;  by issuing an allowance, the tx-sender may call through the allowed contract\n(define-public (allow-contract-caller (caller principal) (until-burn-ht (optional uint)))\n  (begin\n    (asserts! (is-eq tx-sender contract-caller) err-stacking-permission-denied)\n    (ok (map-set allowance-contract-callers\n          { sender: tx-sender, contract-caller: caller}\n          { until-burn-ht: until-burn-ht}))))\n\n;; Revokes contract-caller authorization to call stacking methods\n(define-public (disallow-contract-caller (caller principal))\n  (begin\n    (asserts! (is-eq tx-sender contract-caller) err-stacking-permission-denied)\n    (ok (map-delete allowance-contract-callers { sender: tx-sender, contract-caller: caller}))))\n\n;; Verifies that the contract caller has allowance to handle the tx-sender's stacking\n(define-read-only (check-caller-allowed)\n  (or (is-eq tx-sender contract-caller)\n    (let ((caller-allowed\n                 ;; if not in the caller map, return false\n            (unwrap! (map-get? allowance-contract-callers\n                       { sender: tx-sender, contract-caller: contract-caller})\n              false))\n          (expires-at\n                ;; if until-burn-ht not set, then return true (because no expiry)\n            (unwrap! (get until-burn-ht caller-allowed) true)))\n          ;; is the caller allowance still valid\n      (< burn-block-height expires-at))))\n\n;; Returns the burn height at which a particular contract is allowed to stack for a particular principal.\n;; The result is (some (some X)) if X is the burn height at which the allowance terminates.\n;; The result is (some none) if the caller is allowed indefinitely.\n;; The result is none if there is no allowance record.\n(define-read-only (get-allowance-contract-callers (sender principal) (calling-contract principal))\n  (map-get? allowance-contract-callers { sender: sender, contract-caller: calling-contract}))\n",
    "analysis": {
      "summary": "This contract implements a non-custodial, self-service stacking pool for the Stacks blockchain, allowing users to delegate and stack their STX tokens, with features for extending stacking and managing rewards.",
      "explanation": "The contract facilitates a decentralized pooling mechanism for users wishing to participate in Stacks' Proof of Transfer (PoX) stacking without meeting the protocol's minimum threshold individually. Users delegate their STX to the pool, which then stacks the tokens on their behalf, potentially earning Bitcoin rewards that are distributed according to each participant's share in the pool.\n\nData vars and constants:\n- `pox-addr-indices`, `last-aggregation`, `locked-amounts`, `reward-admins` maps <L38-47> track pool indices, last commit heights, user locked amounts, and admin privileges, respectively.\n- `active`, `pool-pox-address`, `stx-buffer` data vars <L50-54> indicate pool status, address for rewards, and a buffer amount of STX left unlocked.\n- `pox-info`, `half-cycle-length`, and various error constants <L56-68> store PoX contract info, cycle lengths, and error codes for standardization.\n\nFunctions:\n- `delegate-stx-inner` <L79-87> revokes any previous delegation and delegates STX to the pool's address.\n- `lock-delegated-stx` <L89-113> locks the delegated STX for stacking, extending locking if already stacked, or increasing the amount if possible.\n- `delegate-stack-stx`, `delegate-stack-stx-many` <L192-209> enable users or their representatives to stack delegated STX for the next cycle.\n- Admin functions <L240-265> allow designated admins to modify pool settings and manage reward distribution.\n\nNotable qualities:\n- The contract integrates closely with the PoX protocol, extending its functionality to users with smaller amounts of STX.\n- It introduces a level of automation and delegation not inherent to the base PoX protocol, allowing for more flexible participation in stacking.\n- The contract design considers security and user autonomy, providing mechanisms for revoking delegation and managing permissions.",
      "tags": ["staking", "utility", "protocol"]
    }
  }
]
